<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数学建模学习笔记 | 青墨染烟雨</title><meta name="author" content="Chen Jiabin,2948429338@qq.com"><meta name="copyright" content="Chen Jiabin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为了应对数学建模比赛准备的笔记，内容包括各类的评价方法和优化方法">
<meta property="og:type" content="article">
<meta property="og:title" content="数学建模学习笔记">
<meta property="og:url" content="https://qinmoranyanyu.github.io/2025/03/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="青墨染烟雨">
<meta property="og:description" content="为了应对数学建模比赛准备的笔记，内容包括各类的评价方法和优化方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png">
<meta property="article:published_time" content="2025-03-01T09:58:28.000Z">
<meta property="article:modified_time" content="2025-03-01T10:06:15.823Z">
<meta property="article:author" content="Chen Jiabin">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数学建模学习笔记",
  "url": "https://qinmoranyanyu.github.io/2025/03/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png",
  "datePublished": "2025-03-01T09:58:28.000Z",
  "dateModified": "2025-03-01T10:06:15.823Z",
  "author": [
    {
      "@type": "Person",
      "name": "Chen Jiabin",
      "url": "https://qinmoranyanyu.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011641807.svg"><link rel="canonical" href="https://qinmoranyanyu.github.io/2025/03/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="4yH3_EEqHZ9_glXp2Ey1UlNzL_EQ2NQ0TO1lAXhBrvE"/><meta name="baidu-site-verification" content="codeva-dQzACO1Fjm"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数学建模学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011603481.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-bars"></i><span> 推荐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fa-solid fa-headphones"></i><span> 歌曲</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa-solid fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011641807.svg" alt="Logo"><span class="site-name">青墨染烟雨</span></a><a class="nav-page-title" href="/"><span class="site-name">数学建模学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-bars"></i><span> 推荐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fa-solid fa-headphones"></i><span> 歌曲</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa-solid fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数学建模学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T09:58:28.000Z" title="发表于 2025-03-01 17:58:28">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-01T10:06:15.823Z" title="更新于 2025-03-01 18:06:15">2025-03-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">26.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/03/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<h1 id="评价类方法"><a href="#评价类方法" class="headerlink" title="评价类方法"></a>评价类方法</h1><h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>虫部落‐快搜 ： <a target="_blank" rel="noopener" href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1.写出判断矩阵</p>
<p>2.判断矩阵一致性检验</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751412.png" style="zoom: 67%;" />

<p>3.判断矩阵求权重</p>
<ol>
<li><p>算术平均法</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751477.png" style="zoom: 67%;" />
</li>
<li><p>几何平均法</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751426.png" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;特征值法（最常用）&#x3D;&#x3D;</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751498.png" style="zoom:67%;" /></li>
</ol>
<p>4.计算权重和</p>
<h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 注意：在论文写作中，应该先对判断矩阵进行一致性检验，然后再计算权重，因为只有判断矩阵通过了一致性检验，其权重才是有意义的。</span></span><br><span class="line"><span class="comment">%% 在下面的代码中，我们先计算了权重，然后再进行了一致性检验，这是为了顺应计算过程，事实上在逻辑上是说不过去的。</span></span><br><span class="line"><span class="comment">%% 因此大家自己写论文中如果用到了层次分析法，一定要先对判断矩阵进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 而且要说明的是，只有非一致矩阵的判断矩阵才需要进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 如果你的判断矩阵本身就是一个一致矩阵，那么就没有必要进行一致性检验。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 在每一行的语句后面加上分号(一定要是英文的哦;中文的长这个样子；)表示不显示运行结果</span></span><br><span class="line"><span class="comment">% 多行注释:选中要注释的若干语句,快捷键Ctrl+R</span></span><br><span class="line"><span class="comment">% 取消注释:选中要取消注释的语句,快捷键Ctrl+T</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;请输入判断矩阵A&#x27;</span>)  <span class="comment">%matlab中disp()就是屏幕输出函数，类似于c语言中的printf（）函数</span></span><br><span class="line"><span class="comment">% 注意，disp函数比较特殊，这里可要分号，可不要分号哦</span></span><br><span class="line"></span><br><span class="line">A=input(<span class="string">&#x27;A=&#x27;</span>);</span><br><span class="line"><span class="comment">% 这里输入的就是我们的判断矩阵，其为n阶方阵（行数和列数相同）</span></span><br><span class="line"><span class="comment">% [1 3 1/3 1/3 1 1/3;1/3 1 1/4 1/5 1 1/5;3 4 1 1 2 3;3 5 1 1 2 1;1 1 1/2 1/2 1 1;3 5 1/3 1 1 1]</span></span><br><span class="line"><span class="comment">% [1 1 4 1/3 3;1 1 4 1/3 3;1/4 1/4 1 1/3 1/2;3 3 3 1 3;1/3 1/3 2 1/3 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 在开始下面正式的步骤之前，我们有必要检验下A是否因为粗心而输入有误</span></span><br><span class="line">ERROR = <span class="number">0</span>;  <span class="comment">% 默认输入是没有错误的</span></span><br><span class="line"><span class="comment">%(1)检查矩阵A的维数是否不大于1或不是方阵</span></span><br><span class="line">[r,c]=<span class="built_in">size</span>(A);</span><br><span class="line"><span class="comment">%size(A)函数是用来求矩阵的大小的,返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</span></span><br><span class="line"><span class="comment">%[r,c]=size(A)  %将矩阵A的行数返回到第一个输出变量r，将矩阵的列数返回到第二个输出变量c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r ~= c  || r &lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment">% 注意哦，不等号是 ~=  (~是键盘Tab上面那个键，要和Shift键同时按才会出来)，别和C语言里面的!=搞混了</span></span><br><span class="line">    <span class="comment">% ||表示逻辑运算符‘或’（在键盘Enter上面，也要和Shift键一起按） 逻辑运算符且是 &amp;&amp; （&amp;读and，连接符号，是and的缩写。 ）</span></span><br><span class="line">    ERROR = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%(2)检验是否为正互反矩阵  a_ij &gt; 0 且 a_ij * a_ji = 1</span></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    [n,n] = <span class="built_in">size</span>(A);</span><br><span class="line">    <span class="comment">% 因为我们的判断矩阵A是一个非零方阵，所以这里的r和c相同，我们可以就用同一个字母n表示</span></span><br><span class="line">    <span class="comment">% 判断是否有元素小于0</span></span><br><span class="line">    <span class="comment">%    for i = 1:n</span></span><br><span class="line">    <span class="comment">%        for j = 1:n</span></span><br><span class="line">    <span class="comment">%            if A(i,j)&lt;=0</span></span><br><span class="line">    <span class="comment">%                ERROR = 2;</span></span><br><span class="line">    <span class="comment">%            end</span></span><br><span class="line">    <span class="comment">%        end</span></span><br><span class="line">    <span class="comment">%    end</span></span><br><span class="line">    <span class="keyword">if</span> sum(sum(A &lt;= <span class="number">0</span>)) &gt; <span class="number">0</span></span><br><span class="line">        ERROR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%顺便检验n是否超过了15，因为RI向量为15维</span></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">15</span></span><br><span class="line">        ERROR = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    <span class="comment">% 判断  a_ij * a_ji = 1 是否成立</span></span><br><span class="line">    <span class="keyword">if</span> sum(sum(A&#x27; .* A ~=  <span class="built_in">ones</span>(n))) &gt; <span class="number">0</span></span><br><span class="line">        ERROR = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% A&#x27; 表示求出 A 的转置矩阵，即将a_ij和a_ji互换位置</span></span><br><span class="line">    <span class="comment">% ones(n)函数生成一个n*n的全为1的方阵, zeros(n)函数生成一个n*n的全为0的方阵</span></span><br><span class="line">    <span class="comment">% ones(m,n)函数生成一个m*n的全为1的矩阵</span></span><br><span class="line">    <span class="comment">% MATLAB在矩阵的运算中，“/”号和“*”号代表矩阵之间的乘法与除法，对应元素之间的乘除法需要使用“./”和“.*”</span></span><br><span class="line">    <span class="comment">% 如果a_ij * a_ji = 1 满足， 那么A和A&#x27;对应元素相乘应该为1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ERROR == <span class="number">0</span></span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %方法1： 算术平均法求权重% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</span></span><br><span class="line">    <span class="comment">% 第二步：将归一化的各列相加</span></span><br><span class="line">    <span class="comment">% 第三步：将相加后的向量除以n即可得到权重向量</span></span><br><span class="line">    </span><br><span class="line">    Sum_A = sum(A);</span><br><span class="line">    <span class="comment">% matlab中的sum函数的用法</span></span><br><span class="line">    <span class="comment">% a=sum(x);%按列求和</span></span><br><span class="line">    <span class="comment">% a=sum(x,2);%按行求和</span></span><br><span class="line">    <span class="comment">% a=sum(x(:));%对整个矩阵求和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % 基础：matlab中如何提取矩阵中指定位置的元素？</span></span><br><span class="line">    <span class="comment">% % （1）取指定行和列的一个元素（输出的是一个值）</span></span><br><span class="line">    <span class="comment">% %     A(2,1)  A(3,2)</span></span><br><span class="line">    <span class="comment">% % （2）取指定的某一行的全部元素（输出的是一个行向量）</span></span><br><span class="line">    <span class="comment">% %     A(2,:)  A(5,:)</span></span><br><span class="line">    <span class="comment">% % （3）取指定的某一列的全部元素（输出的是一个列向量）</span></span><br><span class="line">    <span class="comment">% %     A(:,1)  A(:,3)</span></span><br><span class="line">    <span class="comment">% % （4）取指定的某些行的全部元素（输出的是一个矩阵）</span></span><br><span class="line">    <span class="comment">% %    A([2,5],:)      只取第二行和第五行（一共2行）</span></span><br><span class="line">    <span class="comment">% %    A(2:5,:)        取第二行到第五行（一共4行）</span></span><br><span class="line">    <span class="comment">% % （5）取全部元素(按列拼接的，最终输出的是一个列向量)</span></span><br><span class="line">    <span class="comment">% %    A(:)</span></span><br><span class="line">    </span><br><span class="line">    SUM_A = <span class="built_in">repmat</span>(Sum_A,n,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">% B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</span></span><br><span class="line">    <span class="comment">% 另外一种替代的方法如下：</span></span><br><span class="line">    <span class="comment">% SUM_A = [];</span></span><br><span class="line">    <span class="comment">% for i = 1:n  %循环哦，不需要加冒号，这里表示循环n次</span></span><br><span class="line">    <span class="comment">%     SUM_A = [SUM_A;Sum_A];</span></span><br><span class="line">    <span class="comment">% end</span></span><br><span class="line">    </span><br><span class="line">    Stand_A = A ./ SUM_A;</span><br><span class="line">    <span class="comment">% MATLAB在矩阵的运算中，“*”号和“/”号代表矩阵之间的乘法与除法，对应元素之间的乘除法需要使用“./”和“.*”</span></span><br><span class="line">    <span class="comment">% 这里我们直接将两个矩阵对应的元素相除即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;算术平均法求权重的结果为：&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(sum(Stand_A,<span class="number">2</span>) / n)</span><br><span class="line">    <span class="comment">% 首先对标准化后的矩阵按照行求和，得到一个列向量，然后再将这个列向量的每个元素同时除以n即可（注意这里也可以用./哦）</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %方法2： 几何平均法求权重% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 第一步：将A的元素按照行相乘得到一个新的列向量</span></span><br><span class="line">    Prduct_A = prod(A,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% prod函数和sum函数类似，一个用于乘，一个用于加</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 第二步：将新的向量的每个分量开n次方</span></span><br><span class="line">    Prduct_n_A = Prduct_A .^ (<span class="number">1</span>/n);</span><br><span class="line">    <span class="comment">% 这里对元素操作，因此要加.号哦。  ^符号表示乘方哦  这里是开n次方，所以我们等价求1/n次方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 第三步：对该列向量进行归一化即可得到权重向量</span></span><br><span class="line">    <span class="comment">% 将这个列向量中的每一个元素除以这一个向量的和即可</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;几何平均法求权重的结果为：&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %方法3： 特征值法求权重% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 计算矩阵A的特征值和特征向量的函数是eig(A),其中最常用的两个用法：</span></span><br><span class="line">    <span class="comment">% （1）E=eig(A)：求矩阵A的全部特征值，构成向量E。</span></span><br><span class="line">    <span class="comment">% （2）[V,D]=eig(A)：求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。（V的每一列都是D中与之相同列的特征值的特征向量）</span></span><br><span class="line">    [V,D] = eig(A);    <span class="comment">%V是特征向量, D是由特征值构成的对角矩阵（除了对角线元素外，其余位置元素全为0）</span></span><br><span class="line">    Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D)); <span class="comment">%也可以写成max(D(:))哦~</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 那么怎么找到最大特征值所在的位置了？ 需要用到find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</span></span><br><span class="line">    <span class="comment">% 下面例子来自博客：https://www.cnblogs.com/anzhiwu815/p/5907033.html</span></span><br><span class="line">    <span class="comment">% 关于find函数的更加深入的用法可参考原文</span></span><br><span class="line">    <span class="comment">% &gt;&gt; X = [1 0 4 -3 0 0 0 8 6];</span></span><br><span class="line">    <span class="comment">% &gt;&gt; ind = find(X)</span></span><br><span class="line">    <span class="comment">% ind =</span></span><br><span class="line">    <span class="comment">%    1     3     4     8     9</span></span><br><span class="line">    <span class="comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span></span><br><span class="line">    <span class="comment">% &gt;&gt; ind = find(X,2)</span></span><br><span class="line">    <span class="comment">% &gt;&gt; ind =</span></span><br><span class="line">    <span class="comment">%     1     3</span></span><br><span class="line">    <span class="comment">%若X是一个矩阵，索引该如何返回呢？</span></span><br><span class="line">    <span class="comment">%  &gt;&gt; X = [1 -3 0;0 0 8;4 0 6]</span></span><br><span class="line">    <span class="comment">%  X =</span></span><br><span class="line">    <span class="comment">%   1    -3     0</span></span><br><span class="line">    <span class="comment">%   0     0     8</span></span><br><span class="line">    <span class="comment">%   4     0     6</span></span><br><span class="line">    <span class="comment">%  &gt;&gt; ind = find(X)</span></span><br><span class="line">    <span class="comment">% ind =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">%      4</span></span><br><span class="line">    <span class="comment">%      8</span></span><br><span class="line">    <span class="comment">%      9</span></span><br><span class="line">    <span class="comment">% 这是因为在Matlab在存储矩阵时，是一列一列存储的，我们可以做一下验证：</span></span><br><span class="line">    <span class="comment">%  &gt;&gt; X(4)</span></span><br><span class="line">    <span class="comment">%  ans =</span></span><br><span class="line">    <span class="comment">%     -3</span></span><br><span class="line">    <span class="comment">% 假如你需要按照行列的信息输出该怎么办呢？</span></span><br><span class="line">    <span class="comment">% [r,c] = find(X)</span></span><br><span class="line">    <span class="comment">% r =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      2</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">% c =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">%      2</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">%      3</span></span><br><span class="line">    <span class="comment">% [r,c] = find(X,1) %只找第一个非0元素</span></span><br><span class="line">    <span class="comment">% r =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    <span class="comment">% c =</span></span><br><span class="line">    <span class="comment">%      1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 那么问题来了，我们要得到最大特征值的位置，就需要将包含所有特征值的这个对角矩阵D中，不等于最大特征值的位置全变为0</span></span><br><span class="line">    <span class="comment">% 这时候可以用到矩阵与常数的大小判断运算，共有三种运算符：大于&gt; ;小于&lt; ;等于 ==  （一个等号表示赋值；两个等号表示判断）</span></span><br><span class="line">    <span class="comment">% 例如：A &gt; 2 会生成一个和A相同大小的矩阵，矩阵元素要么为0，要么为1（A中每个元素和2比较，如果大于2则为1，否则为0）</span></span><br><span class="line">    [r,c]=<span class="built_in">find</span>(D == Max_eig , <span class="number">1</span>);</span><br><span class="line">    <span class="comment">% 找到D中第一个与最大特征值相等的元素的位置，记录它的行和列。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;特征值法求权重的结果为：&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>( V(:,c) ./ sum(V(:,c)) )</span><br><span class="line">    <span class="comment">% 我们先根据上面找到的最大特征值的列数c找到对应的特征向量，然后再进行标准化。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% % % % % % % % % % % % %下面是计算一致性比例CR的环节% % % % % % % % % % % % %</span></span><br><span class="line">    <span class="comment">% 当CR&lt;0.10时，我们认为判断矩阵的一致性可以接受；否则应对其进行修正。</span></span><br><span class="line">    CI = (Max_eig - n) / (n<span class="number">-1</span>);</span><br><span class="line">    RI=[<span class="number">0</span> <span class="number">0.00001</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];  <span class="comment">%注意哦，这里的RI最多支持 n = 15</span></span><br><span class="line">    <span class="comment">% 这里n=2时，一定是一致矩阵，所以CI = 0，我们为了避免分母为0，将这里的第二个元素改为了很接近0的正数</span></span><br><span class="line">    CR=CI/RI(n);</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>);<span class="built_in">disp</span>(CI);</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;一致性比例CR=&#x27;</span>);<span class="built_in">disp</span>(CR);</span><br><span class="line">    <span class="keyword">if</span> CR&lt;<span class="number">0.10</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受!&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改!&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">1</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请检查矩阵A的维数是否不大于1或不是方阵&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">2</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请检查矩阵A中有元素小于等于0&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">3</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;A的维数n超过了15，请减少准则层的数量&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> ERROR == <span class="number">4</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请检查矩阵A中存在i、j不满足A_ij * A_ji = 1&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="F4锁定单元格"><a href="#F4锁定单元格" class="headerlink" title="F4锁定单元格"></a>F4锁定单元格</h3><h2 id="优劣解距离法"><a href="#优劣解距离法" class="headerlink" title="优劣解距离法"></a>优劣解距离法</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><p>正向化</p>
<p>将所有的指标转化为极大型指标</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751421.png" style="zoom:80%;" />
</li>
<li><p>正向化矩阵标准化</p>
<p>标准化的目的是为了消除量纲的影响</p>
</li>
<li><p>计算得分</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751548.png" style="zoom:80%;" />
</li>
<li><p>归一化</p>
</li>
<li><p>用excel对数据进行可视化</p>
</li>
</ol>
<h3 id="算法代码-1"><a href="#算法代码-1" class="headerlink" title="算法代码"></a>算法代码</h3><p>主函数：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"><span class="comment">%% 注意：如果提示: 错误使用 load，无法读取文件 &#x27;data_water_quality.mat&#x27;。没有此类文件或目录。</span></span><br><span class="line"><span class="comment">% 那么原因是因为你的Matlab的当前文件夹中不存在这个文件</span></span><br><span class="line"><span class="comment">% 可以使用cd函数修改Matlab的当前文件夹</span></span><br><span class="line"><span class="comment">% 比如说，我的代码和数据放在了: D:第2讲.TOPSIS法（优劣解距离法）\代码和例题数据</span></span><br><span class="line"><span class="comment">% 那么我就可以输入命令：</span></span><br><span class="line"><span class="comment">% cd &#x27;D:第2讲.TOPSIS法（优劣解距离法）\代码和例题数据&#x27;</span></span><br><span class="line"><span class="comment">% 也可以看我更新的视频：“更新9_Topsis代码为什么运行失败_得分结果怎么可视化以及权重的确定如何更加准确”，里面有介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% A = magic(5)  % 幻方矩阵</span></span><br><span class="line"><span class="comment">% M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</span></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,&#x27;descend&#x27;)是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,&#x27;descend&#x27;) ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure>

<p>Positivization 函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>正向化函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="自输入权重代码"><a href="#自输入权重代码" class="headerlink" title="自输入权重代码"></a>自输入权重代码</h3><p>主函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"><span class="comment">%% 注意：如果提示: 错误使用 load，无法读取文件 &#x27;data_water_quality.mat&#x27;。没有此类文件或目录。</span></span><br><span class="line"><span class="comment">% 那么原因是因为你的Matlab的当前文件夹中不存在这个文件</span></span><br><span class="line"><span class="comment">% 可以使用cd函数修改Matlab的当前文件夹</span></span><br><span class="line"><span class="comment">% 比如说，我的代码和数据放在了: D:第2讲.TOPSIS法（优劣解距离法）\代码和例题数据</span></span><br><span class="line"><span class="comment">% 那么我就可以输入命令：</span></span><br><span class="line"><span class="comment">% cd &#x27;D:第2讲.TOPSIS法（优劣解距离法）\代码和例题数据&#x27;</span></span><br><span class="line"><span class="comment">% 也可以看我更新的视频：“更新9_Topsis代码为什么运行失败_得分结果怎么可视化以及权重的确定如何更加准确”，里面有介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 作业：在这里增加是否需要算加权</span></span><br><span class="line"><span class="comment">% 补充一个基础知识：m*n维的矩阵A 点乘 n维行向量B，等于这个A的每一行都点乘B</span></span><br><span class="line"><span class="comment">% （注意：2017以及之后版本的Matlab才支持，老版本Matlab会报错）</span></span><br><span class="line"><span class="comment">% % 假如原始数据为：</span></span><br><span class="line"><span class="comment">%   A=[1, 2, 3;</span></span><br><span class="line"><span class="comment">%        2, 4, 6] </span></span><br><span class="line"><span class="comment">% % 权重矩阵为：</span></span><br><span class="line"><span class="comment">%   B=[ 0.2, 0.5 ,0.3 ] </span></span><br><span class="line"><span class="comment">% % 加权后为：</span></span><br><span class="line"><span class="comment">%   C=A .* B</span></span><br><span class="line"><span class="comment">%     0.2000    1.0000    0.9000</span></span><br><span class="line"><span class="comment">%     0.4000    2.0000    1.8000</span></span><br><span class="line"><span class="comment">% 类似的，还有矩阵和向量的点除， 大家可以自己试试计算A ./ B</span></span><br><span class="line"><span class="comment">% 注意，矩阵和向量没有 .- 和 .+ 哦 ，大家可以试试，如果计算A.+B 和 A.-B会报什么错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 这里补充一个小插曲</span></span><br><span class="line"><span class="comment">% % 在上一讲层次分析法的代码中，我们可以优化以下的语句：</span></span><br><span class="line"><span class="comment">% % Sum_A = sum(A);</span></span><br><span class="line"><span class="comment">% % SUM_A = repmat(Sum_A,n,1);</span></span><br><span class="line"><span class="comment">% % Stand_A = A ./ SUM_A;</span></span><br><span class="line"><span class="comment">% % 事实上，我们把第三行换成：Stand_A = A ./ Sum_A; 也是可以的哦 </span></span><br><span class="line"><span class="comment">% % (再次强调，新版本的Matlab才能运行哦)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 让用户判断是否需要增加权重</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;请输入是否需要增加权重向量，需要输入1，不需要输入0&#x27;</span>)</span><br><span class="line">Judge = input(<span class="string">&#x27;请输入是否需要增加权重： &#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;如果你有3个指标，你就需要输入3个权重，例如它们分别为0.25,0.25,0.5, 则你需要输入[0.25,0.25,0.5]&#x27;</span>]);</span><br><span class="line">    weigh = input([<span class="string">&#x27;你需要输入&#x27;</span> num2str(m) <span class="string">&#x27;个权数。&#x27;</span> <span class="string">&#x27;请以行向量的形式输入这&#x27;</span> num2str(m) <span class="string">&#x27;个权重: &#x27;</span>]);</span><br><span class="line">    OK = <span class="number">0</span>;  <span class="comment">% 用来判断用户的输入格式是否正确</span></span><br><span class="line">    <span class="keyword">while</span> OK == <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(sum(weigh) - <span class="number">1</span>)&lt;<span class="number">0.000001</span> &amp;&amp; <span class="built_in">size</span>(weigh,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">size</span>(weigh,<span class="number">2</span>) == m   <span class="comment">% 这里要注意浮点数的运算是不精准的。</span></span><br><span class="line">             OK =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            weigh = input(<span class="string">&#x27;你输入的有误，请重新输入权重行向量: &#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    weigh = <span class="built_in">ones</span>(<span class="number">1</span>,m) ./ m ; <span class="comment">%如果不需要加权重就默认权重都相同，即都为1/m</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum(((Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ) .* <span class="built_in">repmat</span>(weigh,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum(((Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ) .* <span class="built_in">repmat</span>(weigh,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% A = magic(5)  % 幻方矩阵</span></span><br><span class="line"><span class="comment">% M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</span></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,&#x27;descend&#x27;)是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,&#x27;descend&#x27;) ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure>



<h3 id="基于熵权法权重的代码"><a href="#基于熵权法权重的代码" class="headerlink" title="基于熵权法权重的代码"></a>基于熵权法权重的代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦。</span></span><br><span class="line"><span class="comment">% clear;clc</span></span><br><span class="line"><span class="comment">% load data_water_quality.mat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 作业：在这里增加是否需要算加权</span></span><br><span class="line"><span class="comment">% 补充一个基础知识：m*n维的矩阵A 点乘 n维行向量B，等于这个A的每一行都点乘B</span></span><br><span class="line"><span class="comment">% （注意：2017以及之后版本的Matlab才支持，老版本Matlab会报错）</span></span><br><span class="line"><span class="comment">% % 假如原始数据为：</span></span><br><span class="line"><span class="comment">%   A=[1, 2, 3;</span></span><br><span class="line"><span class="comment">%        2, 4, 6] </span></span><br><span class="line"><span class="comment">% % 权重矩阵为：</span></span><br><span class="line"><span class="comment">%   B=[ 0.2, 0.5 ,0.3 ] </span></span><br><span class="line"><span class="comment">% % 加权后为：</span></span><br><span class="line"><span class="comment">%   C=A .* B</span></span><br><span class="line"><span class="comment">%     0.2000    1.0000    0.9000</span></span><br><span class="line"><span class="comment">%     0.4000    2.0000    1.8000</span></span><br><span class="line"><span class="comment">% 类似的，还有矩阵和向量的点除， 大家可以自己试试计算A ./ B</span></span><br><span class="line"><span class="comment">% 注意，矩阵和向量没有 .- 和 .+ 哦 ，大家可以试试，如果计算A.+B 和 A.-B会报什么错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 这里补充一个小插曲</span></span><br><span class="line"><span class="comment">% % 在上一讲层次分析法的代码中，我们可以优化以下的语句：</span></span><br><span class="line"><span class="comment">% % Sum_A = sum(A);</span></span><br><span class="line"><span class="comment">% % SUM_A = repmat(Sum_A,n,1);</span></span><br><span class="line"><span class="comment">% % Stand_A = A ./ SUM_A;</span></span><br><span class="line"><span class="comment">% % 事实上，我们把第三行换成：Stand_A = A ./ Sum_A; 也是可以的哦 </span></span><br><span class="line"><span class="comment">% % (再次强调，新版本的Matlab才能运行哦)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 让用户判断是否需要增加权重</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&quot;请输入是否需要增加权重向量，需要输入1，不需要输入0&quot;</span>)</span><br><span class="line">Judge = input(<span class="string">&#x27;请输入是否需要增加权重： &#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Judge = input(<span class="string">&#x27;使用熵权法确定权重请输入1，否则输入0： &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sum(sum(Z&lt;<span class="number">0</span>)) &gt;<span class="number">0</span>   <span class="comment">% 如果之前标准化后的Z矩阵中存在负数，则重新对X进行标准化</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;原来标准化得到的Z矩阵中存在负数，所以需要对X重新标准化&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                    Z(<span class="built_in">i</span>,<span class="built_in">j</span>) = [X(<span class="built_in">i</span>,<span class="built_in">j</span>) - <span class="built_in">min</span>(X(:,<span class="built_in">j</span>))] / [<span class="built_in">max</span>(X(:,<span class="built_in">j</span>)) - <span class="built_in">min</span>(X(:,<span class="built_in">j</span>))];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;X重新进行标准化得到的标准化矩阵Z为:  &#x27;</span>)</span><br><span class="line">            <span class="built_in">disp</span>(Z)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        weight = Entropy_Method(Z);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;熵权法确定的权重为：&#x27;</span>)</span><br><span class="line">        <span class="built_in">disp</span>(weight)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;如果你有3个指标，你就需要输入3个权重，例如它们分别为0.25,0.25,0.5, 则你需要输入[0.25,0.25,0.5]&#x27;</span>]);</span><br><span class="line">        weight = input([<span class="string">&#x27;你需要输入&#x27;</span> num2str(m) <span class="string">&#x27;个权数。&#x27;</span> <span class="string">&#x27;请以行向量的形式输入这&#x27;</span> num2str(m) <span class="string">&#x27;个权重: &#x27;</span>]);</span><br><span class="line">        OK = <span class="number">0</span>;  <span class="comment">% 用来判断用户的输入格式是否正确</span></span><br><span class="line">        <span class="keyword">while</span> OK == <span class="number">0</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(sum(weight) <span class="number">-1</span>)&lt;<span class="number">0.000001</span> &amp;&amp; <span class="built_in">size</span>(weight,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">size</span>(weight,<span class="number">2</span>) == m  <span class="comment">% 注意，Matlab中浮点数的比较要小心</span></span><br><span class="line">                OK =<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                weight = input(<span class="string">&#x27;你输入的有误，请重新输入权重行向量: &#x27;</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    weight = <span class="built_in">ones</span>(<span class="number">1</span>,m) ./ m ; <span class="comment">%如果不需要加权重就默认权重都相同，即都为1/m</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weight,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weight,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% A = magic(5)  % 幻方矩阵</span></span><br><span class="line"><span class="comment">% M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</span></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,&#x27;descend&#x27;)是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,&#x27;descend&#x27;) ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增添功能函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[W]</span> = <span class="title">Entropy_Method</span><span class="params">(Z)</span></span></span><br><span class="line"><span class="comment">% 计算有n个样本，m个指标的样本所对应的的熵权</span></span><br><span class="line"><span class="comment">% 输入</span></span><br><span class="line"><span class="comment">% Z ： n*m的矩阵（要经过正向化和标准化处理，且元素中不存在负数）</span></span><br><span class="line"><span class="comment">% 输出</span></span><br><span class="line"><span class="comment">% W：熵权，1*m的行向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算熵权</span></span><br><span class="line">    [n,m] = <span class="built_in">size</span>(Z);</span><br><span class="line">    D = <span class="built_in">zeros</span>(<span class="number">1</span>,m);  <span class="comment">% 初始化保存信息效用值的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">        x = Z(:,<span class="built_in">i</span>);  <span class="comment">% 取出第i列的指标</span></span><br><span class="line">        p = x / sum(x);</span><br><span class="line">        <span class="comment">% 注意，p有可能为0，此时计算ln(p)*p时，Matlab会返回NaN，所以这里我们自己定义一个函数</span></span><br><span class="line">        e = -sum(p .* mylog(p)) / <span class="built_in">log</span>(n); <span class="comment">% 计算信息熵</span></span><br><span class="line">        D(<span class="built_in">i</span>) = <span class="number">1</span>- e; <span class="comment">% 计算信息效用值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    W = D ./ sum(D);  <span class="comment">% 将信息效用值归一化，得到权重</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重新定义一个mylog函数，当输入的p中元素为0时，返回0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[lnp]</span> =  <span class="title">mylog</span><span class="params">(p)</span></span></span><br><span class="line">n = <span class="built_in">length</span>(p);   <span class="comment">% 向量的长度</span></span><br><span class="line">lnp = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   <span class="comment">% 初始化最后的结果</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n   <span class="comment">% 开始循环</span></span><br><span class="line">        <span class="keyword">if</span> p(<span class="built_in">i</span>) == <span class="number">0</span>   <span class="comment">% 如果第i个元素为0</span></span><br><span class="line">            lnp(<span class="built_in">i</span>) = <span class="number">0</span>;  <span class="comment">% 那么返回的第i个结果也为0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lnp(<span class="built_in">i</span>) = <span class="built_in">log</span>(p(<span class="built_in">i</span>));  </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h2 id="灰色关联分析"><a href="#灰色关联分析" class="headerlink" title="灰色关联分析"></a>灰色关联分析</h2><h3 id="传统数理统计的不足之处"><a href="#传统数理统计的不足之处" class="headerlink" title="传统数理统计的不足之处"></a>传统数理统计的不足之处</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751231.png" style="zoom:80%;" />

<h3 id="该方法的好处"><a href="#该方法的好处" class="headerlink" title="该方法的好处"></a>该方法的好处</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751261.png" style="zoom:80%;" />





<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>画统计图（excel）</li>
<li>确定分析数列（即确定参考数列（母序列）和比较数列（子序列））</li>
<li>对变量进行预处理（目的：1.去量纲；2.缩小变量范围简化计算）</li>
<li>计算子序列中多个指标与母序列的关联系数</li>
<li>求每个指标对于母指标的关联度（关联系数求平均）</li>
<li>比较关联度大小得出结论（关联度越大表示联系越紧密）</li>
</ol>
<h3 id="算法代码-2"><a href="#算法代码-2" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 灰色关联分析用于系统分析例题的讲解</span></span><br><span class="line">clear;clc</span><br><span class="line">load gdp.mat  <span class="comment">% 导入数据 一个6*4的矩阵</span></span><br><span class="line"><span class="comment">% 不会导入数据的同学可以看看第二讲topsis模型，我们也可以自己在工作区新建变量，并把Excel的数据粘贴过来</span></span><br><span class="line"><span class="comment">% 注意Matlab的当前文件夹一定要切换到有数据文件的这个文件夹内</span></span><br><span class="line">Mean = <span class="built_in">mean</span>(gdp);  <span class="comment">% 求出每一列的均值以供后续的数据预处理</span></span><br><span class="line">gdp = gdp ./ <span class="built_in">repmat</span>(Mean,<span class="built_in">size</span>(gdp,<span class="number">1</span>),<span class="number">1</span>);  <span class="comment">%size(gdp,1)=6, repmat(Mean,6,1)可以将矩阵进行复制，复制为和gdp同等大小，然后使用点除（对应元素相除），这些在第一讲层次分析法都讲过</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;预处理后的矩阵为：&#x27;</span>); <span class="built_in">disp</span>(gdp)</span><br><span class="line">Y = gdp(:,<span class="number">1</span>);  <span class="comment">% 母序列：这里默认第一列为母序列</span></span><br><span class="line">X = gdp(:,<span class="number">2</span>:<span class="keyword">end</span>); <span class="comment">% 子序列：第二列到最后一列为子序列</span></span><br><span class="line">absX0_Xi = <span class="built_in">abs</span>(X - <span class="built_in">repmat</span>(Y,<span class="number">1</span>,<span class="built_in">size</span>(X,<span class="number">2</span>)))  <span class="comment">% 计算|X0-Xi|矩阵(在这里我们把X0定义为了Y)</span></span><br><span class="line">a = <span class="built_in">min</span>(<span class="built_in">min</span>(absX0_Xi))    <span class="comment">% 计算两级最小差a</span></span><br><span class="line">b = <span class="built_in">max</span>(<span class="built_in">max</span>(absX0_Xi))  <span class="comment">% 计算两级最大差b</span></span><br><span class="line">rho = <span class="number">0.5</span>; <span class="comment">% 分辨系数取0.5</span></span><br><span class="line"><span class="built_in">gamma</span> = (a+rho*b) ./ (absX0_Xi  + rho*b)  <span class="comment">% 计算子序列中各个指标与母序列的关联系数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;子序列中各个指标的灰色关联度分别为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">mean</span>(<span class="built_in">gamma</span>))</span><br></pre></td></tr></table></figure>





<h3 id="基于灰色关联度权重的代码"><a href="#基于灰色关联度权重的代码" class="headerlink" title="基于灰色关联度权重的代码"></a>基于灰色关联度权重的代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 灰色关联分析用于综合评价模型例题的讲解</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"><span class="comment">% 不会导入数据的同学可以看看第二讲topsis模型，我们也可以自己在工作区新建变量，并把Excel的数据粘贴过来</span></span><br><span class="line"><span class="comment">% 注意Matlab的当前文件夹一定要切换到有数据文件的这个文件夹内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);   <span class="comment">%1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指  标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 对正向化后的矩阵进行预处理</span></span><br><span class="line">Mean = <span class="built_in">mean</span>(X);  <span class="comment">% 求出每一列的均值以供后续的数据预处理</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(Mean,<span class="built_in">size</span>(X,<span class="number">1</span>),<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;预处理后的矩阵为：&#x27;</span>); <span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 构造母序列和子序列</span></span><br><span class="line">Y = <span class="built_in">max</span>(Z,[],<span class="number">2</span>);  <span class="comment">% 母序列为虚拟的，用每一行的最大值构成的列向量表示母序列</span></span><br><span class="line">X = Z; <span class="comment">% 子序列就是预处理后的数据矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算得分</span></span><br><span class="line">absX0_Xi = <span class="built_in">abs</span>(X - <span class="built_in">repmat</span>(Y,<span class="number">1</span>,<span class="built_in">size</span>(X,<span class="number">2</span>)))  <span class="comment">% 计算|X0-Xi|矩阵</span></span><br><span class="line">a = <span class="built_in">min</span>(<span class="built_in">min</span>(absX0_Xi))    <span class="comment">% 计算两级最小差a</span></span><br><span class="line">b = <span class="built_in">max</span>(<span class="built_in">max</span>(absX0_Xi))  <span class="comment">% 计算两级最大差b</span></span><br><span class="line">rho = <span class="number">0.5</span>; <span class="comment">% 分辨系数取0.5</span></span><br><span class="line"><span class="built_in">gamma</span> = (a+rho*b) ./ (absX0_Xi  + rho*b)  <span class="comment">% 计算子序列中各个指标与母序列的关联系数</span></span><br><span class="line">weight = <span class="built_in">mean</span>(<span class="built_in">gamma</span>) / sum(<span class="built_in">mean</span>(<span class="built_in">gamma</span>));  <span class="comment">% 利用子序列中各个指标的灰色关联度计算权重</span></span><br><span class="line">score = sum(X .* <span class="built_in">repmat</span>(weight,<span class="built_in">size</span>(X,<span class="number">1</span>),<span class="number">1</span>),<span class="number">2</span>);   <span class="comment">% 未归一化的得分</span></span><br><span class="line">stand_S = score / sum(score);   <span class="comment">% 归一化后的得分</span></span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 进行排序</span></span><br></pre></td></tr></table></figure>





<h2 id="模糊综合评价"><a href="#模糊综合评价" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h2><h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>确定因素集（评价指标）（分类来划分层级），评语集（评价度量），因素集权重（指标权重）</li>
<li>确定模糊综合判断矩阵（分别建立每个指标的隶属函数（指标正向化））</li>
<li>模糊向量&#x3D;权重集 * 模糊综合判断矩阵</li>
<li>综合评判得出结果</li>
</ol>
<h2 id="用excel绘制图形"><a href="#用excel绘制图形" class="headerlink" title="用excel绘制图形"></a>用excel绘制图形</h2><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751245.png" style="zoom:80%;" />





<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751374.png" style="zoom:80%;" />



<h3 id="双向柱状图"><a href="#双向柱状图" class="headerlink" title="双向柱状图"></a>双向柱状图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751308.png" style="zoom:80%;" />





<h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751316.png" style="zoom:80%;" />

<h3 id="双向条形图"><a href="#双向条形图" class="headerlink" title="双向条形图"></a>双向条形图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751938.png" style="zoom:80%;" />



<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751123.png" style="zoom:80%;" />





<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751199.png"></p>
<h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751132.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751143.png" style="zoom:80%;" />





<h3 id="双轴折线图"><a href="#双轴折线图" class="headerlink" title="双轴折线图"></a>双轴折线图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751218.png" style="zoom:80%;" />



<h3 id="类别折线图"><a href="#类别折线图" class="headerlink" title="类别折线图"></a>类别折线图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751608.png" style="zoom:80%;" />





<h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751007.png" style="zoom:80%;" />



<h3 id="分类散点图"><a href="#分类散点图" class="headerlink" title="分类散点图"></a>分类散点图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751883.png" style="zoom:80%;" />





<h3 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751936.png" style="zoom:80%;" />



<h3 id="excel技巧"><a href="#excel技巧" class="headerlink" title="excel技巧"></a>excel技巧</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751950.png" style="zoom:80%;" />





<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751944.png" style="zoom:80%;" />



<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751278.png"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751406.png"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751474.png"></p>
<h4 id="数据透视表（便于数据交互分析）"><a href="#数据透视表（便于数据交互分析）" class="headerlink" title="数据透视表（便于数据交互分析）"></a>数据透视表（便于数据交互分析）</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751491.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751504.png" style="zoom:80%;" />

<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751584.png" style="zoom:80%;" />

<h5 id="1-数据透视表有空白"><a href="#1-数据透视表有空白" class="headerlink" title="1.数据透视表有空白"></a>1.数据透视表有空白</h5><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751695.png" style="zoom:80%;" />

<h5 id="2-日期或时刻为文本型"><a href="#2-日期或时刻为文本型" class="headerlink" title="2.日期或时刻为文本型"></a>2.日期或时刻为文本型</h5><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751740.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751864.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751882.png" style="zoom:80%;" />



<h5 id="3-数值为文本型"><a href="#3-数值为文本型" class="headerlink" title="3.数值为文本型"></a>3.数值为文本型</h5><p>解决方法：</p>
<ol>
<li>分列功能</li>
<li>用.txt文件</li>
</ol>
<h4 id="强大的工具"><a href="#强大的工具" class="headerlink" title="强大的工具"></a>强大的工具</h4><p>方方格子：可以用于多文件处理</p>
<p>VBA</p>
<h2 id="插值算法（常用于数据缺失值处理）"><a href="#插值算法（常用于数据缺失值处理）" class="headerlink" title="插值算法（常用于数据缺失值处理）"></a>插值算法（常用于数据缺失值处理）</h2><h3 id="低阶插值方法"><a href="#低阶插值方法" class="headerlink" title="低阶插值方法"></a>低阶插值方法</h3><ul>
<li><p>分段插值（低级但好用）</p>
</li>
<li><p>分段多项式插值</p>
</li>
<li><p>多项式插值（不好用）</p>
</li>
</ul>
<h3 id="中阶插值方法（龙格现象）（导数不符合）"><a href="#中阶插值方法（龙格现象）（导数不符合）" class="headerlink" title="中阶插值方法（龙格现象）（导数不符合）"></a>中阶插值方法（龙格现象）（导数不符合）</h3><ul>
<li>拉格朗日插值</li>
<li>牛顿插值</li>
</ul>
<h3 id="高阶插值方法（导数保持一致）"><a href="#高阶插值方法（导数保持一致）" class="headerlink" title="高阶插值方法（导数保持一致）"></a>高阶插值方法（导数保持一致）</h3><ul>
<li>埃尔米特插值（一般为三次）</li>
<li>样条插值（一般为三次）</li>
</ul>
<h3 id="算法代码-3"><a href="#算法代码-3" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 分段三次埃尔米特插值</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p = pchip(x,y,new_x);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>); <span class="comment">% 在同一个脚本文件里面，要想画多个图，需要给每个图编号，否则只会显示最后一个图哦~</span></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;-o&#x27;</span>, new_x, p, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot函数用法:</span></span><br><span class="line"><span class="comment">% plot(x1,y1,x2,y2) </span></span><br><span class="line"><span class="comment">% 线方式： - 实线 :点线 -. 虚点线 - - 波折线 </span></span><br><span class="line"><span class="comment">% 点方式： . 圆点  +加号  * 星号  x x形  o 小圆</span></span><br><span class="line"><span class="comment">% 颜色： y黄； r红； g绿； b蓝； w白； k黑； m紫； c青</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 三次样条插值和分段三次埃尔米特插值的对比</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; </span><br><span class="line">y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p1 = pchip(x,y,new_x);   <span class="comment">%分段三次埃尔米特插值</span></span><br><span class="line">p2 = spline(x,y,new_x);  <span class="comment">%三次样条插值</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,new_x,p1,<span class="string">&#x27;r-&#x27;</span>,new_x,p2,<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;样本点&#x27;</span>,<span class="string">&#x27;三次埃尔米特插值&#x27;</span>,<span class="string">&#x27;三次样条插值&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)   <span class="comment">%标注显示在东南方向</span></span><br><span class="line"><span class="comment">% 说明：</span></span><br><span class="line"><span class="comment">% LEGEND(string1,string2,string3, …)</span></span><br><span class="line"><span class="comment">% 分别将字符串1、字符串2、字符串3……标注到图中，每个字符串对应的图标为画图时的图标。</span></span><br><span class="line"><span class="comment">% ‘Location’用来指定标注显示的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% n维数据的插值</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p = interpn (x, y, new_x, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line"><span class="comment">% 等价于 p = spline(x, y, new_x);</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;o&#x27;</span>, new_x, p, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 人口预测（注意：一般我们很少使用插值算法来预测数据，随着课程的深入，后面的章节会有更适合预测的算法供大家选择，例如灰色预测、拟合预测等）</span></span><br><span class="line">population=[<span class="number">133126</span>,<span class="number">133770</span>,<span class="number">134413</span>,<span class="number">135069</span>,<span class="number">135738</span>,<span class="number">136427</span>,<span class="number">137122</span>,<span class="number">137866</span>,<span class="number">138639</span>, <span class="number">139538</span>];</span><br><span class="line">year = <span class="number">2009</span>:<span class="number">2018</span>;</span><br><span class="line">p1 = pchip(year, population, <span class="number">2019</span>:<span class="number">2021</span>)  <span class="comment">%分段三次埃尔米特插值预测</span></span><br><span class="line">p2 = spline(year, population, <span class="number">2019</span>:<span class="number">2021</span>) <span class="comment">%三次样条插值预测</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(year, population,<span class="string">&#x27;o&#x27;</span>,<span class="number">2019</span>:<span class="number">2021</span>,p1,<span class="string">&#x27;r*-&#x27;</span>,<span class="number">2019</span>:<span class="number">2021</span>,p2,<span class="string">&#x27;bx-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;样本点&#x27;</span>,<span class="string">&#x27;三次埃尔米特插值预测&#x27;</span>,<span class="string">&#x27;三次样条插值预测&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="插值方法可以进行短期预测"><a href="#插值方法可以进行短期预测" class="headerlink" title="插值方法可以进行短期预测"></a>插值方法可以进行短期预测</h3><h3 id="数据缺失值处理"><a href="#数据缺失值处理" class="headerlink" title="数据缺失值处理"></a>数据缺失值处理</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mR4y1A741?vd_source=21929b71ec58f67534148e5c4050348c">【缺失值处理】如何利用spss做均值替代、中位数替代与多重插补？</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YZ4y1f7pk?vd_source=21929b71ec58f67534148e5c4050348c">【6.缺失值与多重插补】</a> </p>
<h2 id="拟合算法"><a href="#拟合算法" class="headerlink" title="拟合算法"></a>拟合算法</h2><h3 id="拟合优度（线性函数的评价指标）"><a href="#拟合优度（线性函数的评价指标）" class="headerlink" title="拟合优度（线性函数的评价指标）"></a>拟合优度（线性函数的评价指标）</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751895.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751948.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751083.png" style="zoom:80%;" />



<h3 id="算法代码-4"><a href="#算法代码-4" class="headerlink" title="算法代码"></a>算法代码</h3><h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">load  data1</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="comment">% 给x和y轴加上标签</span></span><br><span class="line">xlabel(<span class="string">&#x27;x的值&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;y的值&#x27;</span>)</span><br><span class="line">n = <span class="built_in">size</span>(x,<span class="number">1</span>);</span><br><span class="line">k = (n*sum(x.*y)-sum(x)*sum(y))/(n*sum(x.*x)-sum(x)*sum(x))</span><br><span class="line">b = (sum(x.*x)*sum(y)-sum(x)*sum(x.*y))/(n*sum(x.*x)-sum(x)*sum(x))</span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">% 继续在之前的图形上来画图形</span></span><br><span class="line">grid on <span class="comment">% 显示网格线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% % 画出y=kx+b的函数图像 plot(x,y)</span></span><br><span class="line"><span class="comment">% % 传统的画法：模拟生成x和y的序列，比如要画出[0,5]上的图形</span></span><br><span class="line"><span class="comment">% xx = 2.5: 0.1 :7  % 间隔设置的越小画出来的图形越准确</span></span><br><span class="line"><span class="comment">% yy = k * xx + b  % k和b都是已知值</span></span><br><span class="line"><span class="comment">% plot(xx,yy,&#x27;-&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 匿名函数的基本用法。</span></span><br><span class="line"><span class="comment">% handle = @(arglist) anonymous_function</span></span><br><span class="line"><span class="comment">% 其中handle为调用匿名函数时使用的名字。</span></span><br><span class="line"><span class="comment">% arglist为匿名函数的输入参数，可以是一个，也可以是多个，用逗号分隔。</span></span><br><span class="line"><span class="comment">% anonymous_function为匿名函数的表达式。</span></span><br><span class="line"><span class="comment">% 举个小例子</span></span><br><span class="line"><span class="comment">%  z=@(x,y) x^2+y^2; </span></span><br><span class="line"><span class="comment">%  z(1,2) </span></span><br><span class="line"><span class="comment">% % ans =  5</span></span><br><span class="line"><span class="comment">% fplot函数可用于画出匿名一元函数的图形。</span></span><br><span class="line"><span class="comment">% fplot(f,xinterval) 将匿名函数f在指定区间xinterval绘图。xinterval =  [xmin xmax] 表示定义域的范围</span></span><br><span class="line"></span><br><span class="line">f=@(x) k*x+b;</span><br><span class="line">fplot(f,[<span class="number">2.5</span>,<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;样本数据&#x27;</span>,<span class="string">&#x27;拟合函数&#x27;</span>,<span class="string">&#x27;location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y_hat = k*x+b; <span class="comment">% y的拟合值</span></span><br><span class="line">SSR = sum((y_hat-<span class="built_in">mean</span>(y)).^<span class="number">2</span>)  <span class="comment">% 回归平方和</span></span><br><span class="line">SSE = sum((y_hat-y).^<span class="number">2</span>) <span class="comment">% 误差平方和</span></span><br><span class="line">SST = sum((y-<span class="built_in">mean</span>(y)).^<span class="number">2</span>) <span class="comment">% 总体平方和</span></span><br><span class="line">SST-SSE-SSR   <span class="comment">% 5.6843e-14  =   5.6843*10^-14   matlab浮点数计算的一个误差</span></span><br><span class="line">R_2 = SSR / SST</span><br></pre></td></tr></table></figure>





<h4 id="拟合工具箱使用"><a href="#拟合工具箱使用" class="headerlink" title="拟合工具箱使用"></a>拟合工具箱使用</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">population = [<span class="number">3.9</span>,<span class="number">5.3</span>,<span class="number">7.2</span>,<span class="number">9.6</span>,<span class="number">12.9</span>,<span class="number">17.1</span>,<span class="number">23.2</span>,<span class="number">31.4</span>,<span class="number">38.6</span>,<span class="number">50.2</span>,<span class="number">62.9</span>,<span class="number">76.0</span>,<span class="number">92.0</span>,<span class="number">106.5</span>,<span class="number">123.2</span>,<span class="number">131.7</span>,<span class="number">150.7</span>,<span class="number">179.3</span>,<span class="number">204.0</span>,<span class="number">226.5</span>,<span class="number">251.4</span>,<span class="number">281.4</span>];</span><br><span class="line"><span class="built_in">plot</span>(year,population,<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">cftool  <span class="comment">% 拟合工具箱</span></span><br><span class="line"><span class="comment">% (1) X data 选择 year</span></span><br><span class="line"><span class="comment">% (2) Y data 选择 population</span></span><br><span class="line"><span class="comment">% (3) 拟合方式选择：Custom Equation (自定义方程)</span></span><br><span class="line"><span class="comment">% (4) 修改下方的方框为：x = f(t) = xm/(1+(xm/3.9-1)*exp(-r*(t-1790)))</span></span><br><span class="line"><span class="comment">% (5) 左边的result一栏最上面显示：Fit computation did not converge:即没有找到收敛解，右边的拟合图形也表明拟合结果不理想</span></span><br><span class="line"><span class="comment">% (6) 点击Fit Options，修改非线性最小二乘估计法拟合的初始值(StartPoint), r修改为0.02，xm修改为500 </span></span><br><span class="line"><span class="comment">% 有很多同学有疑惑，初始值为什么要这样设置？我们在未来学习微分方程模型和智能算法的课程时再来给大家介绍这里面蕴含的技巧。</span></span><br><span class="line"><span class="comment">% (7) 此时左边的result一览得到了拟合结果：r = 0.02735, xm = 342.4</span></span><br><span class="line"><span class="comment">% (8) 依次点击拟合工具箱的菜单栏最左边的文件-Point to figure(生成图像);—Generate Code(导出代码到时候可以放在你的论文附录)，可以得到一个未命名的脚本文件</span></span><br><span class="line"><span class="comment">% (9) 在这个打开的脚本中按快捷键Ctrl+S，将这个文件保存到当前文件夹。</span></span><br><span class="line"><span class="comment">% (10) 在现在这个文件中调用这个函数得到参数的拟合值和预测的效果</span></span><br><span class="line">[fitresult, gof] = createFit(year, population)</span><br><span class="line">t = <span class="number">2001</span>:<span class="number">2030</span>;</span><br><span class="line">xm = <span class="number">342.4</span>;   </span><br><span class="line">r =  <span class="number">0.02735</span>;</span><br><span class="line">predictions = xm./(<span class="number">1</span>+(xm./<span class="number">3.9</span><span class="number">-1</span>).*<span class="built_in">exp</span>(-r.*(t<span class="number">-1790</span>)));  <span class="comment">% 计算预测值（注意这里要写成点乘和点除,这样可以保证按照对应元素进行计算）</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(year,population,<span class="string">&#x27;.&#x27;</span>,t,predictions,<span class="string">&#x27;.&#x27;</span>)  <span class="comment">% 绘制预测结果图</span></span><br></pre></td></tr></table></figure>

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751104.png" style="zoom:80%;" />

<h5 id="相关学术名词解释-word文件"><a href="#相关学术名词解释-word文件" class="headerlink" title="相关学术名词解释 (word文件)"></a><strong><a href="C:\Users\86134\Desktop\数学建模资料\清风数学建模资料\正课配套课件和代码\正课配套的课件和代码\第4讲.拟合\拓展资料\工具箱曲线拟合类型+评价解释.doc" alt="链接">相关学术名词解释</a></strong> (word文件)</h5><h2 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h2><h3 id="Pearson相关系数"><a href="#Pearson相关系数" class="headerlink" title="Pearson相关系数"></a>Pearson相关系数</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751252.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751280.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751293.png" style="zoom:80%;" />

<h4 id="算法代码-5"><a href="#算法代码-5" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">load <span class="string">&#x27;physical fitness test.mat&#x27;</span>  <span class="comment">%文件名如果有空格隔开，那么需要加引号</span></span><br><span class="line"><span class="comment">% https://ww2.mathworks.cn/help/matlab/ref/corrcoef.html</span></span><br><span class="line"><span class="comment">%% 统计描述</span></span><br><span class="line">MIN = <span class="built_in">min</span>(Test);  <span class="comment">% 每一列的最小值</span></span><br><span class="line">MAX = <span class="built_in">max</span>(Test);   <span class="comment">% 每一列的最大值</span></span><br><span class="line">MEAN = <span class="built_in">mean</span>(Test);  <span class="comment">% 每一列的均值</span></span><br><span class="line">MEDIAN = median(Test);  <span class="comment">%每一列的中位数</span></span><br><span class="line">SKEWNESS = skewness(Test); <span class="comment">%每一列的偏度</span></span><br><span class="line">KURTOSIS = kurtosis(Test);  <span class="comment">%每一列的峰度</span></span><br><span class="line">STD = std(Test);  <span class="comment">% 每一列的标准差</span></span><br><span class="line">RESULT = [MIN;MAX;MEAN;MEDIAN;SKEWNESS;KURTOSIS;STD]  <span class="comment">%将这些统计量放到一个矩阵中表示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算各列之间的相关系数</span></span><br><span class="line"><span class="comment">% 在计算皮尔逊相关系数之前,一定要做出散点图来看两组变量之间是否有线性关系</span></span><br><span class="line"><span class="comment">% 这里使用Spss比较方便: 图形 - 旧对话框 - 散点图/点图 - 矩阵散点图</span></span><br><span class="line"></span><br><span class="line">R = corrcoef(Test)   <span class="comment">% correlation coefficient</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 假设检验部分</span></span><br><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);  <span class="comment">%求t分布的概率密度值 28是自由度  </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">grid on  <span class="comment">% 在画出的图上加上网格线</span></span><br><span class="line"><span class="built_in">hold</span> on  <span class="comment">% 保留原来的图，以便继续在上面操作</span></span><br><span class="line"><span class="comment">% matlab可以求出临界值，函数如下</span></span><br><span class="line">tinv(<span class="number">0.975</span>,<span class="number">28</span>)    <span class="comment">%    2.0484</span></span><br><span class="line"><span class="comment">% 这个函数是累积密度函数cdf的反函数</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-2.048</span>,<span class="number">-2.048</span>],[<span class="number">0</span>,tpdf(<span class="number">-2.048</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">2.048</span>,<span class="number">2.048</span>],[<span class="number">0</span>,tpdf(<span class="number">2.048</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算p值</span></span><br><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">grid on </span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 画线段的方法</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-3.055</span>,<span class="number">-3.055</span>],[<span class="number">0</span>,tpdf(<span class="number">-3.055</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">3.055</span>,<span class="number">3.055</span>],[<span class="number">0</span>,tpdf(<span class="number">3.055</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;该检验值对应的p值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-tcdf(<span class="number">3.055</span>,<span class="number">28</span>))*<span class="number">2</span>)  <span class="comment">%双侧检验的p值要乘以2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算各列之间的相关系数以及p值</span></span><br><span class="line">[R,P] = corrcoef(Test)</span><br><span class="line"><span class="comment">% 在EXCEL表格中给数据右上角标上显著性符号吧</span></span><br><span class="line">P &lt; <span class="number">0.01</span>  <span class="comment">% 标记3颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.05</span>) .* (P &gt; <span class="number">0.01</span>)  <span class="comment">% 标记2颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.1</span>) .* (P &gt; <span class="number">0.05</span>) <span class="comment">% % 标记1颗星的位置</span></span><br><span class="line"><span class="comment">% 也可以使用Spss操作哦 看我演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 正态分布检验</span></span><br><span class="line"><span class="comment">% 正态分布的偏度和峰度</span></span><br><span class="line">x = normrnd(<span class="number">2</span>,<span class="number">3</span>,<span class="number">100</span>,<span class="number">1</span>);   <span class="comment">% 生成100*1的随机向量，每个元素是均值为2，标准差为3的正态分布</span></span><br><span class="line">skewness(x)  <span class="comment">%偏度</span></span><br><span class="line">kurtosis(x)  <span class="comment">%峰度</span></span><br><span class="line">qqplot(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment">% 检验第一列数据是否为正态分布</span></span><br><span class="line">[h,p] = jbtest(Test(:,<span class="number">1</span>),<span class="number">0.05</span>)</span><br><span class="line">[h,p] = jbtest(Test(:,<span class="number">1</span>),<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用循环检验所有列的数据</span></span><br><span class="line">n_c = <span class="built_in">size</span>(Test,<span class="number">2</span>);  <span class="comment">% number of column 数据的列数</span></span><br><span class="line">H = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 初始化节省时间和消耗</span></span><br><span class="line">P = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n_c</span><br><span class="line">    [h,p] = jbtest(Test(:,<span class="built_in">i</span>),<span class="number">0.05</span>);</span><br><span class="line">    H(<span class="built_in">i</span>)=h;</span><br><span class="line">    P(<span class="built_in">i</span>)=p;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(H)</span><br><span class="line"><span class="built_in">disp</span>(P)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Q-Q图</span></span><br><span class="line">qqplot(Test(:,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 斯皮尔曼相关系数</span></span><br><span class="line">X = [<span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span>]&#x27;  <span class="comment">% 一定要是列向量哦，一撇&#x27;表示求转置</span></span><br><span class="line">Y = [<span class="number">5</span> <span class="number">10</span> <span class="number">9</span> <span class="number">10</span> <span class="number">6</span>]&#x27;</span><br><span class="line"><span class="comment">% 第一种计算方法</span></span><br><span class="line"><span class="number">1</span><span class="number">-6</span>*(<span class="number">1</span>+<span class="number">0.25</span>+<span class="number">0.25</span>+<span class="number">1</span>)/<span class="number">5</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二种计算方法</span></span><br><span class="line">coeff = corr(X , Y , <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"><span class="comment">% 等价于：</span></span><br><span class="line">RX = [<span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line">RY = [<span class="number">1</span> <span class="number">4.5</span> <span class="number">3</span> <span class="number">4.5</span> <span class="number">2</span>]</span><br><span class="line">R = corrcoef(RX,RY)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算矩阵各列的斯皮尔曼相关系数</span></span><br><span class="line">R = corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 大样本下的假设检验</span></span><br><span class="line"><span class="comment">% 计算检验值</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">sqrt</span>(<span class="number">590</span>)*<span class="number">0.0301</span>)</span><br><span class="line"><span class="comment">% 计算p值</span></span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-normcdf(<span class="number">0.7311</span>))*<span class="number">2</span>) <span class="comment">% normcdf用来计算标准正态分布的累积概率密度函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="SPSS"><a href="#SPSS" class="headerlink" title="SPSS"></a>SPSS</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751316.png" style="zoom:80%;" />







<h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751453.png" style="zoom:80%;" />





<h3 id="分析统计"><a href="#分析统计" class="headerlink" title="分析统计"></a>分析统计</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751508.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751611.png" style="zoom:80%;" />



<h3 id="矩阵散点图"><a href="#矩阵散点图" class="headerlink" title="矩阵散点图"></a>矩阵散点图</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751658.png" style="zoom:80%;" />



<h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>原假设H<del>0</del></li>
<li>备择假设H<del>1</del></li>
<li>置信水平β</li>
<li>显著性水平α</li>
<li>P值</li>
</ul>
<p>等式：α+β&#x3D;1</p>
<p>双侧检验的P值是单侧检验P值的两倍</p>
<p>当计算出的P值小于对应的显著性水平的时候，<strong>拒绝原假设</strong>，选择备择假设</p>
<p>置信水平一般取95%，显著性水平一般为5%</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751684.jpeg" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751711.jpeg" style="zoom:80%;" />





<h4 id="Pearson相关系数假设检验"><a href="#Pearson相关系数假设检验" class="headerlink" title="Pearson相关系数假设检验"></a>Pearson相关系数假设检验</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751890.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751898.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751005.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751028.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751134.png" style="zoom:80%;" />



<h4 id="Pearson假设检验条件"><a href="#Pearson假设检验条件" class="headerlink" title="Pearson假设检验条件"></a>Pearson假设检验条件</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751142.png" style="zoom:80%;" />



<h3 id="正态分布检验"><a href="#正态分布检验" class="headerlink" title="正态分布检验"></a>正态分布检验</h3><p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11A411q7CQ?vd_source=21929b71ec58f67534148e5c4050348c">【SPSS教程】检验正态分布的几种方法及释义】</a></strong></p>
<h4 id="JB检验"><a href="#JB检验" class="headerlink" title="JB检验"></a>JB检验</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751296.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751322.png" style="zoom:80%;" />



<h4 id="夏皮洛—威尔克检验"><a href="#夏皮洛—威尔克检验" class="headerlink" title="夏皮洛—威尔克检验"></a>夏皮洛—威尔克检验</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751414.png" style="zoom:80%;" />



<h4 id="Q—Q图检验"><a href="#Q—Q图检验" class="headerlink" title="Q—Q图检验"></a>Q—Q图检验</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751406.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751504.png" style="zoom:80%;" />





<h3 id="Spearman相关系数"><a href="#Spearman相关系数" class="headerlink" title="Spearman相关系数"></a>Spearman相关系数</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751526.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751628.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751668.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751753.png" style="zoom:80%;" />

<h4 id="假设检验-1"><a href="#假设检验-1" class="headerlink" title="假设检验"></a>假设检验</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751763.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751897.png" style="zoom:80%;" />







<h3 id="两种相关系数的比较"><a href="#两种相关系数的比较" class="headerlink" title="两种相关系数的比较"></a>两种相关系数的比较</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751905.png" style="zoom:80%;" />





<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p><strong><a target="_blank" rel="noopener" href="https://csacademy.com/app/graph_editor/">在线作图</a></strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751001.png" style="zoom:80%;" />

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab作无向图</span></span><br><span class="line"><span class="comment">% （1）无权重（每条边的权重默认为1）</span></span><br><span class="line"><span class="comment">% 函数graph(s,t)：可在 s 和 t 中的对应节点之间创建边，并生成一个图</span></span><br><span class="line"><span class="comment">% s 和 t 都必须具有相同的元素数；这些节点必须都是从1开始的正整数，或都是字符串元胞数组。</span></span><br><span class="line">s1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t1 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">G1 = graph(s1, t1);</span><br><span class="line"><span class="built_in">plot</span>(G1)</span><br><span class="line"><span class="comment">% 注意哦，编号最好是从1开始连续编号，不要自己随便定义编号</span></span><br><span class="line">s1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t1 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">G1 = graph(s1, t1);</span><br><span class="line"><span class="built_in">plot</span>(G1)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意字符串元胞数组是用大括号包起来的哦</span></span><br><span class="line">s2 = &#123;<span class="string">&#x27;学校&#x27;</span>,<span class="string">&#x27;电影院&#x27;</span>,<span class="string">&#x27;网吧&#x27;</span>,<span class="string">&#x27;酒店&#x27;</span>&#125;;</span><br><span class="line">t2 = &#123;<span class="string">&#x27;电影院&#x27;</span>,<span class="string">&#x27;酒店&#x27;</span>,<span class="string">&#x27;酒店&#x27;</span>,<span class="string">&#x27;KTV&#x27;</span>&#125;;</span><br><span class="line">G2 = graph(s2, t2);</span><br><span class="line"><span class="built_in">plot</span>(G2, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>)  <span class="comment">% 设置线的宽度</span></span><br><span class="line"><span class="comment">% 下面的命令是在画图后不显示坐标</span></span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br><span class="line"><span class="comment">% （2）有权重</span></span><br><span class="line"><span class="comment">% 函数graph(s,t,w)：可在 s 和 t 中的对应节点之间以w的权重创建边，并生成一个图</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">w = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>];</span><br><span class="line">G = graph(s, t, w);</span><br><span class="line"><span class="built_in">plot</span>(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>) </span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br><span class="line"><span class="comment">%% Matlab作有向图</span></span><br><span class="line"><span class="comment">% 无权图 digraph(s,t)</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>];</span><br><span class="line">G = digraph(s, t);</span><br><span class="line"><span class="built_in">plot</span>(G)</span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br><span class="line"><span class="comment">% 有权图 digraph(s,t,w)</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">w = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>];</span><br><span class="line">G = digraph(s, t, w);</span><br><span class="line"><span class="built_in">plot</span>(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">3</span>) </span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br></pre></td></tr></table></figure>



<h3 id="迪杰斯特拉算法（广度优先算法）"><a href="#迪杰斯特拉算法（广度优先算法）" class="headerlink" title="迪杰斯特拉算法（广度优先算法）"></a>迪杰斯特拉算法（广度优先算法）</h3><p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av54668527">算法理论视频</a></strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751057.png" style="zoom:80%;" />



<h3 id="贝尔曼福特算法"><a href="#贝尔曼福特算法" class="headerlink" title="贝尔曼福特算法"></a>贝尔曼福特算法</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751142.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751132.png" style="zoom:80%;" />





<h3 id="算法代码-6"><a href="#算法代码-6" class="headerlink" title="算法代码"></a>算法代码</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751284.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751295.png" style="zoom:80%;" />



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">% 注意哦，Matlab中的图节点要从<span class="number">1</span>开始编号，所以这里把<span class="number">0</span>全部改为了<span class="number">9</span></span><br><span class="line">% 编号最好是从<span class="number">1</span>开始连续编号，不要自己随便定义编号</span><br><span class="line">s = [<span class="number">9</span> <span class="number">9</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">7</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span>  <span class="number">5</span>  <span class="number">5</span> <span class="number">4</span>];</span><br><span class="line">t = [<span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">3</span>];</span><br><span class="line">w = [<span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">6</span> <span class="number">2</span> <span class="number">14</span> <span class="number">10</span> <span class="number">9</span>];</span><br><span class="line">G = graph(s,t,w);</span><br><span class="line">plot(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>) </span><br><span class="line"><span class="built_in">set</span>( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line">[P,d] = shortestpath(G, <span class="number">9</span>, <span class="number">4</span>)  %注意：该函数matlab2015b之后才有哦</span><br><span class="line"></span><br><span class="line">% 在图中高亮我们的最短路径</span><br><span class="line">myplot = plot(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>);  %首先将图赋给一个变量</span><br><span class="line">highlight(myplot, P, <span class="string">&#x27;EdgeColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)   %对这个变量即我们刚刚绘制的图形进行高亮处理（给边加上r红色）</span><br><span class="line"></span><br><span class="line">% 求出任意两点的最短路径矩阵</span><br><span class="line">D = distances(G)   %注意：该函数matlab2015b之后才有哦</span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>)  % <span class="number">1</span> -&gt; <span class="number">2</span>的最短路径</span><br><span class="line">D(<span class="number">9</span>,<span class="number">4</span>)  % <span class="number">9</span> -&gt; <span class="number">4</span>的最短路径</span><br><span class="line"></span><br><span class="line">% 找出给定范围内的所有点  nearest(G,s,d)</span><br><span class="line">% 返回图形 G 中与节点 s 的距离在 d 之内的所有节点</span><br><span class="line">[nodeIDs,dist] = nearest(G, <span class="number">2</span>, <span class="number">10</span>)   %注意：该函数matlab2016a之后才有哦</span><br></pre></td></tr></table></figure>





<h3 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h3><p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av54668527">算法理论视频</a></strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751382.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751391.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751549.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751542.png" style="zoom:80%;" />



<h4 id="算法代码-7"><a href="#算法代码-7" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[dist,path]</span> = <span class="title">Floyd_algorithm</span><span class="params">(D)</span></span></span><br><span class="line"><span class="comment">%% 该函数用于求解一个权重邻接矩阵任意两个节点之间的最短路径</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        D是权重邻接矩阵</span></span><br><span class="line"><span class="comment">% 输出：</span></span><br><span class="line"><span class="comment">%        dist是最短距离矩阵，其元素dist_ij表示表示i,j两个节点的最短距离</span></span><br><span class="line"><span class="comment">%        path是路径矩阵，其元素path_ij表示起点为i，终点为j的两个节点之间的最短路径要经过的节点</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(D,<span class="number">1</span>);  <span class="comment">% 计算节点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化dist矩阵</span></span><br><span class="line">dist = D;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面我们来初始化path矩阵</span></span><br><span class="line">path = <span class="built_in">zeros</span>(n);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">    path(:,<span class="built_in">j</span>) = <span class="built_in">j</span>;   <span class="comment">% 将第j列的元素变为j</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    path(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">-1</span>;  <span class="comment">% 将主对角线元素变为-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面开始三个循环</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:n    <span class="comment">% 中间节点k从1- n 循环</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n     <span class="comment">% 起始节点i从1- n 循环</span></span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n    <span class="comment">% 终点节点j从1-n 循环</span></span><br><span class="line">          <span class="keyword">if</span> dist(<span class="built_in">i</span>,<span class="built_in">j</span>)&gt;dist(<span class="built_in">i</span>,k)+dist(k,<span class="built_in">j</span>)  <span class="comment">% 如果i,j两个节点间的最短距离大于i和k的最短距离+k和j的最短距离</span></span><br><span class="line">             dist(<span class="built_in">i</span>,<span class="built_in">j</span>)=dist(<span class="built_in">i</span>,k)+dist(k,<span class="built_in">j</span>);  <span class="comment">% 那么我们就令这两个较短的距离之和取代i,j两点之间的最短距离</span></span><br><span class="line">             path(<span class="built_in">i</span>,<span class="built_in">j</span>)=path(<span class="built_in">i</span>,k);   <span class="comment">% 起点为i，终点为j的两个节点之间的最短路径要经过的节点更新为path(i,k)</span></span><br><span class="line">             <span class="comment">% 注意，上面一行语句不能写成path(i,j) = k; 这是网上很多地方都容易犯的错误，在PPT11页中会告诉大家为什么不能这么写</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">print_path</span><span class="params">(path,dist,i,j)</span></span></span><br><span class="line"><span class="comment">%% 该函数的作用是打印从i到j经过的最短路径</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        path是使用floyd算法求出来的路径矩阵</span></span><br><span class="line"><span class="comment">%        dist是使用floyd算法求出来的最短距离矩阵</span></span><br><span class="line"><span class="comment">%        i是起始节点的编号</span></span><br><span class="line"><span class="comment">%        j是终点节点的编号</span></span><br><span class="line"><span class="comment">% 输出：无</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">i</span> == <span class="built_in">j</span></span><br><span class="line">    warning(<span class="string">&#x27;起点和终点相同，请检查后重新输入&#x27;</span>)  <span class="comment">% 在屏幕中提示警告信息</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">% 不运行下面的语句，直接退出函数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> path(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="built_in">j</span>   <span class="comment">% 如果path(i,j) = j，则有两种可能：</span></span><br><span class="line"><span class="comment">% （1）如果dist(i,j) 为 Inf , 则说明从i到j没有路径可以到达</span></span><br><span class="line">    <span class="keyword">if</span> dist(<span class="built_in">i</span>,<span class="built_in">j</span>) == Inf</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;没有路径可以到达&#x27;</span>])</span><br><span class="line"><span class="comment">% （2）如果dist(i,j) 不为 Inf , 则说明从i到j可直接到达，且为最短路径</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;的最短路径为&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([num2str(<span class="built_in">i</span>),<span class="string">&#x27; ---&gt; &#x27;</span>,num2str(<span class="built_in">j</span>)])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;最短距离为&#x27;</span>,num2str(dist(<span class="built_in">i</span>,<span class="built_in">j</span>))])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span>  <span class="comment">% 如果path(i,j) ~= j，则说明中间经过了其他节点：</span></span><br><span class="line">    k = path(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    result = [num2str(<span class="built_in">i</span>),<span class="string">&#x27; ---&gt; &#x27;</span>];  <span class="comment">% 初始化要打印的这个字符串</span></span><br><span class="line">    <span class="keyword">while</span> k ~= <span class="built_in">j</span>  <span class="comment">% 只要k不等于j, 就一直循环下去</span></span><br><span class="line">        result = [result , num2str(k) , <span class="string">&#x27; ---&gt; &#x27;</span> ];  <span class="comment">% i先走到k这个节点处</span></span><br><span class="line">        k = path(k,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = [result , num2str(k)];</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;的最短路径为&#x27;</span>])</span><br><span class="line">    <span class="built_in">disp</span>(result)</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;最短距离为&#x27;</span>,num2str(dist(<span class="built_in">i</span>,<span class="built_in">j</span>))])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">print_all_path</span><span class="params">(D)</span></span></span><br><span class="line"><span class="comment">%% 该函数的作用是求解一个权重邻接矩阵任意两个节点之间的最短路径,并打印所有的结果出来</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        D是权重邻接矩阵</span></span><br><span class="line"><span class="comment">% 输出：无</span></span><br><span class="line"></span><br><span class="line">[dist,path] = Floyd_algorithm(D);   <span class="comment">% 调用之前的Floyd_algorithm函数</span></span><br><span class="line">n = <span class="built_in">size</span>(D,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">    warning(<span class="string">&#x27;请输入至少两阶以上的权重邻接矩阵&#x27;</span>)   <span class="comment">% 在屏幕中提示警告信息</span></span><br><span class="line">    <span class="keyword">return</span>;   <span class="comment">% 不运行下面的语句，直接退出函数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">i</span> ~= <span class="built_in">j</span>  <span class="comment">% 不等号用~=表示</span></span><br><span class="line">            print_path(path,dist,<span class="built_in">i</span>,<span class="built_in">j</span>);   <span class="comment">% 调用之前的print_path函数</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;-------------------------------------------&#x27;</span>)</span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>主函数</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% PPT第七页的例子</span></span><br><span class="line"><span class="comment">%% 首先将图转换为权重邻接矩阵D</span></span><br><span class="line">n = <span class="number">5</span>;  <span class="comment">%一共五个节点</span></span><br><span class="line">D = <span class="built_in">ones</span>(n) ./ <span class="built_in">zeros</span>(n);  <span class="comment">% 全部元素初始化为Inf</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    D(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">0</span>;  <span class="comment">% 主对角线元素为0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line">D(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">D(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">-4</span>;</span><br><span class="line">D(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">7</span>;</span><br><span class="line">D(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">D(<span class="number">3</span>,<span class="number">2</span>) = <span class="number">4</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">3</span>) = <span class="number">-5</span>;</span><br><span class="line">D(<span class="number">5</span>,<span class="number">4</span>) = <span class="number">6</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用Floyd_algorithm函数求解</span></span><br><span class="line">[dist,path] = Floyd_algorithm(D)</span><br><span class="line"></span><br><span class="line">print_path(path,dist,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">print_path(path,dist,<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">print_path(path,dist,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;下面我们打印任意两点之间的最短距离：&#x27;</span>)</span><br><span class="line">print_all_path(D)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 思考题的参考答案</span></span><br><span class="line"><span class="comment">%% 首先将图转换为权重邻接矩阵D</span></span><br><span class="line">n = <span class="number">9</span>;  <span class="comment">%一共九个节点</span></span><br><span class="line">D = <span class="built_in">zeros</span>(n);  <span class="comment">% 全部元素初始化为0, 等会你们就知道为什么这样设置啦</span></span><br><span class="line"><span class="comment">% 因为是无向图，所以权重邻接矩阵是一个对称矩阵</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">4</span>; D(<span class="number">1</span>,<span class="number">8</span>) = <span class="number">8</span>; </span><br><span class="line">D(<span class="number">2</span>,<span class="number">8</span>) = <span class="number">3</span>; D(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">D(<span class="number">8</span>,<span class="number">9</span>) = <span class="number">1</span>; D(<span class="number">8</span>,<span class="number">7</span>) = <span class="number">6</span>; </span><br><span class="line">D(<span class="number">9</span>,<span class="number">7</span>) = <span class="number">6</span>; D(<span class="number">9</span>,<span class="number">3</span>) = <span class="number">2</span>;</span><br><span class="line">D(<span class="number">7</span>,<span class="number">6</span>) = <span class="number">2</span>; D(<span class="number">3</span>,<span class="number">4</span>) = <span class="number">7</span>; </span><br><span class="line">D(<span class="number">3</span>,<span class="number">6</span>) = <span class="number">4</span>; D(<span class="number">6</span>,<span class="number">4</span>) = <span class="number">14</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">5</span>) = <span class="number">9</span>; D(<span class="number">6</span>,<span class="number">5</span>) = <span class="number">10</span>;</span><br><span class="line">D = D+D&#x27;;   <span class="comment">% 这个操作可以得到对称矩阵的另一半</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> ~= <span class="built_in">j</span>) &amp;&amp; (D(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="number">0</span>)  </span><br><span class="line">            D(<span class="built_in">i</span>,<span class="built_in">j</span>) = Inf;   <span class="comment">% 将非主对角线上的0元素全部变为Inf</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用Floyd_algorithm函数求解</span></span><br><span class="line">[dist,path] = Floyd_algorithm(D)</span><br><span class="line">print_all_path(D)</span><br></pre></td></tr></table></figure>





<h2 id="多元回归分析"><a href="#多元回归分析" class="headerlink" title="多元回归分析"></a>多元回归分析</h2><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751646.png" alt="Snipaste_2023-01-10_20-44-23" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751735.png" alt="Snipaste_2023-01-10_20-44-36" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751756.png" alt="Snipaste_2023-01-10_20-43-53" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751777.png" alt="Snipaste_2023-01-10_20-44-15" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751925.png" alt="Snipaste_2023-01-10_20-44-48" style="zoom:80%;" />











<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751955.png" alt="Snipaste_2023-01-10_20-46-58" style="zoom:80%;" />



<h3 id="回归分析的分类"><a href="#回归分析的分类" class="headerlink" title="回归分析的分类"></a>回归分析的分类</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751989.png" style="zoom:80%;" />



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751145.png" alt="Snipaste_2023-01-10_20-53-22" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751187.png" alt="Snipaste_2023-01-10_20-53-28" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751221.png" alt="Snipaste_2023-01-10_20-53-41" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751336.png" style="zoom:80%;" />





<h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751368.png" style="zoom:80%;" />







<h3 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751377.png" alt="Snipaste_2023-01-10_21-09-47" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751542.png" alt="Snipaste_2023-01-10_21-12-33" style="zoom:80%;" />

<h4 id="解释变量模型"><a href="#解释变量模型" class="headerlink" title="解释变量模型"></a>解释变量模型</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751611.png" alt="Snipaste_2023-01-10_21-49-52" style="zoom:80%;" />

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751645.png" alt="Snipaste_2023-01-10_21-53-03" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751724.png" alt="Snipaste_2023-01-10_21-53-13" style="zoom:80%;" />



<h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751765.png" alt="Snipaste_2023-01-10_21-20-56" style="zoom:80%;" />



<h4 id="自变量不充分产生内生性"><a href="#自变量不充分产生内生性" class="headerlink" title="自变量不充分产生内生性"></a>自变量不充分产生内生性</h4><p><strong>内生性：因为自变量个数不充分引起的</strong></p>
<p><strong>外生性：自变量个数恰好可以完全解释因变量</strong></p>
<p><strong>多重共线性：自变量过多，引起自变量之间存在相关性</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751744.png" alt="Snipaste_2023-01-10_21-24-45" style="zoom:80%;" />



<h4 id="核心解释变量和控制变量解救内生性"><a href="#核心解释变量和控制变量解救内生性" class="headerlink" title="核心解释变量和控制变量解救内生性"></a>核心解释变量和控制变量解救内生性</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751927.png" style="zoom:80%;" />



<h4 id="回归模型解释"><a href="#回归模型解释" class="headerlink" title="回归模型解释"></a>回归模型解释</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751960.png" alt="Snipaste_2023-01-10_21-49-44" style="zoom:80%;" />



<h4 id="交互项"><a href="#交互项" class="headerlink" title="交互项"></a>交互项</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751048.png" style="zoom:80%;" />



<h3 id="回归方法"><a href="#回归方法" class="headerlink" title="回归方法"></a>回归方法</h3><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751142.png" alt="Snipaste_2023-01-11_18-47-52" style="zoom:80%;" />

<h4 id="处理语法"><a href="#处理语法" class="headerlink" title="处理语法"></a>处理语法</h4><p><strong>数据描述</strong></p>
<ul>
<li>summarize	定量数据</li>
<li>tabulate         定性数据</li>
<li>regress  y  x1  x2  …  x<del>k</del></li>
</ul>
<p><strong>原假设：回归系数不显著异于0</strong></p>
<p><strong>当P&lt;0.05时拒绝原假设，认为回归系数显著异于0，回归系数有效</strong></p>
<p><strong>联合显著性检验：验证回归模型的正确性</strong></p>
<p><strong>原假设同上</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751178.png" alt="Snipaste_2023-01-11_19-23-50" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751184.png" alt="Snipaste_2023-01-11_20-01-23" style="zoom:80%;" />



<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">﻿<span class="comment">// 按键盘上的PageUp可以使用上一次输入的代码（Matleb中是上箭头）</span></span><br><span class="line"><span class="comment">// 清除所有变量</span></span><br><span class="line"><span class="keyword">clear</span></span><br><span class="line"><span class="comment">// 清屏 和 matlab的clc类似</span></span><br><span class="line">cls </span><br><span class="line"><span class="comment">// 导入数据（其实是我们直接在界面上粘贴过来的，我们用鼠标点界面导入更方便 本条请删除后再复制到论文中，如果评委老师看到了就知道这不是你写的了）</span></span><br><span class="line"><span class="comment">// import excel &quot;C:\Users\hc_lzp\Desktop\数学建模视频录制\第7讲.多元回归分析\代码和例题数据\课堂中讲解的奶粉数据.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow</span></span><br><span class="line">import excel <span class="string">&quot;课堂中讲解的奶粉数据.xlsx&quot;</span>, sheet(<span class="string">&quot;Sheet1&quot;</span>) firstrow</span><br><span class="line"><span class="comment">// 定量变量的描述性统计</span></span><br><span class="line"><span class="keyword">summarize</span> 团购价元 评价量 商品毛重kg  <span class="comment">// 对定量数据进行描述性统计</span></span><br><span class="line"><span class="comment">// 定性变量的频数分布，并得到相应字母开头的虚拟变量</span></span><br><span class="line"><span class="keyword">tabulate</span> 配方,<span class="keyword">gen</span>(A)	<span class="comment">// 对定性数据进行描述性统计</span></span><br><span class="line"><span class="keyword">tabulate</span> 奶源产地 ,<span class="keyword">gen</span>(B)</span><br><span class="line"><span class="keyword">tabulate</span> 国产或进口 ,<span class="keyword">gen</span>(C)</span><br><span class="line"><span class="keyword">tabulate</span> 适用年龄岁 ,<span class="keyword">gen</span>(<span class="keyword">D</span>)</span><br><span class="line"><span class="keyword">tabulate</span> 包装单位 ,<span class="keyword">gen</span>(<span class="keyword">E</span>)</span><br><span class="line"><span class="keyword">tabulate</span> 分类 ,<span class="keyword">gen</span>(F)</span><br><span class="line"><span class="keyword">tabulate</span> 段位 ,<span class="keyword">gen</span>(<span class="keyword">G</span>)</span><br><span class="line"><span class="comment">// 下面进行回归</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg	<span class="comment">// 默认OLS：最小二乘法</span></span><br><span class="line"><span class="comment">// 下面的语句可帮助我们把回归结果保存在Word文档中</span></span><br><span class="line"><span class="comment">// 在使用之前需要运行下面这个代码来安装下这个功能包（运行一次之后就可以注释掉了）</span></span><br><span class="line"><span class="comment">// ssc install reg2docx, all replace</span></span><br><span class="line"><span class="comment">// 如果安装出现connection timed out的错误，可以尝试换成手机热点联网，如果手机热点也不能下载，就不用这个命令吧，可以自己做一个回归结果表，如果觉得麻烦就直接把回归结果截图。</span></span><br><span class="line"><span class="keyword">est</span> store m1</span><br><span class="line">reg2docx m1 using m1.docx, <span class="keyword">replace</span></span><br><span class="line"><span class="comment">// *** p&lt;0.01  ** p&lt;0.05 * p&lt;0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stata会自动剔除多重共线性的变量</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4</span><br><span class="line"><span class="keyword">est</span> store m2</span><br><span class="line">reg2docx m2 using m2.docx, <span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到标准化回归系数</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg, b </span><br><span class="line"></span><br><span class="line"><span class="comment">// 画出残差图</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4</span><br><span class="line"><span class="keyword">rvfplot</span> </span><br><span class="line"><span class="comment">// 残差与拟合值的散点图</span></span><br><span class="line"><span class="keyword">graph</span> export a1.png ,<span class="keyword">replace</span></span><br><span class="line"><span class="comment">// 残差与自变量团购价的散点图</span></span><br><span class="line"><span class="keyword">rvpplot</span>  团购价元</span><br><span class="line"><span class="keyword">graph</span> export a2.png ,<span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么评价量的拟合值会出现负数？</span></span><br><span class="line"><span class="comment">// 描述性统计并给出分位数对应的数值</span></span><br><span class="line"><span class="keyword">summarize</span> 评价量,<span class="keyword">d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作评价量的概率密度估计图</span></span><br><span class="line"><span class="keyword">kdensity</span> 评价量 </span><br><span class="line"><span class="keyword">graph</span> export a3.png ,<span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异方差BP检验</span></span><br><span class="line"><span class="keyword">estat</span> <span class="keyword">hettest</span> ,rhs iid</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异方差怀特检验</span></span><br><span class="line"><span class="keyword">estat</span> <span class="keyword">imtest</span>,white</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用OLS + 稳健的标准误</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4, r</span><br><span class="line"><span class="keyword">est</span> store m3</span><br><span class="line">reg2docx m3 using m3.docx, <span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算VIF</span></span><br><span class="line"><span class="keyword">estat</span>  <span class="keyword">vif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐步回归（一定要注意完全多重共线性的影响）</span></span><br><span class="line"><span class="comment">// 向前逐步回归（后面的r表示稳健的标准误）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r pe(0.05)</span><br><span class="line"><span class="comment">// 向后逐步回归（后面的r表示稳健的标准误）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r <span class="keyword">pr</span>(0.05)</span><br><span class="line"><span class="comment">// 向后逐步回归的同时使用标准化回归系数（在r后面跟上一个b即可）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r b <span class="keyword">pr</span>(0.05)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补充语法 (大家不需要具体的去学Stata软件，掌握我课堂上教给大家的一些命令应对数学建模比赛就可以啦)</span></span><br><span class="line"><span class="comment">// 事实上大家学好Excel，学好后应对90%的数据预处理问题都能解决</span></span><br><span class="line"><span class="comment">// (1) 用已知变量生成新的变量 </span></span><br><span class="line"><span class="keyword">generate</span> lny = <span class="built_in">log</span>(评价量)  </span><br><span class="line"><span class="keyword">generate</span> price_square = 团购价元 ^2</span><br><span class="line"><span class="keyword">generate</span> interaction_term = 团购价元*商品毛重kg</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 修改变量名称，因为用中文命名变量名称有时候可能容易出现未知Bug</span></span><br><span class="line"><span class="keyword">rename</span> 团购价元 price</span><br></pre></td></tr></table></figure>



<p><strong>虚变量</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751341.png" alt="Snipaste_2023-01-11_19-31-20" style="zoom:80%;" />

<h3 id="R-2-较低处理方法"><a href="#R-2-较低处理方法" class="headerlink" title="R^2^较低处理方法"></a>R^2^较低处理方法</h3><ul>
<li><strong>预测性回归看重R^2^、解释性回归不看重R^2^</strong></li>
<li><strong>调整模型，将自变量或者因变量取对数，或者交互项（解释不清楚）</strong></li>
<li><strong>数据存在异常值，或者数据分布不均匀。调整数据</strong></li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751386.png" alt="Snipaste_2023-01-11_19-51-12" style="zoom:80%;" />



<h3 id="标准化回归消除量纲（度量影响力）"><a href="#标准化回归消除量纲（度量影响力）" class="headerlink" title="标准化回归消除量纲（度量影响力）"></a>标准化回归消除量纲（度量影响力）</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751450.png" alt="Snipaste_2023-01-11_20-00-36" style="zoom:80%;" />



<h3 id="异方差"><a href="#异方差" class="headerlink" title="异方差"></a>异方差</h3><p><strong>异方差：扰动项方差不一致</strong></p>
<p><strong>截面数据容易出现异方差</strong></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751549.png" alt="Snipaste_2023-01-11_20-46-28" style="zoom:80%;" />

<h4 id="异方差的影响和解决"><a href="#异方差的影响和解决" class="headerlink" title="异方差的影响和解决"></a>异方差的影响和解决</h4><p><strong>影响</strong></p>
<ul>
<li>导致回归系数失效</li>
<li>假设检验无法使用</li>
<li>OLS估计量不是最优线性无偏估计量</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>使用OLS+稳健标准误（推荐）</li>
<li>广义最小二乘法GLS</li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751584.png" alt="Snipaste_2023-01-11_20-46-36" style="zoom:80%;" />



<h4 id="检验异方差存在"><a href="#检验异方差存在" class="headerlink" title="检验异方差存在"></a>检验异方差存在</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751739.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751752.png" alt="Snipaste_2023-01-11_23-35-40" style="zoom:80%;" />

<h5 id="BP检验"><a href="#BP检验" class="headerlink" title="BP检验"></a>BP检验</h5><p><strong>原假设：不存在异方差</strong></p>
<p><strong>P&gt;0.05时说明在95%的置信水平下扰动项不存在异方差</strong></p>
<p><strong>即不拒绝原假设</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751804.png" alt="Snipaste_2023-01-11_23-35-47" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751852.png" alt="Snipaste_2023-01-11_23-35-54" style="zoom:80%;" />



<h5 id="怀特检验"><a href="#怀特检验" class="headerlink" title="怀特检验"></a>怀特检验</h5><p><strong>原假设同上</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751979.png" alt="Snipaste_2023-01-11_23-36-01" style="zoom:80%;" />



<h4 id="异方差的解决"><a href="#异方差的解决" class="headerlink" title="异方差的解决"></a>异方差的解决</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751026.png" alt="Snipaste_2023-01-11_23-36-08" style="zoom:80%;" />

<h5 id="稳健标准误（推荐）"><a href="#稳健标准误（推荐）" class="headerlink" title="稳健标准误（推荐）"></a>稳健标准误（推荐）</h5><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751157.png" alt="Snipaste_2023-01-11_23-36-15" style="zoom:80%;" />



<h3 id="多重共线性"><a href="#多重共线性" class="headerlink" title="多重共线性"></a>多重共线性</h3><p><strong>自变量之间存在相关性引起</strong></p>
<p><strong>影响：</strong></p>
<ul>
<li><strong>多重共线性会使得回归系数估计不准确</strong></li>
<li><strong>总体F检验显著，但单个系数t检验不显著</strong></li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751200.png" alt="Snipaste_2023-01-11_23-36-21" style="zoom:80%;" />



<h4 id="多重共线性检验"><a href="#多重共线性检验" class="headerlink" title="多重共线性检验"></a>多重共线性检验</h4><p><strong>VIF&gt;10认为存在严重的多重共线性</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751187.png" alt="Snipaste_2023-01-11_23-36-29" style="zoom:80%;" />



<h4 id="多重共线性处理方法"><a href="#多重共线性处理方法" class="headerlink" title="多重共线性处理方法"></a>多重共线性处理方法</h4><ul>
<li>预测回归不关注多重共线性问题，解释回归关注</li>
<li>当多重共线性不影响解释变量时，可以不考虑多重共线性的影响</li>
<li>当多重共线性影响解释变量时，增大样本容量，剔除导致严重共线性的变量或者修改模型</li>
<li>逐步回归法</li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751238.png" alt="Snipaste_2023-01-11_23-36-35" style="zoom:80%;" />

<h5 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h5><p><strong>向后逐步回归更好</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751364.png" alt="Snipaste_2023-01-11_23-36-42" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751459.png" style="zoom: 80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751539.png" alt="Snipaste_2023-01-11_23-36-49" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751564.png" alt="Snipaste_2023-01-11_23-36-59" style="zoom:80%;" />









<h2 id="岭回归和lasso回归（逐步回归升级版）（解决多重共线性）"><a href="#岭回归和lasso回归（逐步回归升级版）（解决多重共线性）" class="headerlink" title="岭回归和lasso回归（逐步回归升级版）（解决多重共线性）"></a>岭回归和lasso回归（逐步回归升级版）（解决多重共线性）</h2><ul>
<li><strong>逐步回归升级版</strong></li>
<li><strong>解决多重共线性</strong></li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751692.png" style="zoom:80%;" />





<h3 id="古典回归模型"><a href="#古典回归模型" class="headerlink" title="古典回归模型"></a>古典回归模型</h3><p>瞒住四个假定：</p>
<ul>
<li>线性假定</li>
<li>严格外生性</li>
<li>无多重共线性</li>
<li>球形扰动项</li>
</ul>
<h3 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h3><p><strong>适用于样本数量n小于指标数量的情况</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751714.png" style="zoom:80%;" />



<h4 id="λ选取"><a href="#λ选取" class="headerlink" title="λ选取"></a>λ选取</h4><p><strong>方法</strong></p>
<ul>
<li><strong>岭迹分析</strong></li>
<li><strong>VIF法（方差膨胀因子）</strong></li>
<li><strong>最小化均方误差（MPSE）</strong></li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751775.png" alt="Snipaste_2023-01-12_20-53-19" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751885.png" alt="Snipaste_2023-01-12_20-55-44" style="zoom:80%;" />



<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53905488">知乎链接</a></strong></p>
<h3 id="lasso回归（推荐）"><a href="#lasso回归（推荐）" class="headerlink" title="lasso回归（推荐）"></a>lasso回归（推荐）</h3><p><strong>优点</strong></p>
<ul>
<li><strong>可以将不重要的回归系数压缩至0</strong></li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>没有显示解，只能使用近似估计算法</strong></li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751949.png" alt="Snipaste_2023-01-12_20-56-06" style="zoom:80%;" />



<h4 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751976.png" style="zoom:80%;" />



<h4 id="压缩不重要的自变量"><a href="#压缩不重要的自变量" class="headerlink" title="压缩不重要的自变量"></a>压缩不重要的自变量</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751112.png" alt="Snipaste_2023-01-12_21-13-40" style="zoom:80%;" />



<h4 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751274.png" style="zoom:80%;" />



<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751146.png" style="zoom:80%;" />

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空工作区数据</span></span><br><span class="line"><span class="keyword">clear</span></span><br><span class="line"><span class="comment">// 安装lassopack命令,见课件</span></span><br><span class="line"><span class="comment">// findit lassopack   </span></span><br><span class="line"><span class="comment">// 导入数据，注意修改Excel文件的地址</span></span><br><span class="line">import excel <span class="string">&quot;C:\Users\hc_lzp\Desktop\数学建模视频录制\A01更新\岭回归和lasso回归\数据和拓展资料\棉花产量论文作业的数据.xlsx&quot;</span>, sheet(<span class="string">&quot;data&quot;</span>) firstrow</span><br><span class="line"><span class="comment">// 注意：这里自变量的量纲相同所以不用标准化，如果需要标准化，那么可以借助Matlab的zscore函数，或者直接使用SPSS（分析-描述统计-描述：在描述列表的方框左下角，看到“将标准化得分另存为变量（Z）之后点击打勾，然后确定。）</span></span><br><span class="line"><span class="comment">// Stata中也有相应的标准化变量的命令，不过一次只能标准化一个变量，例如： egen Y = std(单产)   这个代码就表示将单产标准化，得到的变量记为Y</span></span><br><span class="line">cvlasso 单产 种子费 化肥费 农药费 机械费 灌溉费, lopt seed(520)</span><br></pre></td></tr></table></figure>



<h2 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h2><p>方法</p>
<ul>
<li>逻辑回归（logistic regression）</li>
<li>费希尔线性回归（Fisher线性判别）</li>
</ul>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><h4 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h4><p><strong>首先：</strong>将决策变量转化为虚拟变量0-1</p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751694.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751706.png" style="zoom:80%;" />



<p>如果<strong>自变量是定性变量</strong>，需要对自变量<strong>进行虚拟化</strong></p>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751006.png" alt="Snipaste_2023-01-26_21-59-25" style="zoom:80%;" />



<p><strong>提高预测精度的方法</strong></p>
<ul>
<li>加入平方项或交互项（可能会造成过拟合现象）</li>
<li>交叉验证</li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751020.png" alt="Snipaste_2023-01-26_22-00-00" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751127.png" alt="Snipaste_2023-01-26_22-00-53" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751382.png" style="zoom:80%;" />



<h4 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751432.png" alt="Snipaste_2023-01-26_22-33-11" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751460.png" alt="Snipaste_2023-01-26_22-33-21" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751501.png" alt="Snipaste_2023-01-26_22-33-29" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751537.png" alt="Snipaste_2023-01-26_22-34-20" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751581.png" style="zoom:80%;" />





<h3 id="Fisher线性判别分析"><a href="#Fisher线性判别分析" class="headerlink" title="Fisher线性判别分析"></a>Fisher线性判别分析</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751732.png" style="zoom:80%;" />



<h4 id="二分类-1"><a href="#二分类-1" class="headerlink" title="二分类"></a>二分类</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751832.png" alt="Snipaste_2023-01-26_22-20-09" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751839.png" style="zoom:80%;" />



<h4 id="多分类-1"><a href="#多分类-1" class="headerlink" title="多分类"></a>多分类</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751864.png" alt="Snipaste_2023-01-26_22-30-33" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751945.png" style="zoom:80%;" />



<h2 id="聚类模型"><a href="#聚类模型" class="headerlink" title="聚类模型"></a>聚类模型</h2><p><strong>注意：</strong>需要对数据进行标准化</p>
<h3 id="K-means聚类算法（基于距离）"><a href="#K-means聚类算法（基于距离）" class="headerlink" title="K-means聚类算法（基于距离）"></a>K-means聚类算法（基于距离）</h3><p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751992.png"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751139.png" alt="Snipaste_2023-01-29_20-16-30"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751197.png" alt="Snipaste_2023-01-29_20-15-54"></p>
<h4 id="算法优劣"><a href="#算法优劣" class="headerlink" title="算法优劣"></a>算法优劣</h4><p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751217.png" alt="Snipaste_2023-01-29_20-16-42"></p>
<h3 id="K-means-改进算法（基于距离）"><a href="#K-means-改进算法（基于距离）" class="headerlink" title="K-means++改进算法（基于距离）"></a>K-means++改进算法（基于距离）</h3><p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751268.png" alt="Snipaste_2023-01-29_20-17-03"></p>
<h4 id="spss操作"><a href="#spss操作" class="headerlink" title="spss操作"></a>spss操作</h4><p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751331.png" alt="Snipaste_2023-01-29_20-22-35"></p>
<h3 id="系统（层次）聚类（基于距离）（推荐）"><a href="#系统（层次）聚类（基于距离）（推荐）" class="headerlink" title="系统（层次）聚类（基于距离）（推荐）"></a>系统（层次）聚类（基于距离）（推荐）</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751416.png" style="zoom:80%;" />

<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751483.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751532.png" alt="Snipaste_2023-01-29_20-40-35" style="zoom:80%;" />

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751540.png" alt="Snipaste_2023-01-29_20-45-56" style="zoom:80%;" />



<h4 id="spss操作-1"><a href="#spss操作-1" class="headerlink" title="spss操作"></a>spss操作</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751660.png" alt="Snipaste_2023-01-29_20-50-11" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751742.png" alt="Snipaste_2023-01-29_20-50-38" style="zoom:80%;" />



<h4 id="肘部图（估计k）"><a href="#肘部图（估计k）" class="headerlink" title="肘部图（估计k）"></a>肘部图（估计k）</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751815.png" alt="Snipaste_2023-01-29_20-51-43" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751845.png" alt="Snipaste_2023-01-29_20-53-05" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751874.png" alt="Snipaste_2023-01-29_20-57-47" style="zoom:80%;" />





<h3 id="DBSCAN算法（基于密度）"><a href="#DBSCAN算法（基于密度）" class="headerlink" title="DBSCAN算法（基于密度）"></a>DBSCAN算法（基于密度）</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751949.png" alt="Snipaste_2023-01-29_21-04-04" style="zoom:80%;" />

<h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751084.png" alt="Snipaste_2023-01-29_21-05-52" style="zoom:80%;" />



<h4 id="算法优劣-1"><a href="#算法优劣-1" class="headerlink" title="算法优劣"></a>算法优劣</h4><p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751153.png" alt="Snipaste_2023-01-29_21-10-32"></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[IDX, isnoise]</span>=<span class="title">DBSCAN</span><span class="params">(X,epsilon,MinPts)</span></span></span><br><span class="line"></span><br><span class="line">    C=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    n=<span class="built_in">size</span>(X,<span class="number">1</span>);</span><br><span class="line">    IDX=<span class="built_in">zeros</span>(n,<span class="number">1</span>);  <span class="comment">% 初始化全部为0，即全部为噪音点</span></span><br><span class="line">    </span><br><span class="line">    D=pdist2(X,X);</span><br><span class="line">    </span><br><span class="line">    visited=<span class="built_in">false</span>(n,<span class="number">1</span>);</span><br><span class="line">    isnoise=<span class="built_in">false</span>(n,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> ~visited(<span class="built_in">i</span>)</span><br><span class="line">            visited(<span class="built_in">i</span>)=<span class="built_in">true</span>;</span><br><span class="line">            </span><br><span class="line">            Neighbors=RegionQuery(<span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">numel</span>(Neighbors)&lt;MinPts</span><br><span class="line">                <span class="comment">% X(i,:) is NOISE</span></span><br><span class="line">                isnoise(<span class="built_in">i</span>)=<span class="built_in">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C=C+<span class="number">1</span>;</span><br><span class="line">                ExpandCluster(<span class="built_in">i</span>,Neighbors,C);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ExpandCluster</span><span class="params">(i,Neighbors,C)</span></span></span><br><span class="line">        IDX(<span class="built_in">i</span>)=C;</span><br><span class="line">        </span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">true</span></span><br><span class="line">            <span class="built_in">j</span> = Neighbors(k);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ~visited(<span class="built_in">j</span>)</span><br><span class="line">                visited(<span class="built_in">j</span>)=<span class="built_in">true</span>;</span><br><span class="line">                Neighbors2=RegionQuery(<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">numel</span>(Neighbors2)&gt;=MinPts</span><br><span class="line">                    Neighbors=[Neighbors Neighbors2];   <span class="comment">%#ok</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> IDX(<span class="built_in">j</span>)==<span class="number">0</span></span><br><span class="line">                IDX(<span class="built_in">j</span>)=C;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">numel</span>(Neighbors)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Neighbors</span>=<span class="title">RegionQuery</span><span class="params">(i)</span></span></span><br><span class="line">        Neighbors=<span class="built_in">find</span>(D(<span class="built_in">i</span>,:)&lt;=epsilon);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlotClusterinResult</span><span class="params">(X, IDX)</span></span></span><br><span class="line"></span><br><span class="line">    k=<span class="built_in">max</span>(IDX);</span><br><span class="line"></span><br><span class="line">    Colors=hsv(k);</span><br><span class="line"></span><br><span class="line">    Legends = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:k</span><br><span class="line">        Xi=X(IDX==<span class="built_in">i</span>,:);</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">i</span>~=<span class="number">0</span></span><br><span class="line">            Style = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            MarkerSize = <span class="number">8</span>;</span><br><span class="line">            Color = Colors(<span class="built_in">i</span>,:);</span><br><span class="line">            Legends&#123;<span class="keyword">end</span>+<span class="number">1</span>&#125; = [<span class="string">&#x27;Cluster #&#x27;</span> num2str(<span class="built_in">i</span>)];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Style = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            MarkerSize = <span class="number">6</span>;</span><br><span class="line">            Color = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> ~<span class="built_in">isempty</span>(Xi)</span><br><span class="line">                Legends&#123;<span class="keyword">end</span>+<span class="number">1</span>&#125; = <span class="string">&#x27;Noise&#x27;</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isempty</span>(Xi)</span><br><span class="line">            <span class="built_in">plot</span>(Xi(:,<span class="number">1</span>),Xi(:,<span class="number">2</span>),Style,<span class="string">&#x27;MarkerSize&#x27;</span>,MarkerSize,<span class="string">&#x27;Color&#x27;</span>,Color);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">hold</span> off;</span><br><span class="line">    axis equal;</span><br><span class="line">    grid on;</span><br><span class="line">    <span class="built_in">legend</span>(Legends);</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;NorthEastOutside&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Load Data</span></span><br><span class="line"></span><br><span class="line">load mydata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Run DBSCAN Clustering Algorithm</span></span><br><span class="line"></span><br><span class="line">epsilon=<span class="number">0.5</span>;</span><br><span class="line">MinPts=<span class="number">10</span>;</span><br><span class="line">IDX=DBSCAN(X,epsilon,MinPts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot Results</span></span><br><span class="line"><span class="comment">% 如果只要两个指标的话就可以画图啦</span></span><br><span class="line">PlotClusterinResult(X, IDX);</span><br><span class="line">title([<span class="string">&#x27;DBSCAN Clustering (\epsilon = &#x27;</span> num2str(epsilon) <span class="string">&#x27;, MinPts = &#x27;</span> num2str(MinPts) <span class="string">&#x27;)&#x27;</span>]);</span><br></pre></td></tr></table></figure>









<h2 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751215.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751231.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751338.png" alt="Snipaste_2023-01-31_22-23-15" style="zoom:80%;" />



<h3 id="时间序列分解"><a href="#时间序列分解" class="headerlink" title="时间序列分解"></a>时间序列分解</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751367.png" alt="Snipaste_2023-01-31_22-23-47" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751539.png" alt="Snipaste_2023-01-31_22-23-55" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751534.png" alt="Snipaste_2023-01-31_22-24-04" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751570.png" alt="Snipaste_2023-01-31_22-24-12" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751622.png" alt="Snipaste_2023-01-31_22-24-23" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751699.png" alt="Snipaste_2023-01-31_22-26-03" style="zoom:80%;" />



<h3 id="spss缺失值处理"><a href="#spss缺失值处理" class="headerlink" title="spss缺失值处理"></a>spss缺失值处理</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751758.png" alt="Snipaste_2023-01-31_22-27-58" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751879.png" alt="Snipaste_2023-01-31_22-28-11" style="zoom:80%;" />



<h3 id="spss数据处理（时间序列图）"><a href="#spss数据处理（时间序列图）" class="headerlink" title="spss数据处理（时间序列图）"></a>spss数据处理（时间序列图）</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751900.png" alt="Snipaste_2023-01-31_22-28-24" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751954.png" alt="Snipaste_2023-01-31_22-28-48" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751007.png" alt="Snipaste_2023-01-31_22-29-11" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751068.png" alt="Snipaste_2023-01-31_22-40-44" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751101.png" alt="Snipaste_2023-01-31_22-44-52" style="zoom:80%;" />



<h3 id="操作用途和步骤"><a href="#操作用途和步骤" class="headerlink" title="操作用途和步骤"></a>操作用途和步骤</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751248.png" alt="Snipaste_2023-01-31_22-45-06" style="zoom:80%;" />



<h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751305.png" alt="Snipaste_2023-01-31_22-46-27" style="zoom:80%;" />





<h4 id="指数平滑模型"><a href="#指数平滑模型" class="headerlink" title="指数平滑模型"></a>指数平滑模型</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751342.png" alt="Snipaste_2023-01-31_22-51-45" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751464.png" alt="Snipaste_2023-01-31_22-54-28" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751446.png" alt="Snipaste_2023-01-31_22-57-01" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751486.png" alt="Snipaste_2023-01-31_22-57-48" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751637.png" alt="Snipaste_2023-01-31_22-59-15" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751751.png" alt="Snipaste_2023-01-31_22-59-26" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751781.png" alt="Snipaste_2023-01-31_23-00-52" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751788.png" alt="Snipaste_2023-01-31_23-01-33" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751837.png" alt="Snipaste_2023-01-31_23-01-46" style="zoom:80%;" />



<h4 id="一元时间序列分析模型"><a href="#一元时间序列分析模型" class="headerlink" title="一元时间序列分析模型"></a>一元时间序列分析模型</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751905.png" style="zoom:80%;" />



<h3 id="建模思路和实例"><a href="#建模思路和实例" class="headerlink" title="建模思路和实例"></a>建模思路和实例</h3><h4 id="季节性数据"><a href="#季节性数据" class="headerlink" title="季节性数据"></a>季节性数据</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751072.png" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751135.png" alt="Snipaste_2023-02-01_00-25-56" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751142.png" alt="Snipaste_2023-02-01_00-26-07" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751218.png" alt="Snipaste_2023-02-01_00-26-25" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751236.png" alt="Snipaste_2023-02-01_00-27-37" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751273.png" alt="Snipaste_2023-02-01_00-27-51" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751489.png" alt="Snipaste_2023-02-01_00-29-38" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751505.png" alt="Snipaste_2023-02-01_00-30-22" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751530.png" alt="Snipaste_2023-02-01_00-31-18" style="zoom:80%;" />



<h4 id="人口预测"><a href="#人口预测" class="headerlink" title="人口预测"></a>人口预测</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751615.png" alt="Snipaste_2023-02-01_00-38-01" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751659.png" alt="Snipaste_2023-02-01_00-38-11" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751680.png" alt="Snipaste_2023-02-01_00-38-20" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751870.png" alt="Snipaste_2023-02-01_00-38-30" style="zoom:80%;" />



<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751072.png"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751135.png" alt="Snipaste_2023-02-01_00-25-56"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751142.png" alt="Snipaste_2023-02-01_00-26-07"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751218.png" alt="Snipaste_2023-02-01_00-26-25"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751236.png" alt="Snipaste_2023-02-01_00-27-37"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751273.png" alt="Snipaste_2023-02-01_00-27-51"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751489.png" alt="Snipaste_2023-02-01_00-29-38"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751505.png" alt="Snipaste_2023-02-01_00-30-22"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751530.png" alt="Snipaste_2023-02-01_00-31-18"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751615.png" alt="Snipaste_2023-02-01_00-38-01"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751659.png" alt="Snipaste_2023-02-01_00-38-11"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751680.png" alt="Snipaste_2023-02-01_00-38-20"></p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751870.png" alt="Snipaste_2023-02-01_00-38-30"></p>
<h4 id="股票上证指数预测"><a href="#股票上证指数预测" class="headerlink" title="股票上证指数预测"></a>股票上证指数预测</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751913.png" alt="Snipaste_2023-02-01_23-14-44" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751903.png" alt="Snipaste_2023-02-01_23-15-05" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751964.png" alt="Snipaste_2023-02-01_23-15-33" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751011.png" alt="Snipaste_2023-02-01_23-15-44" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751045.png" alt="Snipaste_2023-02-01_23-15-56" style="zoom:80%;" />



<h4 id="GDP增速预测"><a href="#GDP增速预测" class="headerlink" title="GDP增速预测"></a>GDP增速预测</h4><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751283.png" alt="Snipaste_2023-02-01_23-16-13" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751302.png" alt="Snipaste_2023-02-01_23-16-21" style="zoom:80%;" />

<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751326.png" alt="Snipaste_2023-02-01_23-16-32" style="zoom:80%;" />



<h1 id="优化类方法"><a href="#优化类方法" class="headerlink" title="优化类方法"></a>优化类方法</h1><h2 id="蒙特卡洛模拟"><a href="#蒙特卡洛模拟" class="headerlink" title="蒙特卡洛模拟"></a>蒙特卡洛模拟</h2><h3 id="引例：浦丰投针实验"><a href="#引例：浦丰投针实验" class="headerlink" title="引例：浦丰投针实验"></a>引例：浦丰投针实验</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751409.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751466.png" style="zoom:80%;" />



<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于布丰投针实验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">%  rand(m,n)函数产生由在[0,1]之间均匀分布的随机数组成的m行n列的矩阵（或称为数组）。</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">%     0.8300    0.1048    0.2396    0.4398</span></span><br><span class="line"><span class="comment">%     0.5663    0.1196    0.8559    0.5817</span></span><br><span class="line"><span class="comment">%     0.9281    0.2574    0.3013    0.9355</span></span><br><span class="line"><span class="comment">%     0.3910    0.3173    0.2108    0.1676</span></span><br><span class="line"><span class="comment">%     0.3645    0.4372    0.8819    0.9232</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">3</span>) <span class="comment">% 若只给一个输入，则会生成一个方阵</span></span><br><span class="line"><span class="comment">%     0.1709    0.4951    0.0541</span></span><br><span class="line"><span class="comment">%     0.9374    0.8500    0.6155</span></span><br><span class="line"><span class="comment">%     0.2400    0.3156    0.5741</span></span><br><span class="line"><span class="comment">% a + rand(m,n)*(b-a) 可以输出在[a,b]之间均匀分布的随机数组成的m行n列的矩阵。</span></span><br><span class="line"><span class="number">-2</span> + <span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">2</span>) * (<span class="number">2</span> - (<span class="number">-2</span>))  <span class="comment">% 输出在[-2,2]之间均匀分布的随机数组成的3行2列的矩阵。</span></span><br><span class="line"><span class="comment">%    -1.2743    0.6013</span></span><br><span class="line"><span class="comment">%    -1.3084    0.0766</span></span><br><span class="line"><span class="comment">%     1.5075    0.7563</span></span><br><span class="line"><span class="comment">% a + rand(m,n)*(b-a)等价于unifrnd(a,b,m,n)</span></span><br><span class="line">unifrnd(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">l =  <span class="number">0.520</span>;     <span class="comment">% 针的长度（任意给的）</span></span><br><span class="line">a = <span class="number">1.314</span>;    <span class="comment">% 平行线的宽度(大于针的长度l即可)</span></span><br><span class="line">n = <span class="number">10000</span>;    <span class="comment">% 做n次投针试验，n越大求出来的pi越准确</span></span><br><span class="line">m = <span class="number">0</span>;    <span class="comment">% 记录针与平行线相交的次数</span></span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span> ;   <span class="comment">% 在[0, a/2]内服从均匀分布随机产生n个数， x中每一个元素表示针的中点和最近的一条平行线的距离</span></span><br><span class="line">phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;    <span class="comment">% 在[0, pi]内服从均匀分布随机产生n个数，phi中的每一个元素表示针和最近的一条平行线的夹角</span></span><br><span class="line"><span class="comment">% axis([0,pi, 0,a/2]);   box on;  % 画一个坐标轴的框架，x轴位于0-pi，y轴位于0-a/2， 并打开图形的边框</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n  <span class="comment">% 开始循环，依次看每根针是否和直线相交</span></span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi (<span class="built_in">i</span>))     <span class="comment">% 如果针和平行线相交</span></span><br><span class="line">        m = m + <span class="number">1</span>;    <span class="comment">% 那么m就要加1</span></span><br><span class="line">        <span class="built_in">plot</span>(phi(<span class="built_in">i</span>), x(<span class="built_in">i</span>), <span class="string">&#x27;r.&#x27;</span>)   <span class="comment">% 模仿书上的那个图，横坐标为phi，纵坐标为x , 用红色的小点进行标记</span></span><br><span class="line">        <span class="built_in">hold</span> on  <span class="comment">% 在原来的图形上继续绘制</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p = m / n;    <span class="comment">% 针和平行线相交出现的频率</span></span><br><span class="line">mypi = (<span class="number">2</span> * l) / (a * p);  <span class="comment">% 我们根据公式计算得到的pi</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到pi为：&#x27;</span>, num2str(mypi)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3） 由于一次模拟的结果具有偶然性，因此我们可以重复100次后再来求一个平均的pi</span></span><br><span class="line">result = <span class="built_in">zeros</span>(<span class="number">100</span>,<span class="number">1</span>);  <span class="comment">% 初始化保存100次结果的矩阵</span></span><br><span class="line">l =  <span class="number">0.520</span>;     a = <span class="number">1.314</span>;</span><br><span class="line">n = <span class="number">1000000</span>;    </span><br><span class="line"><span class="keyword">for</span> num = <span class="number">1</span>:<span class="number">100</span></span><br><span class="line">    m = <span class="number">0</span>;  </span><br><span class="line">    x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span> ;</span><br><span class="line">    phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi (<span class="built_in">i</span>))</span><br><span class="line">            m = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    p = m / n;</span><br><span class="line">    mypi = (<span class="number">2</span> * l) / (a * p);</span><br><span class="line">    result(num) = mypi;  <span class="comment">% 把求出来的myphi保存到结果矩阵中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mymeanpi = <span class="built_in">mean</span>(result);  <span class="comment">% 计算result矩阵中保存的100次结果的均值</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到pi为：&#x27;</span>, num2str(mymeanpi)])</span><br></pre></td></tr></table></figure>



<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>蒙特卡罗⽅法⼜称统计模拟法，是⼀种<strong>随机模拟⽅法</strong></p>
<p>蒙特卡洛模拟是一种算法思想，不是直接的算法</p>
<h3 id="三门问题"><a href="#三门问题" class="headerlink" title="三门问题"></a>三门问题</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751494.png" style="zoom:80%;" />

<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于模拟三门问题</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% randi([a,b],m,n)函数可在指定区间[a,b]内随机取出大小为m*n的整数矩阵</span></span><br><span class="line">randi([<span class="number">1</span>,<span class="number">5</span>],<span class="number">5</span>,<span class="number">8</span>) <span class="comment">%在区间[1,5]内随机取出大小为5*8的整数矩阵</span></span><br><span class="line"><span class="comment">%      2     5     4     5     3     1     4     2</span></span><br><span class="line"><span class="comment">%      3     3     1     5     4     2     1     2</span></span><br><span class="line"><span class="comment">%      4     1     3     3     2     2     5     1</span></span><br><span class="line"><span class="comment">%      5     3     3     4     4     5     4     4</span></span><br><span class="line"><span class="comment">%      4     2     3     4     2     4     2     4</span></span><br><span class="line">randi([<span class="number">1</span>,<span class="number">5</span>])   <span class="comment">%在区间[1,5]内随机取出1个整数</span></span><br><span class="line"><span class="comment">%     3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 字符串的连接方式：(1)[&#x27;字符串1&#x27;,&#x27;字符串2&#x27;] (2)strcat(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;) （第一期视频第一讲）</span></span><br><span class="line">[<span class="string">&#x27;数学建模&#x27;</span>,<span class="string">&#x27;学习交流&#x27;</span>]</span><br><span class="line">strcat(<span class="string">&#x27;数学建模&#x27;</span>,<span class="string">&#x27;学习交流&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% num2str函数：将数值转换为字符串 （第一期视频第一讲）</span></span><br><span class="line">mystr = num2str(<span class="number">1224</span>)  <span class="comment">% 注意观察工作区的mystr这个变量的值</span></span><br><span class="line"><span class="built_in">disp</span>([num2str(<span class="number">1224</span>),<span class="string">&#x27;祝大家平安夜平平安安&#x27;</span>])  <span class="comment">% disp函数是输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分（在成功的条件下的概率）</span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% n代表蒙特卡罗模拟重复次数</span></span><br><span class="line">a = <span class="number">0</span>;  <span class="comment">% a表示不改变主意时能赢得汽车的次数</span></span><br><span class="line">b = <span class="number">0</span>;  <span class="comment">% b表示改变主意时能赢得汽车的次数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>= <span class="number">1</span> : n  <span class="comment">% 开始模拟n次</span></span><br><span class="line">    x = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    <span class="comment">% 下面分为两种情况讨论：x=y和x~=y</span></span><br><span class="line">    <span class="keyword">if</span> x == y   <span class="comment">% 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        a = a + <span class="number">1</span>;     b = b + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">% x ~= y ，如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">        a = a + <span class="number">0</span>;     b = b +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为：&#x27;</span>, num2str(a/n)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的改变主意时的获奖概率为：&#x27;</span>, num2str(b/n)]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3）考虑失败情况的代码(无条件概率)</span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% n代表蒙特卡罗模拟重复次数</span></span><br><span class="line">a = <span class="number">0</span>;  <span class="comment">% a表示不改变主意时能赢得汽车的次数</span></span><br><span class="line">b = <span class="number">0</span>;  <span class="comment">% b表示改变主意时能赢得汽车的次数</span></span><br><span class="line">c = <span class="number">0</span>;  <span class="comment">% c表示没有获奖的次数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>= <span class="number">1</span> : n  <span class="comment">% 开始模拟n次</span></span><br><span class="line">    x = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    change = randi([<span class="number">0</span>, <span class="number">1</span>]); <span class="comment">% change =0  不改变主意，change = 1 改变主意</span></span><br><span class="line">    <span class="comment">% 下面分为两种情况讨论：x=y和x~=y</span></span><br><span class="line">    <span class="keyword">if</span> x == y   <span class="comment">% 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        <span class="keyword">if</span> change == <span class="number">0</span>  <span class="comment">% 不改变主意</span></span><br><span class="line">        	a = a + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">% 改变了主意</span></span><br><span class="line">            c= c+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">% x ~= y ，如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">         <span class="keyword">if</span> change == <span class="number">0</span>  <span class="comment">% 不改变主意</span></span><br><span class="line">        	c = c + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">% 改变了主意</span></span><br><span class="line">            b= b + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为：&#x27;</span>, num2str(a/n)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的改变主意时的获奖概率为：&#x27;</span>, num2str(b/n)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的没有获奖的概率为：&#x27;</span>, num2str(c/n)]);</span><br></pre></td></tr></table></figure>



<h3 id="排队问题"><a href="#排队问题" class="headerlink" title="排队问题"></a>排队问题</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751684.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751051.png" style="zoom:80%;" />



<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗模拟排队问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% normrnd(MU,SIGMA):生成一个服从正态分布(MU参数代表均值,SIGMA参数代表标准差,方差开根号是标准差)的随机数</span></span><br><span class="line">normrnd(<span class="number">10</span>,<span class="number">2</span>)  <span class="comment">% 均值为10 标准差为2（方差为4）的正态分布随机数</span></span><br><span class="line"><span class="comment">% exprnd(M)表示生成一个均值为M的指数分布随机数(其对应的参数为1/M)</span></span><br><span class="line">exprnd(<span class="number">5</span>)  <span class="comment">% 均值为5的指数分布随机数（对应的参数为0.2）</span></span><br><span class="line"><span class="comment">% mean函数是用来求解均值的函数（第一期视频第五讲）</span></span><br><span class="line"><span class="built_in">mean</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">% tic函数和toc函数可以用来返回代码运行的时间，例如我们要计算一段代码的运行时间，就可以在这段代码前加上tic，在这段代码后加上toc (我的微信公众号&quot;数学建模学习交流&quot;中有一篇推送《为什么要对代码初始化》中使用过这对函数)</span></span><br><span class="line">tic</span><br><span class="line">a = <span class="number">2</span>^<span class="number">100</span></span><br><span class="line">toc</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）模型中出现的变量的说明</span></span><br><span class="line"><span class="comment">% x(i)表示第i-1个客户和第i个客户到达的间隔时间，服从参数为0.1的指数分布</span></span><br><span class="line"><span class="comment">% y(i)表示第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布 (若小于1则按1计算)</span></span><br><span class="line"><span class="comment">% c(i)表示第i个客户的到达时间，那么c(i) = c(i-1) + x(i)，初始值c0=0</span></span><br><span class="line"><span class="comment">% b(i)表示第i个客户开始服务的时间</span></span><br><span class="line"><span class="comment">% e(i)表示第i个客户结束服务的时间，初始值e0=0</span></span><br><span class="line"><span class="comment">% 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间</span></span><br><span class="line"><span class="comment">% 即：e(i) = b(i) + y(i）</span></span><br><span class="line"><span class="comment">% 第i个客户开始服务的时间取决于该客户的到达时间和上一个客户结束服务的时间</span></span><br><span class="line"><span class="comment">% 即：b(i) = max(c(i),e(i-1))，初始值b1=c1;</span></span><br><span class="line"><span class="comment">% 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间</span></span><br><span class="line"><span class="comment">% 即：wait(i) = b(i) - c(i)</span></span><br><span class="line"><span class="comment">% w表示所有客户等待时间的总和</span></span><br><span class="line"><span class="comment">% 假设一天内银行最终服务了n个顾客，那么客户的平均等待时间t = w/n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3）问题1的代码</span></span><br><span class="line">clear</span><br><span class="line">tic  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;  <span class="comment">% i表示第i个客户，最开始取i=1</span></span><br><span class="line">w = <span class="number">0</span>;  <span class="comment">% w用来表示所有客户等待的总时间，初始化为0</span></span><br><span class="line">e0 = <span class="number">0</span>;  c0 = <span class="number">0</span>;   <span class="comment">% 初始化e0和c0为0</span></span><br><span class="line">x(<span class="number">1</span>) = exprnd(<span class="number">10</span>);  <span class="comment">% 第0个客户(假想的)和第1个客户到达的时间间隔</span></span><br><span class="line">c(<span class="number">1</span>) = c0 + x(<span class="number">1</span>);  <span class="comment">% 第1个客户到达的时间</span></span><br><span class="line">b(<span class="number">1</span>) = c(<span class="number">1</span>); <span class="comment">% 第1个客户的开始服务的时间</span></span><br><span class="line"><span class="keyword">while</span> b(<span class="built_in">i</span>) &lt;= <span class="number">480</span>  <span class="comment">% 开始设置循环，只要第i个顾客开始服务的时间(时刻)小于480，就可以对其服务（银行每天工作8小时，折换为分钟就是480分钟）</span></span><br><span class="line">    y(<span class="built_in">i</span>) = normrnd(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">% 第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布</span></span><br><span class="line">    <span class="keyword">if</span> y(<span class="built_in">i</span>) &lt; <span class="number">1</span>  <span class="comment">% 根据题目的意思：若服务持续时间不足一分钟，则按照一分钟计算</span></span><br><span class="line">        y(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    e(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) + y(<span class="built_in">i</span>); <span class="comment">% 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间</span></span><br><span class="line">    wait(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) - c(<span class="built_in">i</span>); <span class="comment">% 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间</span></span><br><span class="line">    w = w + wait(<span class="built_in">i</span>); <span class="comment">% 更新所有客户等待的总时间</span></span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="comment">% 增加一名新的客户</span></span><br><span class="line">    x(<span class="built_in">i</span>) = exprnd(<span class="number">10</span>); <span class="comment">% 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">    c(<span class="built_in">i</span>) = c(<span class="built_in">i</span><span class="number">-1</span>) + x(<span class="built_in">i</span>); <span class="comment">% 这位新客户到达银行的时间 = 上一个客户到达银行的时间 + 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">    b(<span class="built_in">i</span>) = <span class="built_in">max</span>(c(<span class="built_in">i</span>),e(<span class="built_in">i</span><span class="number">-1</span>)); <span class="comment">% 这个新客户开始服务的时间取决于其到达时间和上一个客户结束服务的时间</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">n = <span class="built_in">i</span><span class="number">-1</span>; <span class="comment">% n表示银行一天8小时一共服务的客户人数</span></span><br><span class="line">t = w/n; <span class="comment">% 客户的平均等待时间</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;银行一天8小时一共服务的客户人数为: &#x27;</span>,num2str(n)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;客户的平均等待时间为: &#x27;</span>,num2str(t)])</span><br><span class="line">toc  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （4）问题2的代码</span></span><br><span class="line">clear</span><br><span class="line">tic  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">day = <span class="number">100</span>;  <span class="comment">% 假设模拟100天</span></span><br><span class="line">n = <span class="built_in">zeros</span>(day,<span class="number">1</span>); <span class="comment">% 初始化用来保存每日接待客户数结果的矩阵</span></span><br><span class="line">t = <span class="built_in">zeros</span>(day,<span class="number">1</span>); <span class="comment">% 初始化用来保存每日客户平均等待时长的矩阵</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:day</span><br><span class="line">    <span class="built_in">i</span> = <span class="number">1</span>;  <span class="comment">% i表示第i个客户，最开始取i=1</span></span><br><span class="line">    w = <span class="number">0</span>;  <span class="comment">% w用来表示所有客户等待的总时间，初始化为0</span></span><br><span class="line">    e0 = <span class="number">0</span>;  c0 = <span class="number">0</span>;   <span class="comment">% 初始化e0和c0为0</span></span><br><span class="line">    x(<span class="number">1</span>) = exprnd(<span class="number">10</span>);  <span class="comment">% 第0个客户(假想的)和第1个客户到达的时间间隔</span></span><br><span class="line">    c(<span class="number">1</span>) = c0 + x(<span class="number">1</span>);  <span class="comment">% 第1个客户到达的时间</span></span><br><span class="line">    b(<span class="number">1</span>) = c(<span class="number">1</span>); <span class="comment">% 第1个客户的开始服务的时间</span></span><br><span class="line">    <span class="keyword">while</span> b(<span class="built_in">i</span>) &lt;= <span class="number">480</span>  <span class="comment">% 开始设置循环，只要第i个顾客开始服务的时间(时刻)小于480，就可以对其服务（银行每天工作8小时，折换为分钟就是480分钟）</span></span><br><span class="line">        y(<span class="built_in">i</span>) = normrnd(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">% 第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布</span></span><br><span class="line">        <span class="keyword">if</span> y(<span class="built_in">i</span>) &lt; <span class="number">1</span>  <span class="comment">% 根据题目的意思：若服务持续时间不足一分钟，则按照一分钟计算</span></span><br><span class="line">            y(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        e(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) + y(<span class="built_in">i</span>); <span class="comment">% 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间</span></span><br><span class="line">        wait(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) - c(<span class="built_in">i</span>); <span class="comment">% 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间</span></span><br><span class="line">        w = w + wait(<span class="built_in">i</span>); <span class="comment">% 更新所有客户等待的总时间</span></span><br><span class="line">        <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="comment">% 增加一名新的客户</span></span><br><span class="line">        x(<span class="built_in">i</span>) = exprnd(<span class="number">10</span>); <span class="comment">% 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">        c(<span class="built_in">i</span>) = c(<span class="built_in">i</span><span class="number">-1</span>) + x(<span class="built_in">i</span>); <span class="comment">% 这位新客户到达银行的时间 = 上一个客户到达银行的时间 + 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">        b(<span class="built_in">i</span>) = <span class="built_in">max</span>(c(<span class="built_in">i</span>),e(<span class="built_in">i</span><span class="number">-1</span>)); <span class="comment">% 这个新客户开始服务的时间取决于其到达时间和上一个客户结束服务的时间</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n(k) = <span class="built_in">i</span><span class="number">-1</span>; <span class="comment">% n(k)表示银行第k天服务的客户人数</span></span><br><span class="line">    t(k) = w/n(k); <span class="comment">% t(k)表示该银行第k天客户的平均等待时间</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([num2str(day),<span class="string">&#x27;个工作日中，银行每日平均服务的客户人数为: &#x27;</span>,num2str(<span class="built_in">mean</span>(n))])</span><br><span class="line"><span class="built_in">disp</span>([num2str(day),<span class="string">&#x27;个工作日中，银行每日客户的平均等待时间为: &#x27;</span>,num2str(<span class="built_in">mean</span>(t))])</span><br><span class="line">toc  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure>



<h3 id="非线性约束问题"><a href="#非线性约束问题" class="headerlink" title="非线性约束问题"></a>非线性约束问题</h3><ol>
<li>写出各个自变量的大致范围</li>
<li>用随机数模拟</li>
<li>找出符合条件的最大值</li>
</ol>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751863.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751888.png" style="zoom:80%;" />



<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗求解有约束的非线性规划问题</span></span><br><span class="line"><span class="comment">% max f(x) = x1*x2*x3</span></span><br><span class="line"><span class="comment">% s.t.</span></span><br><span class="line"><span class="comment">% (1) -x1+2*x2+2*x3&gt;=0</span></span><br><span class="line"><span class="comment">% (2) x1+2*x2+2*x3&lt;=72</span></span><br><span class="line"><span class="comment">% (3) x2&lt;=20 &amp; x2&gt;=10</span></span><br><span class="line"><span class="comment">% (4) x1-x2 == 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">%  (1) format long g  可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="number">5</span>/<span class="number">7</span></span><br><span class="line"><span class="number">5895</span>*<span class="number">514100</span></span><br><span class="line">format long g</span><br><span class="line"><span class="number">5</span>/<span class="number">7</span></span><br><span class="line"><span class="number">5895</span>*<span class="number">514100</span></span><br><span class="line"><span class="comment">%  (2)unifrnd(a,b,m,n)可以输出在[a,b]之间均匀分布的随机数组成的m行n列的矩阵。(等价于 a + rand(m,n)*(b-a))</span></span><br><span class="line">unifrnd(<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">%           4.07361843196589          3.16179623112705          4.78753417717149</span></span><br><span class="line"><span class="comment">%            4.5289596853781         0.487702024997048          4.82444267599638</span></span><br><span class="line"><span class="comment">%           0.63493408146753          1.39249109433524         0.788065408387741</span></span><br><span class="line"><span class="comment">%            4.5668792806951          2.73440759602492          4.85296390880308</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">20</span>,<span class="number">30</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[20,30]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=x1 - <span class="number">10</span>;</span><br><span class="line">x3=unifrnd(<span class="number">-10</span>,<span class="number">16</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-10,16]之间均匀分布的随机数组成的n行1列的向量构成x3</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&gt;=<span class="number">0</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&lt;=<span class="number">72</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = x(<span class="number">1</span>)*x(<span class="number">2</span>)*x(<span class="number">3</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 x3保存到一个变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;蒙特卡罗模拟得到的最大值为&#x27;</span>,num2str(fmax)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最大值处x1 x2 x3的取值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3）缩小范围重新模拟得到更加精确的取值</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">22</span>,<span class="number">23</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[22,23]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=x1 - <span class="number">10</span>;</span><br><span class="line">x3=unifrnd(<span class="number">11</span>,<span class="number">13</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[11,13]之间均匀分布的随机数组成的n行1列的向量构成x3</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&gt;=<span class="number">0</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&lt;=<span class="number">72</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = x(<span class="number">1</span>)*x(<span class="number">2</span>)*x(<span class="number">3</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 x3保存到一个变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;蒙特卡罗模拟得到的最大值为&#x27;</span>,num2str(fmax)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最大值处x1 x2 x3的取值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure>



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751114.png" style="zoom:80%;" />

<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗求解非线性规划问题</span></span><br><span class="line"><span class="comment">% min f(x) =2*(x1^2)+x2^2-x1*x2-8*x1-3*x2</span></span><br><span class="line"><span class="comment">% s.t.</span></span><br><span class="line"><span class="comment">% (1) 3*x1+x2&gt;9</span></span><br><span class="line"><span class="comment">% (2) x1+2*x2&lt;16</span></span><br><span class="line"><span class="comment">% (3) x1&gt;0 &amp; x2&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）初次寻找最小值的代码</span></span><br><span class="line">clc,clear;</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">0</span>,<span class="number">16</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[0,16]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">0</span>,<span class="number">8</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[0,8]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span>*x(<span class="number">1</span>)+x(<span class="number">2</span>)&gt;<span class="number">9</span>)&amp;&amp;(x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)&lt;<span class="number">16</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = <span class="number">2</span>*(x(<span class="number">1</span>)^<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>-x(<span class="number">1</span>)*x(<span class="number">2</span>)<span class="number">-8</span>*x(<span class="number">1</span>)<span class="number">-3</span>*x(<span class="number">2</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 保存到相应的变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;蒙特卡罗模拟得到的最小值为&#x27;</span>,num2str(fmin)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最小值处x1 x2的取值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）缩小范围重新模拟得到更加精确的取值</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">2</span>,<span class="number">3</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[2,3]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">2</span>,<span class="number">3</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[2,3]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span>*x(<span class="number">1</span>)+x(<span class="number">2</span>)&gt;<span class="number">9</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)&lt;<span class="number">16</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = <span class="number">2</span>*(x(<span class="number">1</span>)^<span class="number">2</span>)+x(<span class="number">2</span>)^<span class="number">2</span>-x(<span class="number">1</span>)*x(<span class="number">2</span>)<span class="number">-8</span>*x(<span class="number">1</span>)<span class="number">-3</span>*x(<span class="number">2</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 保存到相应的变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;蒙特卡罗模拟得到的最小值为&#x27;</span>,num2str(fmin)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最小值处x1 x2的取值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure>



<h3 id="0-1规划问题"><a href="#0-1规划问题" class="headerlink" title="0-1规划问题"></a>0-1规划问题</h3><ul>
<li>类似暴力搜索</li>
<li>当穷举次数远远大于模拟次数的时候，结果不正确</li>
<li>但是它比穷举法要稳定的多</li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751142.png" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751594.png" style="zoom:80%;" />



<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 书店买书问题的蒙特卡罗的模拟</span></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% (1)unique函数: 剔除一个矩阵或者向量的重复值，并将结果按照从小到大的顺序排列  </span></span><br><span class="line"><span class="comment">% adj.	唯一的; 独一无二的   [ju&#x27;ni:k]</span></span><br><span class="line">unique([<span class="number">1</span> <span class="number">2</span> <span class="number">5</span>; <span class="number">6</span> <span class="number">8</span> <span class="number">9</span>;<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>])   </span><br><span class="line">unique([<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">% (2)randi([a,b],m,n)函数可在指定区间[a,b]内随机取出大小为m*n的整数矩阵</span></span><br><span class="line">randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码求解</span></span><br><span class="line">min_money = +Inf;  <span class="comment">% 初始化最小的花费为无穷大，后续只要找到比它小的就更新</span></span><br><span class="line">min_result = randi([<span class="number">1</span>, <span class="number">6</span>],<span class="number">1</span>,<span class="number">5</span>);  <span class="comment">% 初始化五本书都在哪一家书店购买，后续我们不断对其更新</span></span><br><span class="line"><span class="comment">%若min_result = [5 3 6 2 3]，则解释为：第1本书在第5家店买，第2本书在第3家店买，第3本书在第6家店买，第4本书在第2家店买，第5本书在第3家店买  </span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% 蒙特卡罗模拟的次数</span></span><br><span class="line">M = [<span class="number">18</span>	 <span class="number">39</span>	<span class="number">29</span>	<span class="number">48</span>	<span class="number">59</span></span><br><span class="line">        <span class="number">24</span>	<span class="number">45</span>	<span class="number">23</span>	<span class="number">54</span>	<span class="number">44</span></span><br><span class="line">        <span class="number">22</span>	<span class="number">45</span>	<span class="number">23</span>	<span class="number">53</span>	<span class="number">53</span></span><br><span class="line">        <span class="number">28</span>	<span class="number">47</span>	<span class="number">17</span>	<span class="number">57</span>	<span class="number">47</span></span><br><span class="line">        <span class="number">24</span>	<span class="number">42</span>	<span class="number">24</span>	<span class="number">47</span>	<span class="number">59</span></span><br><span class="line">        <span class="number">27</span>	<span class="number">48</span>	<span class="number">20</span>	<span class="number">55</span>	<span class="number">53</span>];  <span class="comment">% m_ij  第j本书在第i家店的售价</span></span><br><span class="line">freight = [<span class="number">10</span> <span class="number">15</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">15</span>];  <span class="comment">% 第i家店的运费</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:n  <span class="comment">% 开始循环</span></span><br><span class="line">    result = randi([<span class="number">1</span>, <span class="number">6</span>],<span class="number">1</span>,<span class="number">5</span>); <span class="comment">% 在1-6这些整数中随机抽取一个1*5的向量，表示这五本书分别在哪家书店购买</span></span><br><span class="line">    index = unique(result);  <span class="comment">% 在哪些商店购买了商品，因为我们等下要计算运费</span></span><br><span class="line">    money = sum(freight(index)); <span class="comment">% 计算买书花费的运费</span></span><br><span class="line">    <span class="comment">% 计算总花费：刚刚计算出来的运费 + 五本书的售价</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">5</span>   </span><br><span class="line">        money = money + M(result(<span class="built_in">i</span>),<span class="built_in">i</span>);  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> money &lt; min_money  <span class="comment">% 判断刚刚随机生成的这组数据的花费是否小于最小花费，如果小于的话</span></span><br><span class="line">        min_money = money;<span class="comment">% 我们更新最小的花费</span></span><br><span class="line">        min_result = result; <span class="comment">% 用这组数据更新最小花费的结果</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">min_money   <span class="comment">% 18+39+48+17+47+20</span></span><br><span class="line">min_result</span><br></pre></td></tr></table></figure>





<h3 id="导弹追踪问题"><a href="#导弹追踪问题" class="headerlink" title="导弹追踪问题"></a>导弹追踪问题</h3><ul>
<li>这类似一个差分模型</li>
<li>取时间间隔t趋近于0</li>
<li>当导弹与B船的距离小于某一值的（一般较小）时，认为它们已经相撞</li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751471.png" alt="Snipaste_2023-01-19_21-24-18" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751505.png" alt="Snipaste_2023-01-19_21-26-55" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751729.png" alt="Snipaste_2023-01-19_21-27-28" style="zoom:80%;" />



<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751970.png" style="zoom:80%;" />



<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于模拟导弹追击问题</span></span><br><span class="line"><span class="comment">% 注意，模拟导弹追击问题更像是一种仿真模拟的方法。这里本质上没有用到随机数，因此严格意义上不能称为蒙特卡罗。</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% mod(m,n)表示求m/n的余数</span></span><br><span class="line"><span class="built_in">mod</span>(<span class="number">8</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">mod</span>(<span class="number">1000</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置横纵坐标的范围并标上字符</span></span><br><span class="line">x = <span class="number">1</span>:<span class="number">0.01</span>:<span class="number">3</span>;</span><br><span class="line">y = x .^ <span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>(x,y)  <span class="comment">% 画出x和y的图形</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">10</span>])  <span class="comment">% 设置横坐标范围为[0, 3] 纵坐标范围为[0, 10]</span></span><br><span class="line">pause(<span class="number">3</span>)  <span class="comment">% 暂停3秒后再继续接下来的命令</span></span><br><span class="line">text(<span class="number">2</span>,<span class="number">4</span>,<span class="string">&#x27;清风&#x27;</span>)  <span class="comment">% 在坐标为(2,4)的点上标上字符串：清风</span></span><br><span class="line">close <span class="comment">% 关闭图形窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) 代码求解</span></span><br><span class="line"><span class="comment">% 1. 不画追击的示意图</span></span><br><span class="line">clear;clc</span><br><span class="line">v=<span class="number">200</span>; <span class="comment">% 任意给定B船的速度（后期我们可以再改的）</span></span><br><span class="line">dt=<span class="number">0.0000001</span>; <span class="comment">% 定义时间间隔</span></span><br><span class="line">x=[<span class="number">0</span>,<span class="number">20</span>]; <span class="comment">% 定义导弹和B船的横坐标分别为x(1)和x(2)</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义导弹和B船的纵坐标分别为y(1)和y(2)</span></span><br><span class="line">t=<span class="number">0</span>; <span class="comment">% 初始化导弹击落B船的时间</span></span><br><span class="line">d=<span class="number">0</span>; <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line">m=<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">% 将sqrt(2)/2定义为一个常量，使后面看起来很简洁</span></span><br><span class="line">dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>); <span class="comment">% 导弹与B船的距离</span></span><br><span class="line"><span class="keyword">while</span>(dd&gt;=<span class="number">0.001</span>)  <span class="comment">% 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合dt来取，否则可能导致错过交界处的情况）</span></span><br><span class="line">    t=t+dt; <span class="comment">% 更新导弹击落B船的时间</span></span><br><span class="line">    d=d+<span class="number">3</span>*v*dt; <span class="comment">% 更新导弹飞行的距离</span></span><br><span class="line">    x(<span class="number">2</span>)=<span class="number">20</span>+t*v*m;  y(<span class="number">2</span>)=t*v*m;   <span class="comment">% 计算新的B船的位置 （注：m=sqrt(2)/2）</span></span><br><span class="line">    dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>);  <span class="comment">% 更新导弹与B船的距离</span></span><br><span class="line">    tan_alpha=(y(<span class="number">2</span>)-y(<span class="number">1</span>))/(x(<span class="number">2</span>)-x(<span class="number">1</span>));   <span class="comment">% 计算斜率，即tan(α)</span></span><br><span class="line">    cos_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>/(<span class="number">1</span>+tan_alpha^<span class="number">2</span>));   <span class="comment">% sec(α)^2 = (1+tan(α)^2)</span></span><br><span class="line">    sin_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>-cos_alpha^<span class="number">2</span>);  <span class="comment">% sin(α)^2 +cos(α)^2 = 1</span></span><br><span class="line">    x(<span class="number">1</span>)=x(<span class="number">1</span>)+<span class="number">3</span>*v*dt*cos_alpha;   y(<span class="number">1</span>)=y(<span class="number">1</span>)+<span class="number">3</span>*v*dt*sin_alpha; <span class="comment">% 计算新的导弹的位置</span></span><br><span class="line">    <span class="keyword">if</span> d&gt;<span class="number">50</span>  <span class="comment">% 导弹的有效射程为50个单位</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;导弹没有击中B船&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">% 退出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&lt;=<span class="number">50</span> &amp; dd&lt;<span class="number">0.001</span>   <span class="comment">% 导弹飞行的距离小于50个单位且导弹和B船的距离小于0.001（表示击中）</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行&#x27;</span>,num2str(d),<span class="string">&#x27;单位后击中B船&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行的时间为&#x27;</span>,num2str(t*<span class="number">60</span>),<span class="string">&#x27;分钟&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2. 画追击的示意图</span></span><br><span class="line">clear;clc</span><br><span class="line">v=<span class="number">200</span>; <span class="comment">% 任意给定B船的速度（后期我们可以再改的）</span></span><br><span class="line">dt=<span class="number">0.0000001</span>; <span class="comment">% 定义时间间隔</span></span><br><span class="line">x=[<span class="number">0</span>,<span class="number">20</span>]; <span class="comment">% 定义导弹和B船的横坐标分别为x(1)和x(2)</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义导弹和B船的纵坐标分别为y(1)和y(2)</span></span><br><span class="line">t=<span class="number">0</span>; <span class="comment">% 初始化导弹击落B船的时间</span></span><br><span class="line">d=<span class="number">0</span>; <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line">m=<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">% 将sqrt(2)/2定义为一个常量，使后面看起来很简洁</span></span><br><span class="line">dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>); <span class="comment">% 导弹与B船的距离</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">&#x27;.k&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">1</span>);  <span class="comment">% 画出导弹和B船所在的坐标，点的大小为1，颜色为黑色(k)，用小点表示</span></span><br><span class="line">    grid on;  <span class="comment">% 打开网格线</span></span><br><span class="line">    <span class="built_in">hold</span> on;  <span class="comment">% 不关闭图形，继续画图</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">30</span> <span class="number">0</span> <span class="number">10</span>])  <span class="comment">% 固定x轴的范围为0-30  固定y轴的范围为0-10</span></span><br><span class="line">k = <span class="number">0</span>;  <span class="comment">% 引入一个变量  为了控制画图的速度（因为Matlab中画图的速度超级慢）</span></span><br><span class="line"><span class="keyword">while</span>(dd&gt;=<span class="number">0.001</span>)  <span class="comment">% 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合dt来取，否则可能导致错过交界处的情况）</span></span><br><span class="line">    t=t+dt; <span class="comment">% 更新导弹击落B船的时间</span></span><br><span class="line">    d=d+<span class="number">3</span>*v*dt; <span class="comment">% 更新导弹飞行的距离</span></span><br><span class="line">    x(<span class="number">2</span>)=<span class="number">20</span>+t*v*m;  y(<span class="number">2</span>)=t*v*m;   <span class="comment">% 计算新的B船的位置 （注：m=sqrt(2)/2）</span></span><br><span class="line">    dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>);  <span class="comment">% 更新导弹与B船的距离</span></span><br><span class="line">    tan_alpha=(y(<span class="number">2</span>)-y(<span class="number">1</span>))/(x(<span class="number">2</span>)-x(<span class="number">1</span>));   <span class="comment">% 计算斜率，即tan(α)</span></span><br><span class="line">    cos_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>/(<span class="number">1</span>+tan_alpha^<span class="number">2</span>));   <span class="comment">% 利用公式：sec(α)^2 = (1+tan(α)^2)  计算出cos(α)</span></span><br><span class="line">    sin_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>-cos_alpha^<span class="number">2</span>);  <span class="comment">% 利用公式： sin(α)^2 +cos(α)^2 = 1  计算出sin(α)</span></span><br><span class="line">    x(<span class="number">1</span>)=x(<span class="number">1</span>)+<span class="number">3</span>*v*dt*cos_alpha;   y(<span class="number">1</span>)=y(<span class="number">1</span>)+<span class="number">3</span>*v*dt*sin_alpha;   <span class="comment">% 计算新的导弹的位置</span></span><br><span class="line">    k = k +<span class="number">1</span> ;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(k,<span class="number">500</span>) == <span class="number">0</span>   <span class="comment">% 每刷新500次时间就画出下一个导弹和B船所在的坐标  mod(m,n)表示求m/n的余数</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">            <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">&#x27;.k&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">hold</span> on; <span class="comment">% 不关闭图形，继续画图</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        pause(<span class="number">0.001</span>);  <span class="comment">% 暂停0.001s后再继续下面的操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&gt;<span class="number">50</span>  <span class="comment">% 导弹的有效射程为50个单位</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;导弹没有击中B船&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">% 退出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&lt;=<span class="number">50</span> &amp; dd&lt;<span class="number">0.001</span>   <span class="comment">% 导弹飞行的距离小于50个单位且导弹和B船的距离小于0.001（表示击中）</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行&#x27;</span>,num2str(d),<span class="string">&#x27;个单位后击中B船&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行的时间为&#x27;</span>,num2str(t*<span class="number">60</span>),<span class="string">&#x27;分钟&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><ul>
<li>当地点过多时（大于15）蒙特卡洛模拟将很难得到比较好的结果</li>
<li>在这种情况下，<strong>智能算法</strong>更加适用问题的求解</li>
</ul>
<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png" style="zoom:80%;" />



<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% TSP(旅行商问题)</span></span><br><span class="line"><span class="comment">% （1）预备知识</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">10</span>],<span class="string">&#x27;-o&#x27;</span>) <span class="comment">% 画出一条线段，x范围是[1, 2] ，y范围是[5,10]</span></span><br><span class="line">text(<span class="number">1.5</span>,<span class="number">7.5</span>,<span class="string">&#x27;清风&#x27;</span>) <span class="comment">% 在坐标(1.5,7.5)处标上文本：清风</span></span><br><span class="line">close</span><br><span class="line"></span><br><span class="line"><span class="comment">% randperm函数的用法</span></span><br><span class="line">randperm(<span class="number">5</span>)  <span class="comment">% 生成1-5组成的一个随机序列(类似于洗牌的操作)</span></span><br><span class="line"><span class="comment">%      3     5     1     2     4</span></span><br><span class="line"><span class="comment">%      1     4     5     3     2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码求解</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">% 只有10个城市的简单情况</span></span><br><span class="line">coord =[<span class="number">0.6683</span> <span class="number">0.6195</span> <span class="number">0.4</span>    <span class="number">0.2439</span> <span class="number">0.1707</span> <span class="number">0.2293</span> <span class="number">0.5171</span> <span class="number">0.8732</span> <span class="number">0.6878</span> <span class="number">0.8488</span> ;</span><br><span class="line">        <span class="number">0.2536</span> <span class="number">0.2634</span> <span class="number">0.4439</span> <span class="number">0.1463</span> <span class="number">0.2293</span> <span class="number">0.761</span>  <span class="number">0.9414</span> <span class="number">0.6536</span> <span class="number">0.5219</span> <span class="number">0.3609</span>]&#x27; ;  <span class="comment">% 城市坐标矩阵，n行2列</span></span><br><span class="line"><span class="comment">% 38个城市，TSP数据集网站(http://www.tsp.gatech.edu/world/djtour.html) 上公测的最优结果6656。</span></span><br><span class="line"> <span class="comment">% coord = [11003.611100,42102.500000;11108.611100,42373.888900;11133.333300,42885.833300;11155.833300,42712.500000;11183.333300,42933.333300;11297.500000,42853.333300;11310.277800,42929.444400;11416.666700,42983.333300;11423.888900,43000.277800;11438.333300,42057.222200;11461.111100,43252.777800;11485.555600,43187.222200;11503.055600,42855.277800;11511.388900,42106.388900;11522.222200,42841.944400;11569.444400,43136.666700;11583.333300,43150.000000;11595.000000,43148.055600;11600.000000,43150.000000;11690.555600,42686.666700;11715.833300,41836.111100;11751.111100,42814.444400;11770.277800,42651.944400;11785.277800,42884.444400;11822.777800,42673.611100;11846.944400,42660.555600;11963.055600,43290.555600;11973.055600,43026.111100;12058.333300,42195.555600;12149.444400,42477.500000;12286.944400,43355.555600;12300.000000,42433.333300;12355.833300,43156.388900;12363.333300,43189.166700;12372.777800,42711.388900;12386.666700,43334.722200;12421.666700,42895.555600;12645.000000,42973.333300];</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(coord,<span class="number">1</span>);  <span class="comment">% 城市的数目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)  <span class="comment">% 新建一个编号为1的图形窗口</span></span><br><span class="line"><span class="built_in">plot</span>(coord(:,<span class="number">1</span>),coord(:,<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>);   <span class="comment">% 画出城市的分布散点图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    text(coord(<span class="built_in">i</span>,<span class="number">1</span>)+<span class="number">0.01</span>,coord(<span class="built_in">i</span>,<span class="number">2</span>)+<span class="number">0.01</span>,num2str(<span class="built_in">i</span>))   <span class="comment">% 在图上标上城市的编号（加上0.01表示把文字的标记往右上方偏移一点）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">% 等一下要接着在这个图形上画图的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">zeros</span>(n);   <span class="comment">% 初始化两个城市的距离矩阵全为0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:n  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">i</span>  </span><br><span class="line">        coord_i = coord(<span class="built_in">i</span>,:);   x_i = coord_i(<span class="number">1</span>);     y_i = coord_i(<span class="number">2</span>);  <span class="comment">% 城市i的横坐标为x_i，纵坐标为y_i</span></span><br><span class="line">        coord_j = coord(<span class="built_in">j</span>,:);   x_j = coord_j(<span class="number">1</span>);     y_j = coord_j(<span class="number">2</span>);  <span class="comment">% 城市j的横坐标为x_j，纵坐标为y_j</span></span><br><span class="line">        d(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="built_in">sqrt</span>((x_i-x_j)^<span class="number">2</span> + (y_i-y_j)^<span class="number">2</span>);   <span class="comment">% 计算城市i和j的距离</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = d+d&#x27;;   <span class="comment">% 生成距离矩阵的对称的一面</span></span><br><span class="line"></span><br><span class="line">min_result = +<span class="built_in">inf</span>;  <span class="comment">% 假设最短的距离为min_result，初始化为无穷大，后面只要找到比它小的就对其更新</span></span><br><span class="line">min_path = [<span class="number">1</span>:n];   <span class="comment">% 初始化最短的路径就是1-2-3-...-n</span></span><br><span class="line">N = <span class="number">10000000</span>;  <span class="comment">% 蒙特卡罗模拟的次数</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:N  <span class="comment">% 开始循环</span></span><br><span class="line">    result = <span class="number">0</span>;  <span class="comment">% 初始化走过的路程为0</span></span><br><span class="line">    path = randperm(n);  <span class="comment">% 生成一个1-n的随机打乱的序列</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n<span class="number">-1</span>  </span><br><span class="line">        result = d(path(<span class="built_in">i</span>),path(<span class="built_in">i</span>+<span class="number">1</span>)) + result;  <span class="comment">% 按照这个序列不断的更新走过的路程这个值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = d(path(<span class="number">1</span>),path(n)) + result;  <span class="comment">% 别忘了加上从最后一个城市返回到最开始那个城市的距离</span></span><br><span class="line">    <span class="keyword">if</span> result &lt; min_result  <span class="comment">% 判断这次模拟走过的距离是否小于最短的距离，如果小于就更新最短距离和最短的路径</span></span><br><span class="line">        min_path = path;</span><br><span class="line">        min_result = result;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">min_path</span><br><span class="line">min_path = [min_path,min_path(<span class="number">1</span>)];   <span class="comment">% 在最短路径的最后面加上一个元素，即第一个点（我们要生成一个封闭的图形）</span></span><br><span class="line">n = n+<span class="number">1</span>;  <span class="comment">% 城市的个数加一个（紧随着上一步）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n<span class="number">-1</span> </span><br><span class="line">     <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    coord_i = coord(min_path(<span class="built_in">i</span>),:);   x_i = coord_i(<span class="number">1</span>);     y_i = coord_i(<span class="number">2</span>); </span><br><span class="line">    coord_j = coord(min_path(<span class="built_in">j</span>),:);   x_j = coord_j(<span class="number">1</span>);     y_j = coord_j(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">plot</span>([x_i,x_j],[y_i,y_j],<span class="string">&#x27;-&#x27;</span>)    <span class="comment">% 每两个点就作出一条线段，直到所有的城市都走完</span></span><br><span class="line">    pause(<span class="number">0.5</span>)  <span class="comment">% 暂停0.5s再画下一条线段</span></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h3 id="估计自然常数"><a href="#估计自然常数" class="headerlink" title="估计自然常数"></a>估计自然常数</h3><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  作业参考答案：蒙特卡罗的方法去估计自然常数e</span></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% (1)randperm函数的用法</span></span><br><span class="line">randperm(<span class="number">5</span>)  <span class="comment">% 生成1-5组成的一个随机序列</span></span><br><span class="line"><span class="comment">%      3     5     1     2     4</span></span><br><span class="line"><span class="comment">%      1     4     5     3     2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (2)find函数的用法 （第一期视频第一讲）</span></span><br><span class="line"><span class="comment">% 假设a是一个向量，那么find(a)可以用来返回这个向量中非零元素的下标，如果a中所有元素都为0，则返回空值</span></span><br><span class="line"><span class="built_in">find</span>([<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">-5</span>])  <span class="comment">%      1     2     3     5     7</span></span><br><span class="line"><span class="built_in">find</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])  <span class="comment">%   空的 1×0 double 行矢量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (3) 矩阵（或向量）和常量的比较运算可返回逻辑矩阵（或向量）(元素全为0和1)</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">-5</span>] &gt; <span class="number">0</span>      <span class="comment">%    1   1   1   0   1   0   0</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">-5</span>] == <span class="number">0</span>    <span class="comment">%    0   0   0   1   0   1   0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (4) isempty(A)函数可以用来判断A是否为空, 如果A为空， isempty(A) 返回逻辑值1(true)，否则返回逻辑值0(false)。</span></span><br><span class="line"><span class="built_in">isempty</span>(<span class="built_in">find</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]))   <span class="comment">%    1</span></span><br><span class="line"><span class="built_in">isempty</span>(<span class="built_in">find</span>([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]))   <span class="comment">%    0</span></span><br><span class="line"><span class="built_in">isempty</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])  <span class="comment">% 注意，别搞错啦，它不是空矩阵（空矩阵是指里面没有元素）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）参考答案</span></span><br><span class="line">clear;clc</span><br><span class="line">tic  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n = <span class="number">1000000</span>;  <span class="comment">% 蒙特卡洛的次数（理论上n取得越大，计算出来的结果越精确）</span></span><br><span class="line">m = <span class="number">0</span>;   <span class="comment">% 每个人拿到的都不是自己卡片的次数（频数）</span></span><br><span class="line">people = <span class="number">100</span>;   <span class="comment">% 假设一共有100个人玩这个游戏 （任给的）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n  <span class="comment">% 开始循环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(<span class="built_in">find</span>(randperm(people) - [<span class="number">1</span>:people] == <span class="number">0</span>))  <span class="comment">% 如果每个人拿到的都不是自己的卡片</span></span><br><span class="line">        m = m + <span class="number">1</span>;  <span class="comment">% 那么次数就加1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequency = m / n;  <span class="comment">% 每个人拿到的都不是自己卡片的频率（概率）</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;自然常数e的蒙特卡罗模拟值为：&#x27;</span>, num2str(<span class="number">1</span> / frequency)])  <span class="comment">% 注：自然常数真实值约为2.7182</span></span><br><span class="line">toc  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure>



<h3 id="武器升级"><a href="#武器升级" class="headerlink" title="武器升级"></a>武器升级</h3><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751167.png" style="zoom:80%;" />



<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗解决武器升级问题</span></span><br><span class="line"><span class="comment">% 现在有一把神器，初始为1级，可免费领取（即价值为0），可花费金币对其升级，每次10000金币，最多升到5级。</span></span><br><span class="line"><span class="comment">% 给定一个升级的概率表(见讲义)，问：5级神器价值多少金币？（即升级到5级神器平均的花费）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% 以一定的概率产生随机数  randsrc(m,n,[alphabet; prob])</span></span><br><span class="line"><span class="comment">% m和n表示生成的随机数矩阵的行数和列数</span></span><br><span class="line"><span class="comment">% alphabet表示需要产生的随机数的数字，用一个行向量表示</span></span><br><span class="line"><span class="comment">% prob表示这些数字出现的概率大小，用一个行向量表示，向量长度和alphabet向量要完全相同, 且这些概率的和要为1</span></span><br><span class="line"><span class="comment">% 比如：要产生1、4、 6这三个数。它们分别出现的概率为 0.1、0.2、0.7，如何设计程序使得按照这个概率产生10个随机数呢？</span></span><br><span class="line">alphabet = [<span class="number">1</span> <span class="number">4</span> <span class="number">6</span>]; prob = [<span class="number">0.1</span> <span class="number">0.2</span> <span class="number">0.7</span>];</span><br><span class="line">randsrc(<span class="number">10</span>,<span class="number">1</span>,[alphabet; prob])</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）参考答案</span></span><br><span class="line"><span class="comment">% clear;clc</span></span><br><span class="line">tic  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"><span class="comment">% 升级的成功率储存在success矩阵中，以第一行和第三行为例，表格的解释：</span></span><br><span class="line"><span class="comment">%  1级武器强化时，有20%概率升到2级，10%概率升到3级，5%概率升到4级，65%概率不变。</span></span><br><span class="line"><span class="comment">%  3级武器强化时，10%概率跌到1级，20%概率跌到2级，20%概率升到4级，10%概率升到5级</span></span><br><span class="line">success = [<span class="number">0.65</span> <span class="number">0.2</span>  <span class="number">0.1</span>  <span class="number">0.05</span>  <span class="number">0</span>;</span><br><span class="line">                 <span class="number">0.25</span> <span class="number">0.4</span>  <span class="number">0.2</span>  <span class="number">0.1</span>    <span class="number">0.05</span>;</span><br><span class="line">                 <span class="number">0.1</span>   <span class="number">0.2</span>  <span class="number">0.4</span>  <span class="number">0.2</span>    <span class="number">0.1</span>;</span><br><span class="line">                 <span class="number">0</span>      <span class="number">0.1</span>  <span class="number">0.3</span>  <span class="number">0.4</span>    <span class="number">0.2</span>] ;</span><br><span class="line">n = <span class="number">10000</span>;  <span class="comment">% 蒙特卡罗模拟的次数</span></span><br><span class="line">MONEY = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  <span class="comment">% 初始化用来存储每次蒙特卡罗计算出来的表示强化费用的向量</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    rank = <span class="number">1</span>; <span class="comment">% 武器的初始等级</span></span><br><span class="line">    money = <span class="number">0</span>;  <span class="comment">%花费的钱数，初始化为0</span></span><br><span class="line">    alphabet = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>];   <span class="comment">% 用来表示五个等级</span></span><br><span class="line">    <span class="keyword">while</span> rank ~= <span class="number">5</span>  <span class="comment">% 只要等级不是5级， 就一直循环下去</span></span><br><span class="line">        prob =success(rank,:);    <span class="comment">% 令生成随机数的概率为第rank行</span></span><br><span class="line">        rank = randsrc(<span class="number">1</span>,<span class="number">1</span>,[alphabet; prob]);   <span class="comment">% 生成一个在1-5中的随机数，表示强化后的等级</span></span><br><span class="line">        money = money + <span class="number">10000</span>;  <span class="comment">% 更新强化的费用</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MONEY(<span class="built_in">i</span>) = money;  <span class="comment">% 将这次蒙特卡罗的结果保存到MONEY向量中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;将武器升级到5级的平均花费为：&#x27;</span>,num2str(<span class="built_in">mean</span>(MONEY))])</span><br><span class="line">toc  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure>



<h3 id="选择决策方案模拟（换灯泡问题）"><a href="#选择决策方案模拟（换灯泡问题）" class="headerlink" title="选择决策方案模拟（换灯泡问题）"></a>选择决策方案模拟（换灯泡问题）</h3><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 选择决策方案的模拟</span></span><br><span class="line"><span class="comment">% 某设备上安装有四只型号规格完全相同的电子管，已知电子管寿命为1000--2000小时之间的均匀分布(假定为整数)。</span></span><br><span class="line"><span class="comment">% 当电子管损坏时有两种维修方案，一是每次更换损坏的那一只；二是当其中一只损坏时四只同时更换。</span></span><br><span class="line"><span class="comment">% 已知更换时间为换一只时需1小时，4只同时换为2小时。</span></span><br><span class="line"><span class="comment">% 更换时机器因停止运转每小时的损失为20元，又每只电子管价格10元，</span></span><br><span class="line"><span class="comment">% 试用模拟方法决定哪一个方案经济合理？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% randi([a,b],m,n)  随机生成m*n的矩阵，矩阵中的每个元素都是[a,b]中的随机整数</span></span><br><span class="line">randi([<span class="number">1</span>, <span class="number">5</span>],<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">randi([<span class="number">1</span>, <span class="number">5</span>])  <span class="comment">% 不写m*n代表只生成1个随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% find函数的用法</span></span><br><span class="line"><span class="comment">% find函数的用法在第一期视频：层次分析法那一节讲过，我们当时找最大特征值的位置</span></span><br><span class="line">a = [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span>];</span><br><span class="line"><span class="built_in">find</span>(a)  <span class="comment">% 找到a中所有非0元素的位置</span></span><br><span class="line"><span class="built_in">find</span>(a == <span class="number">5</span>)  <span class="comment">% 找到a中等于5的元素的位置</span></span><br><span class="line"><span class="built_in">find</span>(a == <span class="number">5</span>,<span class="number">1</span>)  <span class="comment">% 找到a中第一个等于5的元素的位置</span></span><br><span class="line"><span class="built_in">find</span>(a == <span class="built_in">min</span>(a))   <span class="comment">% 找到a中最小元素的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">clear;clc</span><br><span class="line">T = <span class="number">100000000</span>;   <span class="comment">% T表示模拟的总时间（单位为小时）</span></span><br><span class="line">t = <span class="number">0</span>;   <span class="comment">% 初始化当前时刻为0小时</span></span><br><span class="line">c1 = <span class="number">0</span>; c2 = <span class="number">0</span>;  <span class="comment">% 初始化两种方案的总花费都为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  方案一</span></span><br><span class="line">life = randi([<span class="number">1000</span>,<span class="number">2000</span>],<span class="number">1</span>,<span class="number">4</span>);  <span class="comment">% 随机生成四个电子管的寿命，假设为整数</span></span><br><span class="line"><span class="keyword">while</span> t &lt; T  <span class="comment">% 只要现在的时刻没有超过总时刻，就不断循环下去</span></span><br><span class="line">    result = <span class="built_in">min</span>(life);  <span class="comment">% 找出寿命最短的那一个电子管的寿命</span></span><br><span class="line">    t = t+result+<span class="number">1</span>;  <span class="comment">% 现在的时间更改到有电子管损坏的时刻（加上1表示更换电子管需要花费的时间）</span></span><br><span class="line">    c1 = c1 + <span class="number">20</span> * <span class="number">1</span> +<span class="number">10</span>;  <span class="comment">% 更新方案一的花费 </span></span><br><span class="line">    k = <span class="built_in">find</span>(life == result,<span class="number">1</span>);   <span class="comment">% 找到哪一个电子管是坏的</span></span><br><span class="line">    life = life - result <span class="number">-1</span>; <span class="comment">% 更新所有电子管的寿命（这里不减去1也是可以的，减少了1也无所谓，对结果的影响很小）    </span></span><br><span class="line">    life(k) = randi([<span class="number">1000</span>,<span class="number">2000</span>]);  <span class="comment">% 把坏掉的那个电子管的寿命重置</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  方案二</span></span><br><span class="line">t = <span class="number">0</span>;   <span class="comment">% 初始化当前时刻为0小时</span></span><br><span class="line"><span class="keyword">while</span> t &lt; T  <span class="comment">% 只要现在的时刻没有超过总时刻，就不断循环下去</span></span><br><span class="line">    life = randi([<span class="number">1000</span>,<span class="number">2000</span>],<span class="number">1</span>,<span class="number">4</span>); <span class="comment">% 随机生成四个电子管的寿命，假设为整数</span></span><br><span class="line">    result = <span class="built_in">min</span>(life); <span class="comment">% 找出寿命最小的那一个电子管的寿命</span></span><br><span class="line">    t = t+result+<span class="number">2</span>;  <span class="comment">% 现在的时间更改到有电子管损坏的时刻（加上2表示更换所有电子管需要花费的时间）</span></span><br><span class="line">    c2 =c2 + <span class="number">20</span> * <span class="number">2</span> +<span class="number">40</span>;  <span class="comment">% 更新方案二的花费 </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 两种方案的花费</span></span><br><span class="line">c1</span><br><span class="line">c2</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qinmoranyanyu.github.io">Chen Jiabin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qinmoranyanyu.github.io/2025/03/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://qinmoranyanyu.github.io/2025/03/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://qinmoranyanyu.github.io" target="_blank">青墨染烟雨</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post-share"><div class="social-share" data-image="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020504.jpg" target="_blank"><img class="post-qr-code-img" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020504.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020503.png" target="_blank"><img class="post-qr-code-img" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020503.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/01/Python%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" title="Python算法学习笔记"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011807922.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python算法学习笔记</div></div><div class="info-2"><div class="info-item-1">包括各种数据结构和常用算法</div></div></div></a><a class="pagination-related" href="/2025/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B1/" title="自定义博客网站搭建教程（1）"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011810400.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">自定义博客网站搭建教程（1）</div></div><div class="info-2"><div class="info-item-1">关于我的博客网站搭建过程</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/01/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011819971.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Git学习笔记</div></div><div class="info-2"><div class="info-item-1">Git学习，包括Git的原理和再idea中的使用</div></div></div></a><a class="pagination-related" href="/2025/03/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Nginx学习笔记"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011821873.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Nginx学习笔记</div></div><div class="info-2"><div class="info-item-1">Nginx的学习笔记，包括Nginx的部署，配置文件的含义，集群化等内容</div></div></div></a><a class="pagination-related" href="/2025/03/01/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux 学习笔记"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011826863.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Linux 学习笔记</div></div><div class="info-2"><div class="info-item-1">Nginx的学习笔记，包括Nginx的部署，配置文件的含义，集群化等内容</div></div></div></a><a class="pagination-related" href="/2025/03/01/Java%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/" title="Java八股学习"><img class="cover" src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Java八股学习</div></div><div class="info-2"><div class="info-item-1">Java八股学习总结</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011603481.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Chen Jiabin</div><div class="author-info-description">回首向来萧瑟处,归去,也无风雨也无晴</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qinmoranyanyu"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.cnblogs.com/chenjiabin" target="_blank" title="博客园"><i class="fa-solid fa-blog" style="color: #000000;"></i></a><a class="social-icon" href="https://gitee.com/forever-or-moment" target="_blank" title="gitee"><i class="fa-solid fa-rss" style="color: #000000;"></i></a><a class="social-icon" href="mailto:2948429338@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">基于hexo的博客网站,终于搭好了!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">评价类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">层次分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.1.</span> <span class="toc-text">搜索引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">算法代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F4%E9%94%81%E5%AE%9A%E5%8D%95%E5%85%83%E6%A0%BC"><span class="toc-number">2.1.4.</span> <span class="toc-text">F4锁定单元格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">优劣解距离法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">算法代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%BE%93%E5%85%A5%E6%9D%83%E9%87%8D%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">自输入权重代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%86%B5%E6%9D%83%E6%B3%95%E6%9D%83%E9%87%8D%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">基于熵权法权重的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">灰色关联分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">传统数理统计的不足之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">该方法的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.3.4.</span> <span class="toc-text">算法代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%BA%A6%E6%9D%83%E9%87%8D%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.5.</span> <span class="toc-text">基于灰色关联度权重的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7"><span class="toc-number">2.4.</span> <span class="toc-text">模糊综合评价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">算法步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8excel%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2"><span class="toc-number">2.5.</span> <span class="toc-text">用excel绘制图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BC%E5%9B%BE"><span class="toc-number">2.5.1.</span> <span class="toc-text">饼图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE"><span class="toc-number">2.5.2.</span> <span class="toc-text">柱状图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%9F%B1%E7%8A%B6%E5%9B%BE"><span class="toc-number">2.5.3.</span> <span class="toc-text">双向柱状图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E5%BD%A2%E5%9B%BE"><span class="toc-number">2.5.4.</span> <span class="toc-text">条形图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%9D%A1%E5%BD%A2%E5%9B%BE"><span class="toc-number">2.5.5.</span> <span class="toc-text">双向条形图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">2.5.6.</span> <span class="toc-text">直方图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E7%BA%BF%E5%9B%BE"><span class="toc-number">2.5.7.</span> <span class="toc-text">折线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E8%BD%B4%E6%8A%98%E7%BA%BF%E5%9B%BE"><span class="toc-number">2.5.8.</span> <span class="toc-text">双轴折线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%88%AB%E6%8A%98%E7%BA%BF%E5%9B%BE"><span class="toc-number">2.5.9.</span> <span class="toc-text">类别折线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E7%82%B9%E5%9B%BE"><span class="toc-number">2.5.10.</span> <span class="toc-text">散点图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%95%A3%E7%82%B9%E5%9B%BE"><span class="toc-number">2.5.11.</span> <span class="toc-text">分类散点图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%B1%E7%BA%BF%E5%9B%BE"><span class="toc-number">2.5.12.</span> <span class="toc-text">箱线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#excel%E6%8A%80%E5%B7%A7"><span class="toc-number">2.5.13.</span> <span class="toc-text">excel技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8%EF%BC%88%E4%BE%BF%E4%BA%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">2.5.13.1.</span> <span class="toc-text">数据透视表（便于数据交互分析）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.13.2.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8%E6%9C%89%E7%A9%BA%E7%99%BD"><span class="toc-number">2.5.13.2.1.</span> <span class="toc-text">1.数据透视表有空白</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%97%A5%E6%9C%9F%E6%88%96%E6%97%B6%E5%88%BB%E4%B8%BA%E6%96%87%E6%9C%AC%E5%9E%8B"><span class="toc-number">2.5.13.2.2.</span> <span class="toc-text">2.日期或时刻为文本型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%B0%E5%80%BC%E4%B8%BA%E6%96%87%E6%9C%AC%E5%9E%8B"><span class="toc-number">2.5.13.2.3.</span> <span class="toc-text">3.数值为文本型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.5.13.3.</span> <span class="toc-text">强大的工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">插值算法（常用于数据缺失值处理）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E9%98%B6%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.1.</span> <span class="toc-text">低阶插值方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%98%B6%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1%EF%BC%89%EF%BC%88%E5%AF%BC%E6%95%B0%E4%B8%8D%E7%AC%A6%E5%90%88%EF%BC%89"><span class="toc-number">2.6.2.</span> <span class="toc-text">中阶插值方法（龙格现象）（导数不符合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88%E5%AF%BC%E6%95%B0%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%89"><span class="toc-number">2.6.3.</span> <span class="toc-text">高阶插值方法（导数保持一致）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.6.4.</span> <span class="toc-text">算法代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E7%9F%AD%E6%9C%9F%E9%A2%84%E6%B5%8B"><span class="toc-number">2.6.5.</span> <span class="toc-text">插值方法可以进行短期预测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">2.6.6.</span> <span class="toc-text">数据缺失值处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">拟合算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E4%BC%98%E5%BA%A6%EF%BC%88%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%EF%BC%89"><span class="toc-number">2.7.1.</span> <span class="toc-text">拟合优度（线性函数的评价指标）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.7.2.</span> <span class="toc-text">算法代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">最小二乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E5%B7%A5%E5%85%B7%E7%AE%B1%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">拟合工具箱使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%A6%E6%9C%AF%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-word%E6%96%87%E4%BB%B6"><span class="toc-number">2.7.2.2.1.</span> <span class="toc-text">相关学术名词解释 (word文件)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90"><span class="toc-number">2.8.</span> <span class="toc-text">相关分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pearson%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">Pearson相关系数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-5"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">算法代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPSS"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">SPSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">2.8.1.3.</span> <span class="toc-text">数据可视化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.8.2.</span> <span class="toc-text">分析统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%95%A3%E7%82%B9%E5%9B%BE"><span class="toc-number">2.8.3.</span> <span class="toc-text">矩阵散点图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.4.</span> <span class="toc-text">假设检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.8.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pearson%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.4.2.</span> <span class="toc-text">Pearson相关系数假设检验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pearson%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.8.4.3.</span> <span class="toc-text">Pearson假设检验条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.5.</span> <span class="toc-text">正态分布检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JB%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.5.1.</span> <span class="toc-text">JB检验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8F%E7%9A%AE%E6%B4%9B%E2%80%94%E5%A8%81%E5%B0%94%E5%85%8B%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.5.2.</span> <span class="toc-text">夏皮洛—威尔克检验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q%E2%80%94Q%E5%9B%BE%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.5.3.</span> <span class="toc-text">Q—Q图检验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spearman%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0"><span class="toc-number">2.8.6.</span> <span class="toc-text">Spearman相关系数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C-1"><span class="toc-number">2.8.6.1.</span> <span class="toc-text">假设检验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.8.7.</span> <span class="toc-text">两种相关系数的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">2.9.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">2.9.1.</span> <span class="toc-text">迪杰斯特拉算法（广度优先算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.2.</span> <span class="toc-text">贝尔曼福特算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-6"><span class="toc-number">2.9.3.</span> <span class="toc-text">算法代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.4.</span> <span class="toc-text">弗洛伊德算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-7"><span class="toc-number">2.9.4.1.</span> <span class="toc-text">算法代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-number">2.10.</span> <span class="toc-text">多元回归分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.10.1.</span> <span class="toc-text">回归分析的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.10.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86"><span class="toc-number">2.10.3.</span> <span class="toc-text">数据收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">2.10.4.</span> <span class="toc-text">一元线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.10.4.1.</span> <span class="toc-text">解释变量模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.10.4.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">2.10.5.</span> <span class="toc-text">多元线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8F%98%E9%87%8F%E4%B8%8D%E5%85%85%E5%88%86%E4%BA%A7%E7%94%9F%E5%86%85%E7%94%9F%E6%80%A7"><span class="toc-number">2.10.5.1.</span> <span class="toc-text">自变量不充分产生内生性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A7%A3%E9%87%8A%E5%8F%98%E9%87%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%98%E9%87%8F%E8%A7%A3%E6%95%91%E5%86%85%E7%94%9F%E6%80%A7"><span class="toc-number">2.10.5.2.</span> <span class="toc-text">核心解释变量和控制变量解救内生性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A"><span class="toc-number">2.10.5.3.</span> <span class="toc-text">回归模型解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E9%A1%B9"><span class="toc-number">2.10.5.4.</span> <span class="toc-text">交互项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.6.</span> <span class="toc-text">回归方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.10.6.1.</span> <span class="toc-text">软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%AF%AD%E6%B3%95"><span class="toc-number">2.10.6.2.</span> <span class="toc-text">处理语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">2.10.6.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R-2-%E8%BE%83%E4%BD%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.7.</span> <span class="toc-text">R^2^较低处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E5%9B%9E%E5%BD%92%E6%B6%88%E9%99%A4%E9%87%8F%E7%BA%B2%EF%BC%88%E5%BA%A6%E9%87%8F%E5%BD%B1%E5%93%8D%E5%8A%9B%EF%BC%89"><span class="toc-number">2.10.8.</span> <span class="toc-text">标准化回归消除量纲（度量影响力）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%96%B9%E5%B7%AE"><span class="toc-number">2.10.9.</span> <span class="toc-text">异方差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.10.9.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%96%B9%E5%B7%AE%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">2.10.9.2.</span> <span class="toc-text">异方差的影响和解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E5%BC%82%E6%96%B9%E5%B7%AE%E5%AD%98%E5%9C%A8"><span class="toc-number">2.10.9.3.</span> <span class="toc-text">检验异方差存在</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BP%E6%A3%80%E9%AA%8C"><span class="toc-number">2.10.9.3.1.</span> <span class="toc-text">BP检验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%80%E7%89%B9%E6%A3%80%E9%AA%8C"><span class="toc-number">2.10.9.3.2.</span> <span class="toc-text">怀特检验</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%96%B9%E5%B7%AE%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">2.10.9.4.</span> <span class="toc-text">异方差的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%B3%E5%81%A5%E6%A0%87%E5%87%86%E8%AF%AF%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">2.10.9.4.1.</span> <span class="toc-text">稳健标准误（推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7"><span class="toc-number">2.10.10.</span> <span class="toc-text">多重共线性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="toc-number">2.10.10.1.</span> <span class="toc-text">多重共线性检验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.10.2.</span> <span class="toc-text">多重共线性处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%90%E6%AD%A5%E5%9B%9E%E5%BD%92"><span class="toc-number">2.10.10.2.1.</span> <span class="toc-text">逐步回归</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%92%8Classo%E5%9B%9E%E5%BD%92%EF%BC%88%E9%80%90%E6%AD%A5%E5%9B%9E%E5%BD%92%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%EF%BC%88%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">岭回归和lasso回归（逐步回归升级版）（解决多重共线性）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A4%E5%85%B8%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.11.1.</span> <span class="toc-text">古典回归模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%AD%E5%9B%9E%E5%BD%92"><span class="toc-number">2.11.2.</span> <span class="toc-text">岭回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%CE%BB%E9%80%89%E5%8F%96"><span class="toc-number">2.11.2.1.</span> <span class="toc-text">λ选取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.11.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lasso%E5%9B%9E%E5%BD%92%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">2.11.3.</span> <span class="toc-text">lasso回归（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#K%E6%8A%98%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="toc-number">2.11.3.1.</span> <span class="toc-text">K折交叉验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E4%B8%8D%E9%87%8D%E8%A6%81%E7%9A%84%E8%87%AA%E5%8F%98%E9%87%8F"><span class="toc-number">2.11.3.2.</span> <span class="toc-text">压缩不重要的自变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">2.11.3.3.</span> <span class="toc-text">适用情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.11.3.4.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">分类模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="toc-number">2.12.1.</span> <span class="toc-text">逻辑回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%B1%BB"><span class="toc-number">2.12.1.1.</span> <span class="toc-text">二分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E7%B1%BB"><span class="toc-number">2.12.1.2.</span> <span class="toc-text">多分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fisher%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-number">2.12.2.</span> <span class="toc-text">Fisher线性判别分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%B1%BB-1"><span class="toc-number">2.12.2.1.</span> <span class="toc-text">二分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E7%B1%BB-1"><span class="toc-number">2.12.2.2.</span> <span class="toc-text">多分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.13.</span> <span class="toc-text">聚类模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%EF%BC%89"><span class="toc-number">2.13.1.</span> <span class="toc-text">K-means聚类算法（基于距离）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3"><span class="toc-number">2.13.1.1.</span> <span class="toc-text">算法优劣</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-means-%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%EF%BC%89"><span class="toc-number">2.13.2.</span> <span class="toc-text">K-means++改进算法（基于距离）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spss%E6%93%8D%E4%BD%9C"><span class="toc-number">2.13.2.1.</span> <span class="toc-text">spss操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%B1%82%E6%AC%A1%EF%BC%89%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%EF%BC%89%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">2.13.3.</span> <span class="toc-text">系统（层次）聚类（基于距离）（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.13.3.1.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.13.3.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spss%E6%93%8D%E4%BD%9C-1"><span class="toc-number">2.13.3.3.</span> <span class="toc-text">spss操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%82%98%E9%83%A8%E5%9B%BE%EF%BC%88%E4%BC%B0%E8%AE%A1k%EF%BC%89"><span class="toc-number">2.13.3.4.</span> <span class="toc-text">肘部图（估计k）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DBSCAN%E7%AE%97%E6%B3%95%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%AF%86%E5%BA%A6%EF%BC%89"><span class="toc-number">2.13.4.</span> <span class="toc-text">DBSCAN算法（基于密度）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.13.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3-1"><span class="toc-number">2.13.4.2.</span> <span class="toc-text">算法优劣</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.13.4.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90"><span class="toc-number">2.14.</span> <span class="toc-text">时间序列分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">2.14.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E8%A7%A3"><span class="toc-number">2.14.2.</span> <span class="toc-text">时间序列分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spss%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">2.14.3.</span> <span class="toc-text">spss缺失值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spss%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%88%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%9B%BE%EF%BC%89"><span class="toc-number">2.14.4.</span> <span class="toc-text">spss数据处理（时间序列图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%94%A8%E9%80%94%E5%92%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.14.5.</span> <span class="toc-text">操作用途和步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.14.6.</span> <span class="toc-text">模型建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.14.6.1.</span> <span class="toc-text">指数平滑模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.14.6.2.</span> <span class="toc-text">一元时间序列分析模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.14.7.</span> <span class="toc-text">建模思路和实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A3%E8%8A%82%E6%80%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">2.14.7.1.</span> <span class="toc-text">季节性数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E5%8F%A3%E9%A2%84%E6%B5%8B"><span class="toc-number">2.14.7.2.</span> <span class="toc-text">人口预测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E4%B8%8A%E8%AF%81%E6%8C%87%E6%95%B0%E9%A2%84%E6%B5%8B"><span class="toc-number">2.14.7.3.</span> <span class="toc-text">股票上证指数预测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GDP%E5%A2%9E%E9%80%9F%E9%A2%84%E6%B5%8B"><span class="toc-number">2.14.7.4.</span> <span class="toc-text">GDP增速预测</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">优化类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.1.</span> <span class="toc-text">蒙特卡洛模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E4%BE%8B%EF%BC%9A%E6%B5%A6%E4%B8%B0%E6%8A%95%E9%92%88%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.1.1.</span> <span class="toc-text">引例：浦丰投针实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.3.</span> <span class="toc-text">三门问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">排队问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.5.</span> <span class="toc-text">非线性约束问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.6.</span> <span class="toc-text">0-1规划问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%BC%B9%E8%BF%BD%E8%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.7.</span> <span class="toc-text">导弹追踪问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-number">3.1.7.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.8.</span> <span class="toc-text">旅行商问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-number">3.1.8.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E8%AE%A1%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0"><span class="toc-number">3.1.9.</span> <span class="toc-text">估计自然常数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-number">3.1.9.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A6%E5%99%A8%E5%8D%87%E7%BA%A7"><span class="toc-number">3.1.10.</span> <span class="toc-text">武器升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-number">3.1.10.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%86%B3%E7%AD%96%E6%96%B9%E6%A1%88%E6%A8%A1%E6%8B%9F%EF%BC%88%E6%8D%A2%E7%81%AF%E6%B3%A1%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.1.11.</span> <span class="toc-text">选择决策方案模拟（换灯泡问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-number">3.1.11.1.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011819971.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记">Git学习笔记</a><time datetime="2025-03-01T10:15:02.000Z" title="发表于 2025-03-01 18:15:02">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Nginx学习笔记"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011821873.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Nginx学习笔记">Nginx学习笔记</a><time datetime="2025-03-01T10:15:02.000Z" title="发表于 2025-03-01 18:15:02">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/OJ%E5%9C%A8%E7%BA%BF%E5%88%A4%E9%A2%98%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/" title="OJ在线代码测评系统"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011817797.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OJ在线代码测评系统"/></a><div class="content"><a class="title" href="/2025/03/01/OJ%E5%9C%A8%E7%BA%BF%E5%88%A4%E9%A2%98%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/" title="OJ在线代码测评系统">OJ在线代码测评系统</a><time datetime="2025-03-01T10:15:02.000Z" title="发表于 2025-03-01 18:15:02">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B2/" title="自定义博客网站搭建教程（2）"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011810400.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义博客网站搭建教程（2）"/></a><div class="content"><a class="title" href="/2025/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B2/" title="自定义博客网站搭建教程（2）">自定义博客网站搭建教程（2）</a><time datetime="2025-03-01T10:09:30.000Z" title="发表于 2025-03-01 18:09:30">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B1/" title="自定义博客网站搭建教程（1）"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011810400.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义博客网站搭建教程（1）"/></a><div class="content"><a class="title" href="/2025/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B1/" title="自定义博客网站搭建教程（1）">自定义博客网站搭建教程（1）</a><time datetime="2025-03-01T10:08:30.000Z" title="发表于 2025-03-01 18:08:30">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011751016.png);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Chen Jiabin</div><div class="footer_custom_text">我的心是簇拥烈日的花,在你的眼里找到了家</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://lustrous-frangollo-1c41d7.netlify.app/.netlify/functions/twikoo',
      region: 'ap-chengdu',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://lustrous-frangollo-1c41d7.netlify.app/.netlify/functions/twikoo',
      region: 'ap-chengdu',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'JcfrKHxQrPHk3PkrQ8h00WFr-gzGzoHsz',
      appKey: 'SOXW4EXnij10ALSUlWzz5BXv',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.16/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Twikoo' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="2685449094" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://unpkg.com/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="开始搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>