<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kafka入门到精通 | 青墨染烟雨</title><meta name="author" content="Chen Jiabin,2948429338@qq.com"><meta name="copyright" content="Chen Jiabin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kafka入门到精通">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka入门到精通">
<meta property="og:url" content="https://blog.chenjiabin.xyz/posts/14310/index.html">
<meta property="og:site_name" content="青墨染烟雨">
<meta property="og:description" content="Kafka入门到精通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0325c825fa31fa6f45916f706a22cca4.png">
<meta property="article:published_time" content="2025-03-04T15:34:11.000Z">
<meta property="article:modified_time" content="2025-03-04T15:39:57.933Z">
<meta property="article:author" content="Chen Jiabin">
<meta property="article:tag" content="入门到精通">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0325c825fa31fa6f45916f706a22cca4.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kafka入门到精通",
  "url": "https://blog.chenjiabin.xyz/posts/14310/",
  "image": "https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0325c825fa31fa6f45916f706a22cca4.png",
  "datePublished": "2025-03-04T15:34:11.000Z",
  "dateModified": "2025-03-04T15:39:57.933Z",
  "author": [
    {
      "@type": "Person",
      "name": "Chen Jiabin",
      "url": "https://blog.chenjiabin.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011641807.svg"><link rel="canonical" href="https://blog.chenjiabin.xyz/posts/14310/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="4yH3_EEqHZ9_glXp2Ey1UlNzL_EQ2NQ0TO1lAXhBrvE"/><meta name="baidu-site-verification" content="codeva-dQzACO1Fjm"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kafka入门到精通',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011603481.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-bars"></i><span> 推荐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fa-solid fa-headphones"></i><span> 歌曲</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa-solid fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0325c825fa31fa6f45916f706a22cca4.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011641807.svg" alt="Logo"><span class="site-name">青墨染烟雨</span></a><a class="nav-page-title" href="/"><span class="site-name">Kafka入门到精通</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-bars"></i><span> 推荐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fa-solid fa-headphones"></i><span> 歌曲</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa-solid fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kafka入门到精通</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-04T15:34:11.000Z" title="发表于 2025-03-04 23:34:11">2025-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-04T15:39:57.933Z" title="更新于 2025-03-04 23:39:57">2025-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kafka/">Kafka</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">48k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>202分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/14310/#post-comment"><span class="waline-comment-count" data-path="/posts/14310/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="——–"><a href="#——–" class="headerlink" title="——–"></a>——–</h1><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h1 id="——–-1"><a href="#——–-1" class="headerlink" title="——–"></a>——–</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><a target="_blank" rel="noopener" href="https://kafka.apache.org/">Kafka</a> 是基于发布与订阅的消息系统。它最初由 LinkedIn 公司开发，之后成为 Apache 项目的一部分。</p>
<p>因为朋友已经写了一篇很不错的 Kafka 入门文章，所以艿艿就可以光明正大的偷懒了。对 Kafka 不了解的胖友，可以先阅读 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/yuliu/doc">《消息队列之 Kafka》</a> 文章的 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Kafka/install/?self#">「1. Kafka 特点」</a> 和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Kafka/install/?self#">「2. Kafka 中的基本概念」</a> 两个小节。😜</p>
<h1 id="2-单机部署"><a href="#2-单机部署" class="headerlink" title="2. 单机部署"></a>2. 单机部署</h1><blockquote>
<p>操作系统：macOS 10.14</p>
<p>其它系统，基本一致的。</p>
</blockquote>
<p>Kafka 依赖 ZooKeeper 服务，所以胖友先自行安装并启动一个 ZooKeeper 服务。不会的胖友，可以参考阅读下 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/ZooKeeper/install/?self">《ZooKeeper 极简入门》</a> 文章的 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Kafka/install/?self#">「2. 单机部署」</a> 小节。这里，艿艿在本机 <code>127.0.0.1:2181</code> 启动了一个 ZooKeeper 单节点。</p>
<h2 id="2-1-下载软件包"><a href="#2-1-下载软件包" class="headerlink" title="2.1 下载软件包"></a>2.1 下载软件包</h2><p>打开 <a target="_blank" rel="noopener" href="http://kafka.apache.org/downloads">Kafka Download</a> 页面，我们可以看到 Kafka 所有的发布版本。这里，我们选择最新的 <a href="hhttp://kafka.apache.org/downloads#2.3.1">Kafka 2.3.1</a> 版本。这里，我们可以看到两种发布版本：</p>
<ul>
<li>Source: <a target="_blank" rel="noopener" href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.1/kafka-2.3.1-src.tgz">kafka-2.3.1-src.tgz</a></li>
<li>Binary: <a target="_blank" rel="noopener" href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.1/kafka_2.12-2.3.1.tgz">kafka_2.12-2.3.1.tgz</a></li>
</ul>
<p>一般情况下，我们可以直接使用 Binary 版本，它是 Kafka 已经编译好，可以直接使用的 Kafka 软件包。</p>
<p>下面，我们开始下载 Kafka Binary 软件包。命令行操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">$ mkdir -p /Users/yunai/Kafka</span><br><span class="line">$ cd /Users/yunai/Kafka</span><br><span class="line"></span><br><span class="line"># 下载</span><br><span class="line">$ wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.3.1/kafka_2.12-2.3.1.tgz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">$ unzip kafka_2.12-2.3.1.tgz</span><br><span class="line"></span><br><span class="line"># 查看 Kafka 软件包的目录</span><br><span class="line">$ kafka_2.12-2.3.1</span><br><span class="line">$ ls -ls</span><br><span class="line">total 72</span><br><span class="line">64 -rw-r--r--   1 yunai  staff  32216 Oct 18 08:10 LICENSE</span><br><span class="line"> 8 -rw-r--r--   1 yunai  staff    337 Oct 18 08:10 NOTICE</span><br><span class="line"> 0 drwxr-xr-x  33 yunai  staff   1056 Oct 18 08:12 bin # 执行脚本</span><br><span class="line"> 0 drwxr-xr-x  16 yunai  staff    512 Oct 18 08:12 config # 配置文件</span><br><span class="line"> 0 drwxr-xr-x  94 yunai  staff   3008 Oct 18 08:12 libs # Kafka jar 包</span><br><span class="line"> 0 drwxr-xr-x   9 yunai  staff    288 Dec  5 14:50 logs # 日志文件</span><br><span class="line"> 0 drwxr-xr-x   3 yunai  staff     96 Oct 18 08:12 site-docs # 文档</span><br></pre></td></tr></table></figure>



<h2 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h2><p>在 <code>config</code> 目录下，提供了 Kafka 各个组件的配置文件。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ls config</span><br><span class="line">total 136</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff   906 Oct 18 08:10 connect-console-sink.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff   909 Oct 18 08:10 connect-console-source.properties</span><br><span class="line">16 -rw-r--r--  1 yunai  staff  5321 Oct 18 08:10 connect-distributed.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff   883 Oct 18 08:10 connect-file-sink.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff   881 Oct 18 08:10 connect-file-source.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  1552 Oct 18 08:10 connect-log4j.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  2262 Oct 18 08:10 connect-standalone.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  1221 Oct 18 08:10 consumer.properties</span><br><span class="line">16 -rw-r--r--  1 yunai  staff  4727 Oct 18 08:10 log4j.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  1925 Oct 18 08:10 producer.properties</span><br><span class="line">16 -rw-r--r--  1 yunai  staff  6851 Oct 18 08:10 server.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  1032 Oct 18 08:10 tools-log4j.properties</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  1169 Oct 18 08:10 trogdor.conf</span><br><span class="line"> 8 -rw-r--r--  1 yunai  staff  1023 Oct 18 08:10 zookeeper.properties</span><br></pre></td></tr></table></figure>



<p>这里，我们先创建一个 <code>data</code> 目录，然后编辑 <code>conf/server.properties</code> 配置文件，修改数据目录为新创建的 <code>data</code> 目录，即 <code>log.dirs=/Users/yunai/Kafka/kafka_2.12-2.3.1/data</code> 。</p>
<p>😈 当然，因为单机部署是学习或者测试之用，所以不改也问题不大。</p>
<h2 id="2-3-启动-Kafka"><a href="#2-3-启动-Kafka" class="headerlink" title="2.3 启动 Kafka"></a>2.3 启动 Kafka</h2><p>启动一个 Kafka Broker 服务。命令行操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>



<p>启动完成后，查看日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 Kafka Broker 日志。</span><br><span class="line">$ tail -f logs/server.log</span><br><span class="line"></span><br><span class="line">[2019-12-07 19:34:27,983] INFO Kafka version: 2.3.1 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2019-12-07 19:34:27,983] INFO Kafka commitId: 18a913733fb71c01 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2019-12-07 19:34:27,983] INFO Kafka startTimeMs: 1575545667980 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2019-12-07 19:34:27,985] INFO [KafkaServer id=0] started (kafka.server.KafkaServer)</span><br></pre></td></tr></table></figure>



<ul>
<li>默认情况下，Kafka Broker 日志文件所在地址为 <code>logs/server.log</code> 。如果想要自定义，可以通过 <code>config/log4j.properties</code> 配置文件来进行修改。</li>
</ul>
<p>😈 至此，我们已经完成了 Kafka 单机部署。下面，我们开始进行下消息的发送和消费的测试。</p>
<h2 id="2-4-创建-Topic"><a href="#2-4-创建-Topic" class="headerlink" title="2.4 创建 Topic"></a>2.4 创建 Topic</h2><p>在发送和消费消息之前，我们先来创建 Topic 。我们可以使用 <code>bin/kafka-topics.sh</code> 脚本，来进行 Kafka Topic 的管理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建名字为 TestTopic 的 Topic 。 </span><br><span class="line"># @param replication-factor 参数：Topic 副本数</span><br><span class="line"># @param partitions 参数：Topic 分区数</span><br><span class="line"># 关于两个参数的详细解释，可以看看 https://www.cnblogs.com/liuys635/p/10806665.html</span><br><span class="line">$ bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic TestTopic</span><br><span class="line"></span><br><span class="line"># 查询 Topic 列表</span><br><span class="line">$ bin/kafka-topics.sh --list --zookeeper 127.0.0.1:2181</span><br><span class="line">TestTopic</span><br></pre></td></tr></table></figure>



<h2 id="2-5-测试发送消息"><a href="#2-5-测试发送消息" class="headerlink" title="2.5 测试发送消息"></a>2.5 测试发送消息</h2><p>通过使用 <code>bin/kafka-console-producer.sh</code> 脚本，实现测试发送消息。命令行操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 执行 kafka-console-producer.sh 脚本，进入使用命令行发送消息的模式。</span><br><span class="line">$ bin/kafka-console-producer.sh --broker-list 127.0.0.1:9092 --topic TestTopic</span><br><span class="line"></span><br><span class="line"># 每输入一行，敲回车，都会发送一条消息</span><br><span class="line">&gt; yudaoyuanma</span><br><span class="line">&gt; nicai</span><br><span class="line">&gt; hahaha</span><br></pre></td></tr></table></figure>



<p>完成发送三条测试消息后，我们使用「command + C」终止当前脚本，退出。</p>
<h2 id="2-6-测试消费消息"><a href="#2-6-测试消费消息" class="headerlink" title="2.6 测试消费消息"></a>2.6 测试消费消息</h2><p>通过使用 <code>bin/kafka-console-consumer.sh</code> 脚本，实现测试消费消息。命令行操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 执行 kafka-console-consumer.sh 脚本，进入使用命令行消费消息</span><br><span class="line">$ bin/kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic TestTopic --from-beginning</span><br><span class="line"># 执行后，看到刚发送的三条消息，被成功消费，并打印在终端上。</span><br><span class="line">yudaoyuanma</span><br><span class="line">nicai</span><br><span class="line">hahaha</span><br></pre></td></tr></table></figure>



<p>至此，我们已经完成单机部署的 Kafka 的测试，舒服~</p>
<h1 id="3-集群部署"><a href="#3-集群部署" class="headerlink" title="3. 集群部署"></a>3. 集群部署</h1><p>咳咳咳，偷懒下。胖友可以先看艿艿朋友写的 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/yuliu/doc">《消息队列之 Kafka》</a> 文章的 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Kafka/install/?self#">「6. Kafka 集群配置」</a> 小节。</p>
<p>在生产环境下，必须搭建 Kafka 高可用集群，不然简直是找死。</p>
<h1 id="4-Kafka-Manager"><a href="#4-Kafka-Manager" class="headerlink" title="4. Kafka Manager"></a>4. Kafka Manager</h1><p><a target="_blank" rel="noopener" href="https://github.com/yahoo/kafka-manager">Kafka Manager</a> 是由 Yahoo 雅虎开源的 Kafka 管理工具。它支持如下功能：</p>
<blockquote>
<p>打开有道词典，一顿翻译。不过相信胖友，大体意思是能看的懂的。</p>
</blockquote>
<ul>
<li>Manage multiple clusters</li>
<li>Easy inspection of cluster state (topics, consumers, offsets, brokers, replica distribution, partition distribution)</li>
<li>Run preferred replica election</li>
<li>Generate partition assignments with option to select brokers to use</li>
<li>Run reassignment of partition (based on generated assignments)</li>
<li>Create a topic with optional topic configs (0.8.1.1 has different configs than 0.8.2+)</li>
<li>Delete topic (only supported on 0.8.2+ and remember set delete.topic.enable&#x3D;true in broker config)</li>
<li>Topic list now indicates topics marked for deletion (only supported on 0.8.2+)</li>
<li>Batch generate partition assignments for multiple topics with option to select brokers to use</li>
<li>Batch run reassignment of partition for multiple topics</li>
<li>Add partitions to existing topic</li>
<li>Update config for existing topic</li>
<li>Optionally enable JMX polling for broker level and topic level metrics.</li>
<li>Optionally filter out consumers that do not have ids&#x2F; owners&#x2F; &amp; offsets&#x2F; directories in zookeeper.</li>
</ul>
<p>下面，让我们来搭建一个 Kafka Manager 。</p>
<h2 id="4-1-下载软件包"><a href="#4-1-下载软件包" class="headerlink" title="4.1 下载软件包"></a>4.1 下载软件包</h2><p>Kafka Manager 在 <a target="_blank" rel="noopener" href="https://github.com/yahoo/kafka-manager/releases">Releases</a> 中，暂时只提供源码 Source 包，未提供编译好的二进制 Binary 包。</p>
<p>考虑到 Kafka Manager 需要使用 <a target="_blank" rel="noopener" href="https://www.scala-sbt.org/">sbt</a> 进行构造，所以我们就暂时不考虑编译源码的方式。而是，从热心“网友”提供的<a target="_blank" rel="noopener" href="https://blog.wolfogre.com/posts/kafka-manager-download/">Kafka Manager 安装包下载</a> ，美滋滋。这里，我们使用 Kafka Manager 2.0.0.2 版本。操作流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ 下载。可能很慢，可以考虑采用迅雷下载。</span><br><span class="line">$ wget https://github.com/wolfogre/kafka-manager-docker/releases/download/2.0.0.2/kafka-manager-2.0.0.2.zip</span><br><span class="line"></span><br><span class="line">$ 解压</span><br><span class="line">$ unzip kafka-manager-2.0.0.2.zip</span><br><span class="line"></span><br><span class="line"># 查看 Kafka Manager 软件包的目录</span><br><span class="line">$ cd kafka-manager-2.0.0.2</span><br><span class="line">$ ls -ls</span><br><span class="line">total 24</span><br><span class="line">24 -rw-r--r--@   1 yunai  staff  8686 Apr 11  2019 README.md</span><br><span class="line"> 0 drwxr-xr-x@  14 yunai  staff   448 Dec  5 23:17 bin #  执行脚本</span><br><span class="line"> 0 drwxr-xr-x@   7 yunai  staff   224 Dec  5 23:17 conf # 配置文件</span><br><span class="line"> 0 drwxr-xr-x@ 103 yunai  staff  3296 Dec  5 23:17 lib # Kafka Manager jar 包</span><br><span class="line"> 0 drwxr-xr-x@   3 yunai  staff    96 Dec  5 23:17 share</span><br></pre></td></tr></table></figure>



<h2 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h2><p>编辑 <code>conf/application.conf</code> 配置文件，修改配置项为 <code>kafka-manager.zkhosts=&quot;127.0.0.1:2181&quot;</code> 。此处，填写的是胖友的 ZooKeeper 地址。因为艿艿是本地启的 ZooKeeper 服务，所以填写了 <code>&quot;127.0.0.1:2181&quot;</code> 。</p>
<h2 id="4-3-启动-Kafka-Manager"><a href="#4-3-启动-Kafka-Manager" class="headerlink" title="4.3 启动 Kafka Manager"></a>4.3 启动 Kafka Manager</h2><p>启动一个 Kafka Manager 服务。命令行操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup bin/kafka-manager &amp;</span><br></pre></td></tr></table></figure>



<p>启动完成后，查看日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 Kafka Broker 日志。</span><br><span class="line">$ tail -f logs/application.log</span><br><span class="line"></span><br><span class="line">Application started (Prod)</span><br><span class="line"></span><br><span class="line">2019-12-07 23:32:17,845 - [INFO] - from play.core.server.AkkaHttpServer in main</span><br><span class="line">Listening for HTTP on /0:0:0:0:0:0:0:0:9000</span><br></pre></td></tr></table></figure>



<h2 id="4-4-添加-Kafka-集群"><a href="#4-4-添加-Kafka-集群" class="headerlink" title="4.4 添加 Kafka 集群"></a>4.4 添加 Kafka 集群</h2><p>使用浏览器，访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a> 地址，我们就可以看到 Kafka Manager 的界面。如下图：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Ff2878c5bde54b9f4d89f4b6c2d1887cd.jpeg" alt="Kafka Manager"></p>
<p>点击导航栏的「Cluster」按钮，选择「Add Cluster」选项，进入 <a target="_blank" rel="noopener" href="http://127.0.0.1:9000/addCluster">http://127.0.0.1:9000/addCluster</a> 地址。在该界面，我们配置新增 Kafka 集群。如下图：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Ffa85164b2464857418fc15ff5d41933a.jpeg" alt="Kafka Manager"></p>
<p>填写完成后，拉到表单最底部，点击「Save」按钮，保存 Kafka 集群。保存成功后，我们重新访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a> 地址，就可以看到我们新添加的 Kafka 集群。如下图：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Ffc8e549c1646eee8abbb9eaab5350de5.jpeg" alt="Kafka Manager"></p>
<p>点击「test」Kafka 集群，我们就可以管理该 Kafka 集群。如下图：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F71702acc8401cb0451649a4521e8a950.jpeg" alt="Kafka Manager"></p>
<p>具体的功能，胖友可以自己多多体验，艿艿就不啰嗦赘述了。</p>
<h1 id="5-简单示例"><a href="#5-简单示例" class="headerlink" title="5. 简单示例"></a>5. 简单示例</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-native/">lab-03-kafka-native</a> 。</p>
</blockquote>
<p>本小节，我们来看看在 Java 中，如何使用生产者 Producer 发送消息，和消费者 Consumer 消费消息。</p>
<h2 id="5-1-引入依赖"><a href="#5-1-引入依赖" class="headerlink" title="5.1 引入依赖"></a>5.1 引入依赖</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-native/pom.xml"><code>pom.xml</code></a> 文件中，引入相关依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;lab-03-kafka-native&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- 引入 Kafka 客户端依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>



<p>具体每个依赖的作用，胖友自己认真看下艿艿添加的所有注释噢。</p>
<h2 id="5-2-ProducerMain"><a href="#5-2-ProducerMain" class="headerlink" title="5.2 ProducerMain"></a>5.2 ProducerMain</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-native/src/main/java/cn/iocoder/springboot/lab03/kafkademo/ProducerMain.java">ProducerMain</a> 类，使用 <a target="_blank" rel="noopener" href="https://github.com/apache/kafka/blob/master/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java">KafkaProducer</a> 发送消息。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// ProducerMain.java</span><br><span class="line"></span><br><span class="line">public class ProducerMain &#123;</span><br><span class="line"></span><br><span class="line">    private static Producer&lt;String, String&gt; createProducer() &#123;</span><br><span class="line">        // 设置 Producer 的属性</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092&quot;); // 设置 Broker 的地址</span><br><span class="line">        properties.put(&quot;acks&quot;, &quot;1&quot;); // 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span><br><span class="line">        properties.put(&quot;retries&quot;, 3); // 发送失败时，重试发送的次数</span><br><span class="line">//        properties.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">//        properties.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">//        properties.put(&quot;client.id&quot;, &quot;DemoProducer&quot;);</span><br><span class="line">//        properties.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">        properties.put(&quot;key.serializer&quot;, StringSerializer.class.getName()); // 消息的 key 的序列化方式</span><br><span class="line">        properties.put(&quot;value.serializer&quot;, StringSerializer.class.getName()); // 消息的 value 的序列化方式</span><br><span class="line"></span><br><span class="line">        // 创建 KafkaProducer 对象</span><br><span class="line">        // 因为我们消息的 key 和 value 都使用 String 类型，所以创建的 Producer 是 &lt;String, String&gt; 的泛型。</span><br><span class="line">        return new KafkaProducer&lt;&gt;(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        // 创建 KafkaProducer 对象</span><br><span class="line">        Producer&lt;String, String&gt; producer = createProducer();</span><br><span class="line"></span><br><span class="line">        // 创建消息。传入的三个参数，分别是 Topic ，消息的 key ，消息的 message 。</span><br><span class="line">        ProducerRecord&lt;String, String&gt; message = new ProducerRecord&lt;&gt;(&quot;TestTopic&quot;, &quot;key&quot;, &quot;yudaoyuanma&quot;);</span><br><span class="line"></span><br><span class="line">        // 同步发送消息</span><br><span class="line">        Future&lt;RecordMetadata&gt; sendResultFuture = producer.send(message);</span><br><span class="line">        RecordMetadata result = sendResultFuture.get();</span><br><span class="line">        System.out.println(&quot;message sent to &quot; + result.topic() + &quot;, partition &quot; + result.partition() + &quot;, offset &quot; + result.offset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>代码比较简单，胖友根据艿艿添加的注释，理解下哈。</li>
</ul>
<p>执行 <code>#main(args)</code> 方法，发送消息到 Kafka 。执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message sent to TestTopic, partition 0, offset 8</span><br></pre></td></tr></table></figure>



<ul>
<li>发送消息成功。</li>
</ul>
<h2 id="5-3-ConsumerMain"><a href="#5-3-ConsumerMain" class="headerlink" title="5.3 ConsumerMain"></a>5.3 ConsumerMain</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-native/src/main/java/cn/iocoder/springboot/lab03/kafkademo/ConsumerMain.java">ConsumerMain</a> 类，使用 <a target="_blank" rel="noopener" href="https://github.com/apache/kafka/blob/master/clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java">KafkaConsumer</a> 消费消息。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// ConsumerMain.java</span><br><span class="line"></span><br><span class="line">public class ConsumerMain &#123;</span><br><span class="line"></span><br><span class="line">    private static Consumer&lt;String, String&gt; createConsumer() &#123;</span><br><span class="line">        // 设置 Producer 的属性</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092&quot;); // 设置 Broker 的地址</span><br><span class="line">        properties.put(&quot;group.id&quot;, &quot;demo-consumer-group&quot;); // 消费者分组</span><br><span class="line">        properties.put(&quot;auto.offset.reset&quot;, &quot;earliest&quot;); // 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span><br><span class="line">        properties.put(&quot;enable.auto.commit&quot;, true); // 是否自动提交消费进度</span><br><span class="line">        properties.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;); // 自动提交消费进度频率</span><br><span class="line">        properties.put(&quot;key.deserializer&quot;, StringDeserializer.class.getName()); // 消息的 key 的反序列化方式</span><br><span class="line">        properties.put(&quot;value.deserializer&quot;, StringDeserializer.class.getName()); // 消息的 value 的反序列化方式</span><br><span class="line"></span><br><span class="line">        // 创建 KafkaProducer 对象</span><br><span class="line">        // 因为我们消息的 key 和 value 都使用 String 类型，所以创建的 Producer 是 &lt;String, String&gt; 的泛型。</span><br><span class="line">        return new KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建 KafkaConsumer 对象</span><br><span class="line">        Consumer&lt;String, String&gt; consumer = createConsumer();</span><br><span class="line"></span><br><span class="line">        // 订阅消息</span><br><span class="line">        consumer.subscribe(Collections.singleton(&quot;TestTopic&quot;));</span><br><span class="line"></span><br><span class="line">        // 拉取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 拉取消息。如果拉取不到消息，阻塞等待最多 10 秒，或者等待拉取到消息。</span><br><span class="line">            ConsumerRecords records = consumer.poll(Duration.ofSeconds(10));</span><br><span class="line">            // 遍历处理消息</span><br><span class="line">            records.forEach(new java.util.function.Consumer&lt;ConsumerRecord&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void accept(ConsumerRecord record) &#123;</span><br><span class="line">                    System.out.println(record.key() + &quot;\t&quot; + record.value());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>代码比较简单，胖友根据艿艿添加的注释，理解下哈。</li>
</ul>
<p>执行 <code>#main(args)</code> 方法，从 Kafka 消费消息。执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">null	123</span><br><span class="line">null	fsf</span><br><span class="line">null	123</span><br><span class="line">null	123</span><br><span class="line">null	nicai</span><br><span class="line">null	1232321</span><br><span class="line">null	3213231</span><br><span class="line">key	yudaoyuanma</span><br><span class="line">key	yudaoyuanma</span><br></pre></td></tr></table></figure>



<ul>
<li>😈 有一部分消息是艿艿之前做测试发的，可以忽略哈。此时，我们已经成功消费。</li>
</ul>
<h1 id="——–-2"><a href="#——–-2" class="headerlink" title="——–"></a>——–</h1><h1 id="SpringBoot中的Kafka"><a href="#SpringBoot中的Kafka" class="headerlink" title="SpringBoot中的Kafka"></a>SpringBoot中的Kafka</h1><h1 id="——–-3"><a href="#——–-3" class="headerlink" title="——–"></a>——–</h1><blockquote>
<p>本文在提供完整代码示例，可见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs">https://github.com/YunaiV/SpringBoot-Labs</a> 的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka">lab-03-kafka</a> 目录。</p>
<p>原创不易，给点个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/stargazers">Star</a> 嘿，一起冲鸭！</p>
</blockquote>
<h1 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>如果胖友还没了解过分布式消息队列 <a target="_blank" rel="noopener" href="https://kafka.apache.org/">Apache Kafka</a> ，建议先阅读下艿艿写的 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/install/?self">《芋道 Kafka 极简入门》</a> 文章。虽然这篇文章标题是安装部署，实际可以理解成《一文带你快速入门 Kafka》，哈哈哈。</p>
<p>考虑这是 Kafka 如何在 Spring Boot 整合与使用的文章，所以还是简单介绍下 Kafka 是什么？</p>
<blockquote>
<p>FROM <a target="_blank" rel="noopener" href="https://www.oschina.net/p/kafka">《分布式发布订阅消息系统 Kafka》</a></p>
<p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，她有如下特性：</p>
<ul>
<li>通过 O(1) 的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li>
<li>高吞吐量：即使是非常普通的硬件kafka也可以支持每秒数十万的消息。</li>
<li>支持通过 Kafka 服务器和消费机集群来分区消息。</li>
</ul>
</blockquote>
<p>在本文中，我们会比 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/install/?self">《芋道 Kafka 极简入门》</a> 提供更多的生产者 Producer 和消费者 Consumer 的使用示例。例如说：</p>
<ul>
<li>Producer 三种发送消息的方式。</li>
<li>Producer 发送<strong>顺序</strong>消息，Consumer <strong>顺序</strong>消费消息。</li>
<li>Producer 发送<strong>定时</strong>消息。（暂不支持）</li>
<li>Producer <strong>批量</strong>发送消息。</li>
<li>Producer 发送<strong>事务</strong>消息。</li>
<li>Consumer <strong>批量</strong>消费消息。</li>
<li>Consumer <strong>广播</strong>和<strong>集群</strong>消费消息。</li>
</ul>
<p>胖友你就说，艿艿是不是很良心。😜</p>
<h1 id="2-Spring-Kafka"><a href="#2-Spring-Kafka" class="headerlink" title="2. Spring-Kafka"></a>2. Spring-Kafka</h1><p>在 Spring 生态中，提供了 <a target="_blank" rel="noopener" href="https://spring.io/projects/spring-kafka">Spring-Kafka</a> 项目，让我们更简便的使用 Kafka 。其官网介绍如下：</p>
<blockquote>
<p>The Spring for Apache Kafka (spring-kafka) project applies core Spring concepts to the development of Kafka-based messaging solutions.<br>Spring for Apache Kafka (spring-kafka) 项目将 Spring 核心概念应用于基于 Kafka 的消息传递解决方案的开发。</p>
<p>It provides a “template” as a high-level abstraction for sending messages.<br>它提供了一个“模板”作为发送消息的高级抽象。</p>
<p>It also provides support for Message-driven POJOs with @KafkaListener annotations and a “listener container”.<br>它还通过 @KafkaListener 注解和“侦听器容器(listener container)”为消息驱动的 POJO 提供支持。</p>
<p>These libraries promote the use of dependency injection and declarative.<br>这些库促进了依赖注入和声明的使用。</p>
<p>In all of these cases, you will see similarities to the JMS support in the Spring Framework and RabbitMQ support in Spring AMQP.<br>在所有这些用例中，你将看到 Spring Framework 中的 JMS 支持，以及和 Spring AMQP 中的 RabbitMQ 支持的相似之处。</p>
</blockquote>
<ul>
<li>😈 注意，Spring-Kafka 是基于 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-messaging/src/main/java/org/springframework/messaging">Spring Message</a> 来实现 Kafka 的发送端和接收端。</li>
</ul>
<blockquote>
<p>Features(功能特性)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/core/KafkaTemplate.java">KafkaTemplate</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/KafkaMessageListenerContainer.java">KafkaMessageListenerContainer</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/annotation/KafkaListener.java">@KafkaListener</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/transaction/KafkaTransactionManager.java">KafkaTransactionManager</a></li>
<li><code>spring-kafka-test</code> jar with embedded kafka server(带嵌入式 Kafka 服务器的 <code>spring-kafka-test</code> jar 包)</li>
</ul>
</blockquote>
<h1 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo">lab-31-kafka-demo</a> 。</p>
</blockquote>
<p>本小节，我们先来对 Kafka-Spring 做一个快速入门，实现 Producer 三种发送消息的方式的功能，同时创建一个 Consumer 消费消息。</p>
<p>考虑到一个应用既可以使用生产者 Producer ，又可以使用消费者 Consumer ，所以示例就做成一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo">lab-31-kafka-demo</a> 项目。</p>
<h2 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/pom.xml"><code>pom.xml</code></a> 文件中，引入相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lab-03-kafka-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 Spring-Kafka 依赖 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 已经内置 kafka-clients 依赖，所以无需重复引入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 实现对 JSON 的自动化配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 因为，Kafka 对复杂对象的 Message 序列化时，我们会使用到 JSON --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            同时，spring-boot-starter-json 引入了 spring-boot-starter ，而 spring-boot-starter 又引入了 spring-boot-autoconfigure 。</span></span><br><span class="line"><span class="comment">            spring-boot-autoconfigure 实现了 Spring-Kafka 的自动化配置</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 方便等会写单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>具体每个依赖的作用，胖友自己认真看下艿艿添加的所有注释噢。</li>
<li>不过有点很奇怪的是，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot">Spring Boot</a> 已经提供了 Kafka 的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka">自动化配置</a>的支持，但是竟然没有提供 spring-boot-kafka-starter 包，有点神奇~</li>
</ul>
<h2 id="3-2-应用配置文件"><a href="#3-2-应用配置文件" class="headerlink" title="3.2 应用配置文件"></a>3.2 应用配置文件</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/resources"><code>resources</code></a> 目录下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">    <span class="comment"># Kafka Producer 配置项</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span> <span class="comment"># 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span> <span class="comment"># 发送失败时，重试发送的次数</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span> <span class="comment"># 消息的 key 的序列化</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span> <span class="comment"># 消息的 value 的序列化</span></span><br><span class="line">    <span class="comment"># Kafka Consumer 配置项</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span> <span class="comment"># 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">spring:</span></span><br><span class="line">          <span class="attr">json:</span></span><br><span class="line">            <span class="attr">trusted:</span></span><br><span class="line">              <span class="attr">packages:</span> <span class="string">cn.iocoder.springboot.lab03.kafkademo.message</span></span><br><span class="line">    <span class="comment"># Kafka Consumer Listener 监听器配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">missing-topics-fatal:</span> <span class="literal">false</span> <span class="comment"># 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># spring-kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br><span class="line">      <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>在 <code>spring.kafka</code> 配置项，设置 Kafka 的配置，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java">KafkaProperties</a> 配置类。</p>
</li>
<li><p>Spring Boot 提供的 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaAutoConfiguration.java">KafkaAutoConfiguration</a> 自动化配置类，实现 Kafka 的自动配置，创建相应的 Producer 和 Consumer 。</p>
</li>
<li><p><code>spring.kafka.bootstrap-servers</code> 配置项，设置 Kafka Broker 地址。如果多个，使用逗号分隔。</p>
</li>
<li><pre><code class="yaml">spring.kafka.producer
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  配置项，一看就知道是 Kafka Producer 所独有。</span><br><span class="line"></span><br><span class="line">  - `value-serializer` 配置，我们使用了 Spring-Kafka 提供的 [JsonSerializer](https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/support/serializer/JsonSerializer.java) 序列化类，因为稍后我们要使用 JSON 的方式，序列化复杂的 Message 消息。</span><br><span class="line">  - 其它配置，一般默认即可。</span><br><span class="line"></span><br><span class="line">- ```yaml</span><br><span class="line">  spring.kafka.consumer</span><br></pre></td></tr></table></figure>

 

配置项，一看就知道是 Kafka Consumer 所独有。

- `value-serializer` 配置，我们使用了 Spring-Kafka 提供的 [JsonDeserializer](https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/support/serializer/JsonDeserializer.java) 反序列化类，因为稍后我们要使用 JSON 的方式，反序列化复杂的 Message 消息。
- `properties.spring.json.trusted.packages` 配置，配置信任 [`cn.iocoder.springboot.lab03.kafkademo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message) 包下的 Message 类们。因为 JsonDeserializer 在反序列化消息时，考虑到安全性，只反序列化成信任的 Message 类。😈 想要尝试下效果的胖友，可以选择去掉这个配置，很酸爽。
</code></pre>
</li>
</ul>
<h2 id="3-3-Application"><a href="#3-3-Application" class="headerlink" title="3.3 Application"></a>3.3 Application</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/Application.java"><code>Application.java</code></a> 类，配置 <code>@SpringBootApplication</code> 注解即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-Demo01Message"><a href="#3-4-Demo01Message" class="headerlink" title="3.4 Demo01Message"></a>3.4 Demo01Message</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message"><code>cn.iocoder.springboot.lab03.kafkademo.message</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message/Demo01Message.java">Demo01Message</a> 消息类，提供给当前示例使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Message.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;DEMO_01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 set/get/toString 方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>TOPIC</code> 静态属性，我们设置该消息类对应 Topic 为 <code>&quot;DEMO_01&quot;</code> 。</li>
</ul>
<h2 id="3-5-Demo01Producer"><a href="#3-5-Demo01Producer" class="headerlink" title="3.5 Demo01Producer"></a>3.5 Demo01Producer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo01Producer.java">Demo01Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，实现三种发送消息的方式。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">syncSend</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo01Message 消息</span></span><br><span class="line">        <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 同步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo01Message.TOPIC, message).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;SendResult&lt;Object, Object&gt;&gt; <span class="title function_">asyncSend</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo01Message 消息</span></span><br><span class="line">        <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo01Message.TOPIC, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>#asyncSend(...)</code> 方法，<strong>异步</strong>发送消息。在方法内部，会调用 <code>KafkaTemplate#send(topic, data)</code> 方法，<strong>异步</strong>发送消息，返回 Spring <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/concurrent/ListenableFuture.java">ListenableFuture</a> 对象，一个可以通过监听执行结果的 Future 增强。</li>
<li><code>#syncSend(...)</code> 方法，<strong>同步</strong>发送消息。在方法内部，也是调用 <code>KafkaTemplate#send(topic, data)</code> 方法，<strong>异步</strong>发送消息。不过，因为我们后面调用了 ListenableFuture 对象的 <code>#get()</code> 方法，阻塞等待发送结果，从而实现同步的效果。</li>
<li>暂时未提供 <strong>oneway</strong> 发送消息的方式。因为需要配置 Producer 的 <code>acks = 0</code> ，才可以使用这种发送方式。😈 当然，实际场景下，基本不会使用 <strong>oneway</strong> 的方式来发送消息，所以直接先忽略吧。</li>
</ul>
<p>对于胖友来说，可能最关心的是，消息 Message 是怎么序列化的。</p>
<ul>
<li>在序列化时，我们使用了 JsonSerializer 序列化 Message 消息对象，它会在 Kafka 消息 <a target="_blank" rel="noopener" href="https://kafka.apache.org/0110/javadoc/index.html?org/apache/kafka/common/header/Headers.html">Headers</a> 的 <code>__TypeId__</code> 上，值为 Message 消息对应的<strong>类全名</strong>。</li>
<li>在反序列化时，我们使用了 JsonDeserializer 序列化出 Message 消息对象，它会根据 Kafka 消息 <a target="_blank" rel="noopener" href="https://kafka.apache.org/0110/javadoc/index.html?org/apache/kafka/common/header/Headers.html">Headers</a> 的 <code>__TypeId__</code> 的值，反序列化消息内容成该 Message 对象。</li>
</ul>
<h2 id="3-6-Demo01Consumer"><a href="#3-6-Demo01Consumer" class="headerlink" title="3.6 Demo01Consumer"></a>3.6 Demo01Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo01Consumer.java">Demo01Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo01Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo01-consumer-group-&quot; + Demo01Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo01Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在方法上，添加了 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/annotation/KafkaListener.java"><code>@KafkaListener</code></a> 注解，声明消费的 Topic 是 <code>&quot;DEMO_01&quot;</code> ，消费者分组是 <code>&quot;demo01-consumer-group-DEMO_01&quot;</code> 。一般情况下，我们建议一个消费者分组，仅消费一个 Topic 。这样做会有个好处：每个消费者分组职责单一，只消费一个 Topic 。</li>
<li>方法参数，使用消费 Topic 对应的消息类即可。这里，我们使用了 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.4 Demo01Message」</a> 。</li>
<li>虽然说，<code>@KafkaListener</code> 注解是方法级别的，艿艿还是建议一个类，对应一个方法，消费消息。😈 简单清晰~</li>
</ul>
<h2 id="3-7-Demo01AConsumer"><a href="#3-7-Demo01AConsumer" class="headerlink" title="3.7 Demo01AConsumer"></a>3.7 Demo01AConsumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo01AConsumer.java">Demo01AConsumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01AConsumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01AConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo01Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo01-A-consumer-group-&quot; + Demo01Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(ConsumerRecord&lt;Integer, String&gt; record)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), record);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>整体和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.6 Demo01Consumer」</a> 是一致的，主要有两个差异点，也是为什么我们又额外创建了这个消费者的原因。</li>
</ul>
<p><strong>差异一</strong>，在方法上，添加了 <code>@KafkaListener</code> 注解，声明消费的 Topic <strong>还是</strong> <code>&quot;DEMO_01&quot;</code> ，消费者分组修<strong>改成</strong>了 <code>&quot;demo01-A-consumer-group-DEMO_01&quot;</code> 。这样，我们就可以测试 Kafka 集群消费的特性。</p>
<blockquote>
<p>集群消费（Clustering）：集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊消息。</p>
</blockquote>
<ul>
<li>也就是说，如果我们发送一条 Topic 为 <code>&quot;DEMO_01&quot;</code> 的消息，可以分别被 <code>&quot;demo01-A-consumer-group-DEMO_01&quot;</code> 和 <code>&quot;demo01-consumer-group-DEMO_01&quot;</code> 都消费一次。</li>
<li>但是，如果我们启动两个该示例的实例，则消费者分组 <code>&quot;demo01-A-consumer-group-DEMO_01&quot;</code> 和 <code>&quot;demo01-consumer-group-DEMO_01&quot;</code> 都会有多个 Consumer 示例。此时，我们再发送一条 Topic 为 <code>&quot;DEMO_01&quot;</code> 的消息，只会被 <code>&quot;demo01-A-consumer-group-DEMO_01&quot;</code> 的一个 Consumer 消费一次，也同样只会被 <code>&quot;demo01-A-consumer-group-DEMO_01&quot;</code> 的一个 Consumer 消费一次。</li>
</ul>
<p>好好理解上述的两段话，非常重要。</p>
<p>通过<strong>集群消费</strong>的机制，我们可以实现针对相同 Topic ，不同消费者分组实现各自的业务逻辑。例如说：用户注册成功时，发送一条 Topic 为 <code>&quot;USER_REGISTER&quot;</code> 的消息。然后，不同模块使用不同的消费者分组，订阅该 Topic ，实现各自的拓展逻辑：</p>
<ul>
<li>积分模块：判断如果是手机注册，给用户增加 20 积分。</li>
<li>优惠劵模块：因为是新用户，所以发放新用户专享优惠劵。</li>
<li>站内信模块：因为是新用户，所以发送新用户的欢迎语的站内信。</li>
<li>… 等等</li>
</ul>
<p>这样，我们就可以将注册成功后的业务拓展逻辑，实现业务上的解耦，未来也更加容易拓展。同时，也提高了注册接口的性能，避免用户需要等待业务拓展逻辑执行完成后，才响应注册成功。</p>
<p><strong>差异二</strong>，方法参数，设置消费的消息对应的类不是 Demo01Message 类，而是 Kafka 内置的 <a target="_blank" rel="noopener" href="https://github.com/axbaretto/kafka/blob/master/clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerRecord.java">ConsumerRecord</a> 类。通过 ConsumerRecord 类，我们可以获取到消费的消息的更多信息，例如说消息的所属队列、创建时间等等属性，不过消息的内容(<code>value</code>)就需要自己去反序列化。当然，一般情况下，我们不会使用 ConsumerRecord 类。</p>
<h2 id="3-8-简单测试"><a href="#3-8-简单测试" class="headerlink" title="3.8 简单测试"></a>3.8 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo01ProducerTest.java">Demo01ProducerTest</a> 测试类，编写二个单元测试方法，调用 Demo01Producer 二个发送消息的方式。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo01Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSend</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.syncSend(id);</span><br><span class="line">        logger.info(<span class="string">&quot;[testSyncSend][发送编号：[&#123;&#125;] 发送结果：[&#123;&#125;]]&quot;</span>, id, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testASyncSend</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        producer.asyncSend(id).addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;Object, Object&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;[testASyncSend][发送编号：[&#123;&#125;] 发送异常]]&quot;</span>, id, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;Object, Object&gt; result)</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;[testASyncSend][发送编号：[&#123;&#125;] 发送成功，结果为：[&#123;&#125;]]&quot;</span>, id, result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>比较简单，胖友自己看下三个单元测试方法。</li>
</ul>
<p>我们来执行 <code>#testSyncSend()</code> 方法，测试同步发送消息。控制台输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Producer 同步发送消息成功。注意 __TypeId__</span><br><span class="line">2019-12-08 18:14:11.174  INFO 89529 --- [           main] c.i.s.l.k.producer.Demo01ProducerTest    : [testSyncSend][发送编号：[1575627250] 发送结果：[SendResult [producerRecord=ProducerRecord(topic=DEMO_01, partition=null, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [99, 110, 46, 105, 111, 99, 111, 100, 101, 114, 46, 115, 112, 114, 105, 110, 103, 98, 111, 111, 116, 46, 108, 97, 98, 48, 51, 46, 107, 97, 102, 107, 97, 100, 101, 109, 111, 46, 109, 101, 115, 115, 97, 103, 101, 46, 68, 101, 109, 111, 48, 49, 77, 101, 115, 115, 97, 103, 101])], isReadOnly = true), key=null, value=Demo01Message&#123;id=1575627250&#125;, timestamp=null), recordMetadata=DEMO_01-0@0]]]</span><br><span class="line"></span><br><span class="line"># Demo01AConsumer 消费了一次该消息</span><br><span class="line">2019-12-08 18:14:11.217  INFO 89529 --- [ntainer#0-0-C-1] c.i.s.l.k.consumer.Demo01AConsumer       : [onMessage][线程编号:16 消息内容：ConsumerRecord(topic = DEMO_01, partition = 0, leaderEpoch = 0, offset = 0, CreateTime = 1575627251158, serialized key size = -1, serialized value size = 17, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = Demo01Message&#123;id=1575627250&#125;)]</span><br><span class="line"></span><br><span class="line"># Demo01Consumer 消费了一次该消息</span><br><span class="line">2019-12-08 18:14:11.220  INFO 89529 --- [ntainer#1-0-C-1] c.i.s.l.k.consumer.Demo01Consumer        : [onMessage][线程编号:18 消息内容：Demo01Message&#123;id=1575627250&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>通过日志我们可以看到，我们发送的消息，分别被 Demo01AConsumer 和 Demo01Consumer 两个消费者（消费者分组）都消费了一次。</li>
<li>同时，两个消费者在不同的线程中，消费了这条消息。</li>
</ul>
<p>我们来执行 <code>#testASyncSend()</code> 方法，测试异步发送消息。控制台输出如下：</p>
<blockquote>
<p>友情提示：注意，不要关闭 <code>#testSyncSend()</code> 单元测试方法，因为我们要模拟每个消费者集群，都有多个 Consumer 节点。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Producer 异步发送消息成功</span><br><span class="line">2019-12-08 18:20:34.096  INFO 89818 --- [ad | producer-1] c.i.s.l.k.producer.Demo01ProducerTest    : [testASyncSend][发送编号：[1575627633] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_01, partition=null, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [99, 110, 46, 105, 111, 99, 111, 100, 101, 114, 46, 115, 112, 114, 105, 110, 103, 98, 111, 111, 116, 46, 108, 97, 98, 48, 51, 46, 107, 97, 102, 107, 97, 100, 101, 109, 111, 46, 109, 101, 115, 115, 97, 103, 101, 46, 68, 101, 109, 111, 48, 49, 77, 101, 115, 115, 97, 103, 101])], isReadOnly = true), key=null, value=Demo01Message&#123;id=1575627633&#125;, timestamp=null), recordMetadata=DEMO_01-0@2]]]</span><br><span class="line"></span><br><span class="line"># Demo01AConsumer 消费了一次该消息</span><br><span class="line">2019-12-08 18:20:34.139  INFO 89818 --- [ntainer#0-0-C-1] c.i.s.l.k.consumer.Demo01AConsumer       : [onMessage][线程编号:16 消息内容：ConsumerRecord(topic = DEMO_01, partition = 0, leaderEpoch = 0, offset = 2, CreateTime = 1575627634079, serialized key size = -1, serialized value size = 17, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = Demo01Message&#123;id=1575627633&#125;)</span><br><span class="line"></span><br><span class="line"># Demo01Consumer 消费了一次该消息</span><br><span class="line">2019-12-08 18:20:34.142  INFO 89818 --- [ntainer#1-0-C-1] c.i.s.l.k.consumer.Demo01Consumer        : [onMessage][线程编号:18 消息内容：Demo01Message&#123;id=1575627633&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>和 <code>#testSyncSend()</code> 方法执行的结果，是一致的。此时，我们打开 <code>#testSyncSend()</code> 方法所在的控制台，不会看到有消息消费的日志。说明，符合集群消费的机制：<strong>集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊消息。</strong>。</li>
<li>😈 不过如上的日志，也可能出现在 <code>#testSyncSend()</code> 方法所在的控制台，而不在 <code>#testASyncSend()</code> 方法所在的控制台。</li>
</ul>
<h2 id="3-9-KafkaListener"><a href="#3-9-KafkaListener" class="headerlink" title="3.9 @KafkaListener"></a>3.9 @KafkaListener</h2><p>在 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.6 Demo01Consumer」</a> 中，我们已经使用了 <code>@KafkaListener</code> 注解，设置每个 Kafka 消费者 Consumer 的消息监听器的配置。</p>
<p><code>@KafkaListener</code> 注解的<strong>常用</strong>属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听的 Topic 数组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The topics for this listener.</span></span><br><span class="line"><span class="comment"> * The entries can be &#x27;topic name&#x27;, &#x27;property-placeholder keys&#x27; or &#x27;expressions&#x27;.</span></span><br><span class="line"><span class="comment"> * An expression must be resolved to the topic name.</span></span><br><span class="line"><span class="comment"> * This uses group management and Kafka will assign partitions to group members.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Mutually exclusive with &#123;<span class="doctag">@link</span> #topicPattern()&#125; and &#123;<span class="doctag">@link</span> #topicPartitions()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the topic names or expressions (SpEL) to listen to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] topics() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听的 Topic 表达式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The topic pattern for this listener. The entries can be &#x27;topic pattern&#x27;, a</span></span><br><span class="line"><span class="comment"> * &#x27;property-placeholder key&#x27; or an &#x27;expression&#x27;. The framework will create a</span></span><br><span class="line"><span class="comment"> * container that subscribes to all topics matching the specified pattern to get</span></span><br><span class="line"><span class="comment"> * dynamically assigned partitions. The pattern matching will be performed</span></span><br><span class="line"><span class="comment"> * periodically against topics existing at the time of check. An expression must</span></span><br><span class="line"><span class="comment"> * be resolved to the topic pattern (String or Pattern result types are supported).</span></span><br><span class="line"><span class="comment"> * This uses group management and Kafka will assign partitions to group members.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Mutually exclusive with &#123;<span class="doctag">@link</span> #topics()&#125; and &#123;<span class="doctag">@link</span> #topicPartitions()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the topic pattern or expression (SpEL).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.kafka.clients.CommonClientConfigs#METADATA_MAX_AGE_CONFIG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">topicPattern</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@TopicPartition</span> 注解的数组。每个 <span class="doctag">@TopicPartition</span> 注解，可配置监听的 Topic、队列、消费的开始位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The topicPartitions for this listener when using manual topic/partition</span></span><br><span class="line"><span class="comment"> * assignment.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Mutually exclusive with &#123;<span class="doctag">@link</span> #topicPattern()&#125; and &#123;<span class="doctag">@link</span> #topics()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the topic names or expressions (SpEL) to listen to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TopicPartition[] topicPartitions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者分组</span></span><br><span class="line"><span class="comment"> * Override the &#123;<span class="doctag">@code</span> group.id&#125; property for the consumer factory with this value</span></span><br><span class="line"><span class="comment"> * for this listener only.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;SpEL &#123;<span class="doctag">@code</span> #&#123;...&#125;&#125; and property place holders &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; are supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the group id.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">groupId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用消费异常处理器 KafkaListenerErrorHandler 的 Bean 名字</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Set an &#123;<span class="doctag">@link</span> org.springframework.kafka.listener.KafkaListenerErrorHandler&#125; bean</span></span><br><span class="line"><span class="comment"> * name to invoke if the listener method throws an exception.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the error handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">errorHandler</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义消费者监听器的并发数，这个我们在 TODO 详细解析。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Override the container factory&#x27;s &#123;<span class="doctag">@code</span> concurrency&#125; setting for this listener. May</span></span><br><span class="line"><span class="comment"> * be a property placeholder or SpEL expression that evaluates to a &#123;<span class="doctag">@link</span> Number&#125;, in</span></span><br><span class="line"><span class="comment"> * which case &#123;<span class="doctag">@link</span> Number#intValue()&#125; is used to obtain the value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;SpEL &#123;<span class="doctag">@code</span> #&#123;...&#125;&#125; and property place holders &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; are supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the concurrency.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">concurrency</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否自动启动监听器。默认情况下，为 true 自动启动。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * Set to true or false, to override the default setting in the container factory. May</span></span><br><span class="line"><span class="comment"> * be a property placeholder or SpEL expression that evaluates to a &#123;<span class="doctag">@link</span> Boolean&#125; or</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> String&#125;, in which case the &#123;<span class="doctag">@link</span> Boolean#parseBoolean(String)&#125; is used to</span></span><br><span class="line"><span class="comment"> * obtain the value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;SpEL &#123;<span class="doctag">@code</span> #&#123;...&#125;&#125; and property place holders &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; are supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true to auto start, false to not auto start.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">autoStartup</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kafka Consumer 拓展属性。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Kafka consumer properties; they will supersede any properties with the same name</span></span><br><span class="line"><span class="comment"> * defined in the consumer factory (if the consumer factory supports property overrides).</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Supported Syntax&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The supported syntax for key-value pairs is the same as the</span></span><br><span class="line"><span class="comment"> * syntax defined for entries in a Java</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> java.util.Properties#load(java.io.Reader) properties file&#125;:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> key=value&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> key:value&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> key value&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> group.id&#125; and &#123;<span class="doctag">@code</span> client.id&#125; are ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the properties.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.kafka.clients.consumer.ConsumerConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #groupId()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #clientIdPrefix()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>



<p><code>@KafkaListener</code> 注解的<strong>不常用</strong>属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唯一标识</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * The unique identifier of the container managing for this endpoint.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If none is specified an auto-generated one is provided.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: When provided, this value will override the group id property</span></span><br><span class="line"><span class="comment"> * in the consumer factory configuration, unless &#123;<span class="doctag">@link</span> #idIsGroup()&#125;</span></span><br><span class="line"><span class="comment"> * is set to false.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;SpEL &#123;<span class="doctag">@code</span> #&#123;...&#125;&#125; and property place holders &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; are supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &#123;<span class="doctag">@code</span> id&#125; for the container managing for this endpoint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.kafka.config.KafkaListenerEndpointRegistry#getListenerContainer(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * id 唯一标识的前缀</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * When provided, overrides the client id property in the consumer factory</span></span><br><span class="line"><span class="comment"> * configuration. A suffix (&#x27;-n&#x27;) is added for each container instance to ensure</span></span><br><span class="line"><span class="comment"> * uniqueness when concurrency is used.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;SpEL &#123;<span class="doctag">@code</span> #&#123;...&#125;&#125; and property place holders &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; are supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the client id prefix.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">clientIdPrefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 groupId 未设置时，是否使用 id 作为 groupId</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * When &#123;<span class="doctag">@link</span> #groupId() groupId&#125; is not provided, use the &#123;<span class="doctag">@link</span> #id() id&#125; (if</span></span><br><span class="line"><span class="comment"> * provided) as the &#123;<span class="doctag">@code</span> group.id&#125; property for the consumer. Set to false, to use</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> group.id&#125; from the consumer factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false to disable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">idIsGroup</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用的 KafkaListenerContainerFactory Bean 的名字。</span></span><br><span class="line"><span class="comment"> * 若未设置，则使用默认的 KafkaListenerContainerFactory Bean 。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The bean name of the &#123;<span class="doctag">@link</span> org.springframework.kafka.config.KafkaListenerContainerFactory&#125;</span></span><br><span class="line"><span class="comment"> * to use to create the message listener container responsible to serve this endpoint.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If not specified, the default container factory is used, if any.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the container factory bean name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">containerFactory</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所属 MessageListenerContainer Bean 的名字。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If provided, the listener container for this listener will be added to a bean</span></span><br><span class="line"><span class="comment"> * with this value as its name, of type &#123;<span class="doctag">@code</span> Collection&lt;MessageListenerContainer&gt;&#125;.</span></span><br><span class="line"><span class="comment"> * This allows, for example, iteration over the collection to start/stop a subset</span></span><br><span class="line"><span class="comment"> * of containers.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;SpEL &#123;<span class="doctag">@code</span> #&#123;...&#125;&#125; and property place holders &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; are supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the bean name for the group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">containerGroup</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实监听容器的 Bean 名字，需要在名字前加 &quot;__&quot; 。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A pseudo bean name used in SpEL expressions within this annotation to reference</span></span><br><span class="line"><span class="comment"> * the current bean within which this listener is defined. This allows access to</span></span><br><span class="line"><span class="comment"> * properties and methods within the enclosing bean.</span></span><br><span class="line"><span class="comment"> * Default &#x27;__listener&#x27;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Example: &#123;<span class="doctag">@code</span> topics = &quot;#&#123;__listener.topicList&#125;&quot;&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the pseudo bean name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">beanRef</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;__listener&quot;</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/annotation/TopicPartition.java"><code>@TopicPartition</code></a> 注解</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/annotation/PartitionOffset.java"><code>@PartitionOffset</code></a> 注解</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/annotation/KafkaListeners.java"><code>@KafkaListeners</code></a> 注解，允许我们在其中，同时添加多个 <code>@KafkaListener</code> 注解。</li>
</ul>
<h1 id="4-批量发送消息"><a href="#4-批量发送消息" class="headerlink" title="4. 批量发送消息"></a>4. 批量发送消息</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch">lab-03-kafka-demo-batch</a> 。</p>
</blockquote>
<p>在一些业务场景下，我们希望使用 Producer 批量发送消息，提高发送性能。不同于我们在<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self">《芋道 Spring Boot 消息队列 RocketMQ 入门》</a> 的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「4. 批量发送消息」</a> 功能，RocketMQ 是提供了一个可以批量发送多条消息的 API 。而 Kafka 提供的批量发送消息，它提供了一个 <a target="_blank" rel="noopener" href="http://people.apache.org/~nehanarkhede/kafka-0.9-producer-javadoc/doc/org/apache/kafka/clients/producer/internals/RecordAccumulator.html">RecordAccumulator</a> 消息收集器，将发送给相同 Topic 的相同 Partition 分区的消息们，“<strong>偷偷</strong>”收集在一起，当满足条件时候，一次性批量发送提交给 Kafka Broker 。如下是三个条件，满足<strong>任一</strong>即会批量发送：</p>
<ul>
<li>【数量】<code>batch-size</code> ：超过收集的消息数量的最大条数。</li>
<li>【空间】<code>buffer-memory</code> ：超过收集的消息占用的最大内存。</li>
<li>【时间】<code>linger.ms</code> ：超过收集的时间的最大等待时长，单位：毫秒。</li>
</ul>
<p>下面，我们来实现一个 Producer 批量发送消息的示例。考虑到不污染<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3. 快速入门」</a> 的示例，我们新建一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch">lab-03-kafka-demo-batch</a> 项目。</p>
<h2 id="4-1-引入依赖"><a href="#4-1-引入依赖" class="headerlink" title="4.1 引入依赖"></a>4.1 引入依赖</h2><p>和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">3.1 引入依赖」</a> 一致，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch/pom.xml"><code>pom.xml</code></a> 文件。</p>
<h2 id="4-2-应用配置文件"><a href="#4-2-应用配置文件" class="headerlink" title="4.2 应用配置文件"></a>4.2 应用配置文件</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/resources"><code>resources</code></a> 目录下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">    <span class="comment"># Kafka Producer 配置项</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span> <span class="comment"># 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span> <span class="comment"># 发送失败时，重试发送的次数</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span> <span class="comment"># 消息的 key 的序列化</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span> <span class="comment"># 消息的 value 的序列化</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span> <span class="comment"># 每次批量发送消息的最大数量</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span> <span class="comment"># 每次批量发送消息的最大内存</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">linger:</span></span><br><span class="line">          <span class="attr">ms:</span> <span class="number">30000</span> <span class="comment"># 批处理延迟时间上限。这里配置为 30 * 1000 ms 过后，不管是否消息数量是否到达 batch-size 或者消息大小到达 buffer-memory 后，都直接发送一次请求。</span></span><br><span class="line">    <span class="comment"># Kafka Consumer 配置项</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span> <span class="comment"># 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">spring:</span></span><br><span class="line">          <span class="attr">json:</span></span><br><span class="line">            <span class="attr">trusted:</span></span><br><span class="line">              <span class="attr">packages:</span> <span class="string">cn.iocoder.springboot.lab03.kafkademo.message</span></span><br><span class="line">    <span class="comment"># Kafka Consumer Listener 监听器配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">missing-topics-fatal:</span> <span class="literal">false</span> <span class="comment"># 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># spring-kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br><span class="line">      <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>相比</p>
<p>「3.2 应用配置文件」</p>
<p>来说，额外三个参数，就是我们说的 Producer 批量发送的三个条件：</p>
<ul>
<li><code>spring.kafka.producer.batch-size</code></li>
<li><code>spring.kafka.producer.buffer-memory</code></li>
<li><code>spring.kafka.producer.properties.linger.ms</code></li>
</ul>
</li>
<li><p>具体的数值配置多少，根据自己的应用来。这里，我们故意将 <code>linger.ms</code> 配置成了 30 秒，主要为了演示之用。</p>
</li>
</ul>
<h2 id="4-3-Demo02Message"><a href="#4-3-Demo02Message" class="headerlink" title="4.3 Demo02Message"></a>4.3 Demo02Message</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message"><code>cn.iocoder.springboot.lab03.kafkademo.message</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message/Demo02Message.java">Demo02Message</a> 消息类，提供给当前示例使用。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Demo02Message.java</span><br><span class="line"></span><br><span class="line">public class Demo02Message &#123;</span><br><span class="line"></span><br><span class="line">    public static final String TOPIC = &quot;DEMO_012&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 编号</span><br><span class="line">     */</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    // ... 省略 set/get/toString 方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>TOPIC</code> 静态属性，我们设置该消息类对应 Topic 为 <code>&quot;DEMO_02&quot;</code> 。</li>
<li>其它都和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.4 Demo01Message」</a> 是一样的。</li>
</ul>
<h2 id="4-4-Demo02Producer"><a href="#4-4-Demo02Producer" class="headerlink" title="4.4 Demo02Producer"></a>4.4 Demo02Producer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo02Producer.java">Demo02Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，实现一个异步发送消息的方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo02Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;SendResult&lt;Object, Object&gt;&gt; <span class="title function_">asyncSend</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo02Message 消息</span></span><br><span class="line">        <span class="type">Demo02Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo02Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo02Message.TOPIC, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>看起来和我们在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.5 Demo01Producer」</a>提供的异步发送消息的方法，除了换成了 Demo02Message 消息对象，其它都是一模一样的。😈 对的，这也是为什么艿艿在上文说到，Kafka 是“<strong>偷偷</strong>”收集来实现批量发送，对于我们使用发送消息的方法，还是一致的。</li>
<li>因为我们发送的消息 Topic 是自动创建的，所以其 Partition 分区大小是 <strong>1</strong> 。这样，就能保证我每次调用这个方法，满足批量发送消息的一个前提，<strong>相同 Topic 的相同 Partition 分区的消息们</strong>。</li>
</ul>
<h2 id="4-5-Demo02Consumer"><a href="#4-5-Demo02Consumer" class="headerlink" title="4.5 Demo02Consumer"></a>4.5 Demo02Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo02Consumer.java">Demo02Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo02Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo02Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo02-consumer-group-&quot; + Demo02Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo02Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.6 Demo01Consumer」</a>基本一直，除了是不同的消费者分组，消费了不同的 Topic 。</li>
</ul>
<h2 id="4-6-简单测试"><a href="#4-6-简单测试" class="headerlink" title="4.6 简单测试"></a>4.6 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo02ProducerTest.java">Demo02ProducerTest</a> 测试类，编写单元测试方法，测试 Producer 批量发送消息的效果。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo02ProducerTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo02Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testASyncSend</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[testASyncSend][开始执行]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            producer.asyncSend(id).addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;SendResult&lt;Object, Object&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;[testASyncSend][发送编号：[&#123;&#125;] 发送异常]]&quot;</span>, id, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult&lt;Object, Object&gt; result)</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;[testASyncSend][发送编号：[&#123;&#125;] 发送成功，结果为：[&#123;&#125;]]&quot;</span>, id, result);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 故意每条消息之间，隔离 10 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>异步发送三条消息，每次发送消息之间，都故意 sleep 10 秒。😈 目的是，恰好满足我们配置的 <code>linger.ms</code> 最大等待时长。</li>
</ul>
<p>我们来执行 <code>#testASyncSend()</code> 方法，测试批量发送消息。控制台输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 打印 testASyncSend 方法开始执行的日志</span><br><span class="line">2019-12-08 21:43:02.330  INFO 94957 --- [           main] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][开始执行]</span><br><span class="line"></span><br><span class="line"># 30 秒后，满足批量消息的最大等待时长，所以 3 条消息被 Producer 批量发送。</span><br><span class="line"># 因此我们配置的是 acks=1 ，需要等待发送成功后，才会回调 ListenableFutureCallback 的方法。</span><br><span class="line">2019-12-08 21:43:32.424  INFO 94957 --- [ad | producer-1] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][发送编号：[1575639782] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_02, partition=null, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [99, 110, 46, 105, 111, 99, 111, 100, 101, 114, 46, 115, 112, 114, 105, 110, 103, 98, 111, 111, 116, 46, 108, 97, 98, 48, 51, 46, 107, 97, 102, 107, 97, 100, 101, 109, 111, 46, 109, 101, 115, 115, 97, 103, 101, 46, 68, 101, 109, 111, 48, 50, 77, 101, 115, 115, 97, 103, 101])], isReadOnly = true), key=null, value=Demo01Message&#123;id=1575639782&#125;, timestamp=null), recordMetadata=DEMO_02-0@37]]]</span><br><span class="line">2019-12-08 21:43:32.425  INFO 94957 --- [ad | producer-1] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][发送编号：[1575639792] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_02, partition=null, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [99, 110, 46, 105, 111, 99, 111, 100, 101, 114, 46, 115, 112, 114, 105, 110, 103, 98, 111, 111, 116, 46, 108, 97, 98, 48, 51, 46, 107, 97, 102, 107, 97, 100, 101, 109, 111, 46, 109, 101, 115, 115, 97, 103, 101, 46, 68, 101, 109, 111, 48, 50, 77, 101, 115, 115, 97, 103, 101])], isReadOnly = true), key=null, value=Demo01Message&#123;id=1575639792&#125;, timestamp=null), recordMetadata=DEMO_02-0@38]]]</span><br><span class="line">2019-12-08 21:43:32.425  INFO 94957 --- [ad | producer-1] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][发送编号：[1575639802] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_02, partition=null, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [99, 110, 46, 105, 111, 99, 111, 100, 101, 114, 46, 115, 112, 114, 105, 110, 103, 98, 111, 111, 116, 46, 108, 97, 98, 48, 51, 46, 107, 97, 102, 107, 97, 100, 101, 109, 111, 46, 109, 101, 115, 115, 97, 103, 101, 46, 68, 101, 109, 111, 48, 50, 77, 101, 115, 115, 97, 103, 101])], isReadOnly = true), key=null, value=Demo01Message&#123;id=1575639802&#125;, timestamp=null), recordMetadata=DEMO_02-0@39]]]</span><br><span class="line"></span><br><span class="line"># 因为 Producer 批量发送完成，所以 Demo02Consumer 消费到消息</span><br><span class="line">2019-12-08 21:43:32.475  INFO 94957 --- [ntainer#0-0-C-1] c.i.s.l.k.consumer.Demo02Consumer        : [onMessage][线程编号:16 消息内容：Demo01Message&#123;id=1575639782&#125;]</span><br><span class="line">2019-12-08 21:43:32.475  INFO 94957 --- [ntainer#0-0-C-1] c.i.s.l.k.consumer.Demo02Consumer        : [onMessage][线程编号:16 消息内容：Demo01Message&#123;id=1575639792&#125;]</span><br><span class="line">2019-12-08 21:43:32.475  INFO 94957 --- [ntainer#0-0-C-1] c.i.s.l.k.consumer.Demo02Consumer        : [onMessage][线程编号:16 消息内容：Demo01Message&#123;id=1575639802&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>😈 胖友认真看下艿艿在日志中的注释，理解下整个批量发送消息的过程。不过还是那句话，实际场景下，我们不太会把 <code>linger.ms</code> 配置的这么长时间，这里仅仅是演示。</li>
</ul>
<h1 id="5-批量消费消息"><a href="#5-批量消费消息" class="headerlink" title="5. 批量消费消息"></a>5. 批量消费消息</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch-consume">lab-03-kafka-demo-batch-consume</a> 。</p>
</blockquote>
<p>在一些业务场景下，我们希望使用 Consumer 批量消费消息，提高消费速度。要注意，Consumer 的批量消费消息，和 Producer 的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「4. 批量发送消息」</a> 没有直接关联哈。</p>
<p>下面，我们来实现一个 Consumer 批量消费消息的示例。考虑到不污染<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「4. 批量发送消息」</a> 的示例，我们在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch">lab-03-kafka-demo-batch</a> 项目的基础上，复制出一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-batch-consume">lab-03-kafka-demo-batch-consume</a> 项目。😈 酱紫，我们也能少写点代码，哈哈哈~</p>
<h2 id="5-1-应用配置文件"><a href="#5-1-应用配置文件" class="headerlink" title="5.1 应用配置文件"></a>5.1 应用配置文件</h2><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch-consume/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">    <span class="comment"># Kafka Producer 配置项</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span> <span class="comment"># 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span> <span class="comment"># 发送失败时，重试发送的次数</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span> <span class="comment"># 消息的 key 的序列化</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span> <span class="comment"># 消息的 value 的序列化</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span> <span class="comment"># 每次批量发送消息的最大数量</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span> <span class="comment"># 每次批量发送消息的最大内存</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">linger:</span></span><br><span class="line">          <span class="attr">ms:</span> <span class="number">30000</span> <span class="comment"># 批处理延迟时间上限。这里配置为 30 * 1000 ms 过后，不管是否消息数量是否到达 batch-size 或者消息大小到达 buffer-memory 后，都直接发送一次请求。</span></span><br><span class="line">    <span class="comment"># Kafka Consumer 配置项</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span> <span class="comment"># 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line">      <span class="attr">fetch-max-wait:</span> <span class="number">10000</span> <span class="comment"># poll 一次拉取的阻塞的最大时长，单位：毫秒。这里指的是阻塞拉取需要满足至少 fetch-min-size 大小的消息</span></span><br><span class="line">      <span class="attr">fetch-min-size:</span> <span class="number">10</span> <span class="comment"># poll 一次消息拉取的最小数据量，单位：字节</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">100</span> <span class="comment"># poll 一次消息拉取的最大数量</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">spring:</span></span><br><span class="line">          <span class="attr">json:</span></span><br><span class="line">            <span class="attr">trusted:</span></span><br><span class="line">              <span class="attr">packages:</span> <span class="string">cn.iocoder.springboot.lab03.kafkademo.message</span></span><br><span class="line">    <span class="comment"># Kafka Consumer Listener 监听器配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">BATCH</span> <span class="comment"># 监听器类型，默认为 SINGLE ，只监听单条消息。这里我们配置 BATCH ，监听多条消息，批量消费</span></span><br><span class="line">      <span class="attr">missing-topics-fatal:</span> <span class="literal">false</span> <span class="comment"># 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># spring-kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br><span class="line">      <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>相比</p>
<p>「3.2 应用配置文件」</p>
<p>来说，增加了四个配置项，胖友自己根据注释，自己理解下噢。</p>
<ul>
<li><code>spring.kafka.listener.type</code></li>
<li><code>spring.kafka.consumer.max-poll-records</code></li>
<li><code>spring.kafka.consumer.fetch-min-size</code></li>
<li><code>spring.kafka.consumer.fetch-max-wait</code></li>
</ul>
</li>
</ul>
<h2 id="5-2-Demo02Consumer"><a href="#5-2-Demo02Consumer" class="headerlink" title="5.2 Demo02Consumer"></a>5.2 Demo02Consumer</h2><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch-consume/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo02Consumer.java">Demo02Consumer</a> 消费者，改成批量消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo02Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo02Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo02-consumer-group-&quot; + Demo02Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(List&lt;Demo02Message&gt; messages)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息数量：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), messages.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>相比<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「4.5 Demo02Consumer」</a>来说，方法上的参数变成了 List 数组。</li>
</ul>
<h2 id="5-3-简单测试"><a href="#5-3-简单测试" class="headerlink" title="5.3 简单测试"></a>5.3 简单测试</h2><p>还是使用 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-batch-consume/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo02ProducerTest.java">Demo02ProducerTest</a> 测试类，执行单元测试，输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">12</span>-08 <span class="number">23</span>:<span class="number">00</span>:<span class="number">14.274</span>  INFO <span class="number">98637</span> --- [           main] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][开始执行]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-08 <span class="number">23</span>:<span class="number">00</span>:<span class="number">44.385</span>  INFO <span class="number">98637</span> --- [ad | producer-<span class="number">1</span>] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][发送编号：[<span class="number">1575644414</span>] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_02, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">50</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo01Message&#123;id=<span class="number">1575644414</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_02-<span class="number">0</span>@<span class="number">55</span>]]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-08 <span class="number">23</span>:<span class="number">00</span>:<span class="number">44.386</span>  INFO <span class="number">98637</span> --- [ad | producer-<span class="number">1</span>] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][发送编号：[<span class="number">1575644424</span>] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_02, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">50</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo01Message&#123;id=<span class="number">1575644424</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_02-<span class="number">0</span>@<span class="number">56</span>]]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-08 <span class="number">23</span>:<span class="number">00</span>:<span class="number">44.387</span>  INFO <span class="number">98637</span> --- [ad | producer-<span class="number">1</span>] c.i.s.l.k.producer.Demo02ProducerTest    : [testASyncSend][发送编号：[<span class="number">1575644434</span>] 发送成功，结果为：[SendResult [producerRecord=ProducerRecord(topic=DEMO_02, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">50</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo01Message&#123;id=<span class="number">1575644434</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_02-<span class="number">0</span>@<span class="number">57</span>]]]</span><br><span class="line"></span><br><span class="line"># 批量消费了 <span class="number">3</span> 条消息</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-08 <span class="number">23</span>:<span class="number">00</span>:<span class="number">44.425</span>  INFO <span class="number">98637</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo02Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息数量：<span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<ul>
<li>从日志中，我们可以看出，发送的 3 条消息被 Demo02Consumer 批量消费了。</li>
<li>😈 为了更好的做对比，胖友可以尝试自行把配置改成 <code>spring.kafka.listener.type=SINGLE</code> ，就会发现 Demo02Consumer 只会单条消费了。</li>
</ul>
<h1 id="6-定时消息"><a href="#6-定时消息" class="headerlink" title="6. 定时消息"></a>6. 定时消息</h1><p><strong>Kafka 并未提供定时消息的功能，需要我们自行拓展</strong>。</p>
<p>例如说<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/delayed-message-consume-service-use-kafka/?self">《基于 Kafka 的定时消息&#x2F;任务服》</a>文章，提供的方案。</p>
<p>当然，也可以考虑基于 MySQL 存储定时消息，Job 扫描到达时间的定时消息，发送给 Kafka 。</p>
<h1 id="7-消费重试"><a href="#7-消费重试" class="headerlink" title="7. 消费重试"></a>7. 消费重试</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo">lab-31-kafka-demo</a> 。</p>
</blockquote>
<p>Spring-Kafka 提供<strong>消费重试</strong>的机制。在消息<strong>消费失败</strong>的时候，Spring-Kafka 会通过<strong>消费重试</strong>机制，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。</p>
<p>当然，Spring-Kafka 并不会无限重新投递消息给 Consumer 重新消费，而是在默认情况下，达到 N 次重试次数时，Consumer 还是消费失败时，该消息就会进入到<strong>死信队列</strong>。</p>
<blockquote>
<p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，Spring-Kafka 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，Spring-Kafka 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>Spring-Kafka 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。后续，我们可以通过对死信队列中的消息进行重发，来使得消费者实例再次进行消费。</p>
</blockquote>
<ul>
<li>在<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self">《芋道 Spring Boot 消息队列 RocketMQ 入门》</a>的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「6. 消费重试」</a>小节中，我们可以看到，消费重试和死信队列，是 RocketMQ 自带的功能。</li>
<li>而在 Kafka 中，消费重试和死信队列，是由 Spring-Kafka 所封装提供的。</li>
</ul>
<p>每条消息的失败重试，是可以配置一定的<strong>间隔时间</strong>。具体，我们在示例的代码中，来进行具体的解释。</p>
<p>下面，我们开始本小节的示例。该示例，我们会在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3. 快速入门」</a>的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo">lab-31-kafka-demo</a> 项目中，继续改造。</p>
<h2 id="7-1-KafkaConfiguration"><a href="#7-1-KafkaConfiguration" class="headerlink" title="7.1 KafkaConfiguration"></a>7.1 KafkaConfiguration</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/config"><code>cn.iocoder.springboot.lab03.kafkademo.config</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/config/KafkaConfiguration.java">KafkaConfiguration</a> 配置类，增加消费异常的 ErrorHandler 处理器 。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KafkaConfiguration.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> ErrorHandler <span class="title function_">kafkaErrorHandler</span><span class="params">(KafkaTemplate&lt;?, ?&gt; template)</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt; 创建 DeadLetterPublishingRecoverer 对象</span></span><br><span class="line">        <span class="type">ConsumerRecordRecoverer</span> <span class="variable">recoverer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLetterPublishingRecoverer</span>(template);</span><br><span class="line">        <span class="comment">// &lt;2&gt; 创建 FixedBackOff 对象</span></span><br><span class="line">        <span class="type">BackOff</span> <span class="variable">backOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">10</span> * <span class="number">1000L</span>, <span class="number">3L</span>);</span><br><span class="line">        <span class="comment">// &lt;3&gt; 创建 SeekToCurrentErrorHandler 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SeekToCurrentErrorHandler</span>(recoverer, backOff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>Spring-Kafka 的消费重试功能，通过实现自定义的</p>
<p>SeekToCurrentErrorHandler</p>
<p>，在 Consumer 消费消息异常的时候，进行拦截处理：</p>
<ul>
<li>在重试小于最大次数时，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。</li>
<li>在重试到达最大次数时，Consumer 还是消费失败时，该消息就会发送到死信队列。例如说，本小节我们测试的 Topic 是 <code>&quot;DEMO_04&quot;</code> ，则其对应的死信队列的 Topic 就是 <code>&quot;DEMO_04.DLT&quot;</code> ，即在原有 Topic 加上 <code>.DLT</code> 后缀，就是其死信队列的 Topic 。</li>
</ul>
</li>
<li><p><code>&lt;1&gt;</code> 处，创建 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/DeadLetterPublishingRecoverer.java">DeadLetterPublishingRecoverer</a> 对象，它负责实现，在重试到达最大次数时，Consumer 还是消费失败时，该消息就会发送到死信队列。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，创建 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/backoff/FixedBackOff.java">FixedBackOff</a> 对象。这里，我们配置了重试 3 次，每次固定间隔 30 秒。当然，胖友可以选择 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/backoff/BackOff.java">BackOff</a> 的另一个子类 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/backoff/ExponentialBackOff.java">ExponentialBackOff</a> 实现，提供<a target="_blank" rel="noopener" href="http://note.huangz.me/algorithm/arithmetic/exponential-backoff.html">指数递增的间隔时间</a>。</p>
</li>
<li><p><code>&lt;3&gt;</code> 处，创建 SeekToCurrentErrorHandler 对象，负责处理异常，串联整个消费重试的整个过程。</p>
</li>
</ul>
<p>这里，我们来简单说说 SeekToCurrentErrorHandler 是怎么提供消费重试的功能的。</p>
<ul>
<li><p>在消息消费失败时，SeekToCurrentErrorHandler 会将 调用 Kafka Consumer 的 <a target="_blank" rel="noopener" href="https://github.com/axbaretto/kafka/blob/master/clients/src/main/java/org/apache/kafka/clients/consumer/Consumer.java#L124-L132"><code>#seek(TopicPartition partition, long offset)</code></a> 方法，将 Consumer 对于该消息对应的 TopicPartition 分区的<strong>本地</strong>进度设置成<strong>该消息的位置</strong>。这样，Consumer 在下次从 Kafka Broker 拉取消息的时候，又能重新拉取到这条消费失败的消息，并且是第一条。</p>
</li>
<li><p>同时，Spring-Kafka 使用 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/FailedRecordTracker.java">FailedRecordTracker</a> 对每个 Topic 的每个 TopicPartition 消费失败次数进行<strong>计数</strong>，这样相当于对该 TopicPartition 的<strong>第一条</strong>消费失败的消息的消费失败次数进行<strong>计数</strong>。😈 这里，胖友好好思考下，结合艿艿在上一点的描述。</p>
</li>
<li><p>另外，在 FailedRecordTracker 中，会调用 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/backoff/BackOff.java">BackOff</a> 来进行计算，该消息的<strong>下一次重新消费的时间</strong>，通过 <code>Thread#sleep(...)</code> 方法，实现重新消费的时间间隔。</p>
</li>
<li><p>有一点需要注意，FailedRecordTracker 提供的计数是<strong>客户端</strong>级别的，重启 JVM 应用后，计数是会丢失的。所以，如果想要计数进行持久化，需要自己重新实现下 FailedRecordTracker 类，通过 ZooKeeper 存储计数。</p>
<blockquote>
<p>😈 RocketMQ 提供的消费重试的计数，目前是<strong>服务端</strong>级别，已经进行持久化。</p>
</blockquote>
</li>
</ul>
<p>对了，SeekToCurrentErrorHandler 是只<strong>针对</strong>消息的<strong>单条</strong>消费失败的消费重试处理。如果胖友想要有消息的<strong>批量</strong>消费失败的消费重试处理，可以使用 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/SeekToCurrentBatchErrorHandler.java">SeekToCurrentBatchErrorHandler</a> 。配置方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> BatchErrorHandler <span class="title function_">kafkaBatchErrorHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 SeekToCurrentBatchErrorHandler 对象</span></span><br><span class="line">    <span class="type">SeekToCurrentBatchErrorHandler</span> <span class="variable">batchErrorHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeekToCurrentBatchErrorHandler</span>();</span><br><span class="line">    <span class="comment">// 创建 FixedBackOff 对象</span></span><br><span class="line">    <span class="type">BackOff</span> <span class="variable">backOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">10</span> * <span class="number">1000L</span>, <span class="number">3L</span>);</span><br><span class="line">    batchErrorHandler.setBackOff(backOff);</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> batchErrorHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>从代码中我们可以看到，并没有设置 DeadLetterPublishingRecoverer 对象。因为 SeekToCurrentBatchErrorHandler 暂时不支持死信队列的机制。</li>
</ul>
<p>另外，如果胖友想要自定义 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/ErrorHandler.java">ErrorHandler</a> 或 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/BatchErrorHandler.java">BatchErrorHandler</a> 实现类，实现对消费异常的自定义的逻辑，也是可以的。</p>
<ul>
<li>实现的代码的示例，可以参考 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/LoggingErrorHandler.java">LoggingErrorHandler</a> 类。</li>
<li>配置的方式，和本小节配置 SeekToCurrentErrorHandler 或 SeekToCurrentBatchErrorHandler 是一样的。</li>
<li>当然，绝大多数情况下，我们使用 SeekToCurrentErrorHandler 或 SeekToCurrentBatchErrorHandler 是足够的。</li>
</ul>
<blockquote>
<p>艿艿：貌似本小节信息量，略微有一点点大，胖友可以自己好好消化下。同时，也可以调试下整个过程涉及到的源码，更加具象下。「源码之前，了无秘密」。</p>
</blockquote>
<h2 id="7-2-Demo04Message"><a href="#7-2-Demo04Message" class="headerlink" title="7.2 Demo04Message"></a>7.2 Demo04Message</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message"><code>cn.iocoder.springboot.lab03.kafkademo.message</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message/Demo04Message.java">Demo04Message</a> 消息类，提供给当前示例使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04Message.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;DEMO_04&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 set/get/toString 方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>TOPIC</code> 静态属性，我们设置该消息类对应 Topic 为 <code>&quot;DEMO_04&quot;</code> 。</li>
</ul>
<h2 id="7-3-Demo04Producer"><a href="#7-3-Demo04Producer" class="headerlink" title="7.3 Demo04Producer"></a>7.3 Demo04Producer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo04Producer.java">Demo04Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，同步发送消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">syncSend</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo04Message 消息</span></span><br><span class="line">        <span class="type">Demo04Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo04Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 同步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo04Message.TOPIC, message).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.5 Demo01Producer」</a>的同步发送消息的代码是一致的，就是换成了 Demo04Message 。</li>
</ul>
<h2 id="7-4-Demo04Consumer"><a href="#7-4-Demo04Consumer" class="headerlink" title="7.4 Demo04Consumer"></a>7.4 Demo04Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo04Consumer.java">Demo04Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo04Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo04-consumer-group-&quot; + Demo04Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo04Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">        <span class="comment">// &lt;X&gt; 注意，此处抛出一个 RuntimeException 异常，模拟消费失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我就是故意抛出一个异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在 <code>&lt;X&gt;</code> 处，我们在消费消息时候，抛出一个 RuntimeException 异常，模拟消费失败。</li>
</ul>
<h2 id="7-5-简单测试"><a href="#7-5-简单测试" class="headerlink" title="7.5 简单测试"></a>7.5 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo04ProducerTest.java">Demo04ProducerTest</a> 测试类，编写一个单元测试方法，调用 Demo04Producer 同步发送消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04ProducerTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo04Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSend</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.syncSend(id);</span><br><span class="line">        logger.info(<span class="string">&quot;[testSyncSend][发送编号：[&#123;&#125;] 发送结果：[&#123;&#125;]]&quot;</span>, id, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们来执行 <code>#testSyncSend()</code> 方法，同步发送消息。控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Producer 同步发送消息成功</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">18.851</span>  INFO <span class="number">11359</span> --- [           main] c.i.s.l.k.producer.Demo04ProducerTest    : [testSyncSend][发送编号：[<span class="number">1575685458</span>] 发送结果：[SendResult [producerRecord=ProducerRecord(topic=DEMO_04, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">52</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo04Message&#123;id=<span class="number">1575685458</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_04-<span class="number">0</span>@<span class="number">0</span>]]]</span><br><span class="line"></span><br><span class="line"># Consumer04 首次消费</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">18.918</span>  INFO <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo04Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo04Message&#123;id=<span class="number">1575685458</span>&#125;]</span><br><span class="line"># 打印异常</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">28.927</span> ERROR <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] essageListenerContainer$ListenerConsumer : Error handler threw an exception</span><br><span class="line"></span><br><span class="line"># Consumer04 第一次重试消费</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">28.929</span>  INFO <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo04Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo04Message&#123;id=<span class="number">1575685458</span>&#125;]</span><br><span class="line"># 打印异常</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">38.932</span> ERROR <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] essageListenerContainer$ListenerConsumer : Error handler threw an exception</span><br><span class="line"></span><br><span class="line"># Consumer04 第二次重试消费</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">38.934</span>  INFO <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo04Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo04Message&#123;id=<span class="number">1575685458</span>&#125;]</span><br><span class="line"># 打印异常</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">48.939</span> ERROR <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] essageListenerContainer$ListenerConsumer : Error handler threw an exception</span><br><span class="line"></span><br><span class="line"># Consumer04 第三次重试消费</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">48.941</span>  INFO <span class="number">11359</span> --- [ntainer#<span class="number">2</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo04Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo04Message&#123;id=<span class="number">1575685458</span>&#125;]</span><br><span class="line"># 这次不会打印异常日志，直接发到死信队列</span><br></pre></td></tr></table></figure>



<ul>
<li>从日志中，我们可以看出，发送的这条消息被 Demo04Consumer 首次消费失败后，每间隔 10 秒，又消费重试 3 次。</li>
</ul>
<h1 id="8-广播消费"><a href="#8-广播消费" class="headerlink" title="8. 广播消费"></a>8. 广播消费</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-broadcast">lab-03-kafka-demo-broadcast</a> 。</p>
</blockquote>
<p>在上述的示例中，我们看到的都是使用集群消费。而在一些场景下，我们需要使用<strong>广播消费</strong>。</p>
<blockquote>
<p>广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。</p>
</blockquote>
<ul>
<li>不过 Kafka 并不直接提供<strong>内置的</strong>广播消费的功能！！！此时，我们只能退而求其次，每个 Consumer <strong>独有</strong>一个 Consumer Group ，从而保证都能接收到全量的消息。</li>
</ul>
<p>例如说，在应用中，缓存了数据字典等配置表在内存中，可以通过 Kafka 广播消费，实现每个应用节点都消费消息，刷新本地内存的缓存。</p>
<p>又例如说，我们基于 WebSocket 实现了 IM 聊天，在我们给用户主动发送消息时，因为我们不知道用户连接的是哪个提供 WebSocket 的应用，所以可以通过 Kafka 广播消费，每个应用判断当前用户是否是和自己提供的 WebSocket 服务连接，如果是，则推送消息给用户。</p>
<p>下面，我们开始本小节的示例。考虑到不污染上述的示例，我们新建一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-broadcast">lab-03-kafka-demo-broadcast</a> 项目。</p>
<h2 id="8-1-引入依赖"><a href="#8-1-引入依赖" class="headerlink" title="8.1 引入依赖"></a>8.1 引入依赖</h2><p>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.1 引入依赖」」</a>一致，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-broadcast/pom.xml"><code>pom.xml</code></a> 文件。</p>
<h2 id="8-2-应用配置文件"><a href="#8-2-应用配置文件" class="headerlink" title="8.2 应用配置文件"></a>8.2 应用配置文件</h2><p>在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.2 应用配置文件」</a> 是一致的订单，就是修改了配置项 <code>spring.kafka.consumer.auto-offset-reset=latest</code> 。因为在广播订阅下，我们一般情况下，无需消费历史的消息，而是从订阅的 Topic 的队列的尾部开始消费即可，所以配置为 <code>latest</code> 。</p>
<p>完整的配置文件，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/resources/application.yaml"><code>application.yaml</code></a> 。</p>
<h2 id="8-3-Demo05Message"><a href="#8-3-Demo05Message" class="headerlink" title="8.3 Demo05Message"></a>8.3 Demo05Message</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message"><code>cn.iocoder.springboot.lab03.kafkademo.message</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message/Demo05Message.java">Demo05Message</a> 消息类，提供给当前示例使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo05Message.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;DEMO_05&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 set/get/toString 方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>TOPIC</code> 静态属性，我们设置该消息类对应 Topic 为 <code>&quot;DEMO_05&quot;</code> 。</li>
</ul>
<h2 id="8-4-Demo05Producer"><a href="#8-4-Demo05Producer" class="headerlink" title="8.4 Demo05Producer"></a>8.4 Demo05Producer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo05Producer.java">Demo05Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，同步发送消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">syncSend</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo05Message 消息</span></span><br><span class="line">        <span class="type">Demo05Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo05Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 同步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo05Message.TOPIC, message).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.5 Demo01Producer」</a>的同步发送消息的代码是一致的，就是换成了 Demo05Message 。</li>
</ul>
<h2 id="8-5-Demo05Consumer"><a href="#8-5-Demo05Consumer" class="headerlink" title="8.5 Demo05Consumer"></a>8.5 Demo05Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo05Consumer.java">Demo05Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo05Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo05-consumer-group-&quot; + Demo05Message.TOPIC + &quot;-&quot; + &quot;#&#123;T(java.util.UUID).randomUUID()&#125;&quot;)</span> <span class="comment">// &lt;X&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo05Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在 <code>&lt;X&gt;</code> 处，我们通过 Spring EL 表达式，在每个消费者分组的名字上，使用 UUID 生成其后缀。这样，我们就能保证每个项目启动的消费者分组不同，以达到广播消费的目的。</li>
</ul>
<h2 id="8-6-简单测试"><a href="#8-6-简单测试" class="headerlink" title="8.6 简单测试"></a>8.6 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-broadcast/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo05ProducerTest.java">Demo05ProducerTest</a> 测试类，用于测试广播消费。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo05Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSend</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.syncSend(id);</span><br><span class="line">        logger.info(<span class="string">&quot;[testSyncSend][发送编号：[&#123;&#125;] 发送结果：[&#123;&#125;]]&quot;</span>, id, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先，执行 <code>#test()</code> 测试方法，先启动一个消费者分组 <code>&quot;demo05-consumer-group-DEMO_05-$&#123;UUID1&#125;&quot;</code> 的 Consumer 节点。</p>
<p>然后，执行 <code>#testSyncSend()</code> 测试方法，再启动一个消费者分组 <code>&quot;demo05-consumer-group-DEMO_05-$&#123;UUID2&#125;&quot;</code> 的 Consumer 节点。同时，该测试方法，调用 <code>Demo05ProducerTest#syncSend(id)</code> 方法，同步发送了一条消息。控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #### testSyncSend 方法对应的控制台 ####</span></span><br><span class="line"></span><br><span class="line"># Producer 同步发送消息成功</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">42.578</span>  INFO <span class="number">16077</span> --- [           main] c.i.s.l.k.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[<span class="number">1575702042</span>] 发送结果：[SendResult [producerRecord=ProducerRecord(topic=DEMO_05, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">53</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo05Message&#123;id=<span class="number">1575702042</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_05-<span class="number">0</span>@<span class="number">0</span>]]]</span><br><span class="line"></span><br><span class="line"># Demo05Consumer 消费了该消息</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">42.618</span>  INFO <span class="number">16077</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo05Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo05Message&#123;id=<span class="number">1575702042</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### test 方法对应的控制台 ####</span></span><br><span class="line"></span><br><span class="line"># Demo05Consumer 也消费了该消息</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">42.644</span>  INFO <span class="number">16067</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo05Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo05Message&#123;id=<span class="number">1575702042</span>&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>消费者分组 <code>&quot;demo05-consumer-group-DEMO_05-$&#123;UUID1&#125;&quot;</code> 和 <code>demo05-consumer-group-DEMO_05-$&#123;UUID2&#125;</code> 的<strong>两个</strong> Consumer 节点，都消费了这条发送的消息。符合广播消费的预期~</li>
</ul>
<h1 id="9-并发消费"><a href="#9-并发消费" class="headerlink" title="9. 并发消费"></a>9. 并发消费</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-concurrency">lab-03-kafka-demo-concurrency</a> 。</p>
</blockquote>
<p>在上述的示例中，我们配置的每一个 Spring-Kafka <code>@KafkaListener</code> ，都是<strong>串行</strong>消费的。显然，这在监听的 Topic 每秒消息量比较大的时候，会导致消费不及时，导致消息积压的问题。</p>
<p>虽然说，我们可以通过启动多个 JVM 进程，实现<strong>多进程的并发消费</strong>，从而加速消费的速度。但是问题是，否能够实现<strong>多线程</strong>的并发消费呢？答案是<strong>有</strong>。</p>
<p>在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.9 @KafkaListener」</a>小节中，我们可以看到该注解有 <code>concurrency</code> 属性，它可以指定并发消费的线程数。例如说，如果设置 <code>concurrency=4</code> 时，Spring-Kafka 就会为<strong>该</strong> <code>@KafkaListener</code> 创建 4 个线程，进行并发消费。</p>
<p>考虑到让胖友能够更好的理解 <code>concurrency</code> 属性，我们来简单说说 Spring-Kafka 在这块的实现方式。我们来举个例子：</p>
<ul>
<li>首先，我们来创建一个 Topic 为 <code>&quot;DEMO_06&quot;</code> ，并且设置其 Partition 分区数为 <strong>10</strong> 。</li>
<li>然后，我们创建一个 Demo06Consumer 类，并在其消费方法上，添加 <code>@KafkaListener(concurrency=2)</code> 注解。</li>
<li>再然后，我们启动项目。Spring-Kafka 会根据 <code>@KafkaListener(concurrency=2)</code> 注解，创建 <strong>2</strong> 个 Kafka Consumer 。注意噢，是 <strong>2</strong> 个 Kafka Consumer 呢！！！后续，每个 Kafka Consumer 会被<strong>单独</strong>分配到一个线程中，进行拉取消息，消费消息。</li>
<li>之后，Kafka Broker 会将 Topic 为 <code>&quot;DEMO_06&quot;</code> 分配给创建的 <strong>2</strong> 个 Kafka Consumer 各 <strong>5</strong> 个 Partition 。😈 如果不了解 Kafka Broker “分配区分”机制单独胖友，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/How-do-Kafka-consumers-allocate-partitions/?self">《Kafka 消费者如何分配分区》</a> 文章。</li>
<li>这样，因为 <code>@KafkaListener(concurrency=2)</code> 注解，创建 <strong>2</strong> 个 Kafka Consumer ，就在<strong>各自的线程中</strong>，拉取各自的 Topic 为 <code>&quot;DEMO_06&quot;</code> 的 Partition 的消息，各自<strong>串行</strong>消费。从而，实现<strong>多线程</strong>的并发消费。</li>
</ul>
<p>酱紫讲解一下，胖友对 Spring-Kafka 实现<strong>多线程</strong>的并发消费的机制，是否理解了。不过有一点要注意，不要配置 <code>concurrency</code> 属性过大，则创建的 Kafka Consumer 分配不到消费 Topic 的 Partition 分区，导致不断的空轮询。</p>
<blockquote>
<p>友情提示：可以选择不看。</p>
<p>在理解 Spring-Kafka 提供的<strong>并发消费</strong>机制，花费了好几个小时，主要陷入到了一个误区。</p>
<p>如果胖友有使用过 RocketMQ 的并发消费，会发现只要创建一个 RocketMQ Consumer 对象，然后 Consumer 拉取完消息之后，丢到 Consumer 的线程池中执行消费，从而实现并发消费。</p>
<p>而在 Spring-Kafka 提供的并发消费，会发现需要创建多个 Kafka Consumer 对象，并且每个 Consumer 都单独分配一个线程，然后 Consumer 拉取完消息之后，在各自的线程中执行消费。</p>
<p>又或者说，Spring-Kafka 提供的并发消费，很像 RocketMQ 的顺序消费。😈 从感受上来说，Spring-Kafka 的并发消费像 BIO ，RocketMQ 的并发消费像 NIO 。</p>
<p>不过，理论来说，在原生的 Kafka 客户端，也是能封装出和 RocketMQ Consumer 一样的并发消费的机制。</p>
<p>也因此，在使用 Kafka 的时候，每个 Topic 的 Partition 在消息量大的时候，要注意设置的相对大一些。</p>
</blockquote>
<p>下面，我们开始本小节的示例。本示例就是上述举例的具体实现。考虑到不污染上述的示例，我们新建一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-concurrency">lab-03-kafka-demo-concurrency</a> 项目。</p>
<h2 id="9-1-引入依赖"><a href="#9-1-引入依赖" class="headerlink" title="9.1 引入依赖"></a>9.1 引入依赖</h2><p>和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">3.1 引入依赖」</a> 一致，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/pom.xml"><code>pom.xml</code></a> 文件。</p>
<h2 id="9-2-应用配置文件"><a href="#9-2-应用配置文件" class="headerlink" title="9.2 应用配置文件"></a>9.2 应用配置文件</h2><p>和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">3.2 应用配置文件」</a> 一致，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/resources/application.yaml"><code>application.yaml</code></a> 文件。</p>
<p>实际上，可以通过 <code>spring.kafka.listener.concurrency</code> 配置项，全局设置每个 <code>@KafkaListener</code> 的并发消费的线程数。不过个人建议，还是每个 <code>@KafkaListener</code> 各自配置，毕竟每个 Topic 的 Partition 的数量，都是不同的。当然，也可以结合使用 😈 。</p>
<h2 id="9-3-Demo06Message"><a href="#9-3-Demo06Message" class="headerlink" title="9.3 Demo06Message"></a>9.3 Demo06Message</h2><p>在 <a href="ttps://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message"><code>cn.iocoder.springboot.lab03.kafkademo.message</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message/Demo06Message.java">Demo06Message</a> 消息类，提供给当前示例使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo06Message.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;DEMO_06&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 set/get/toString 方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>TOPIC</code> 静态属性，我们设置该消息类对应 Topic 为 <code>&quot;DEMO_06&quot;</code> 。</li>
</ul>
<p>注意，记得手动创建一个 <code>&quot;DEMO_06&quot;</code> 的 Partition 大小为 10 。可执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 10 --topic DEMO_06</span><br></pre></td></tr></table></figure>



<h2 id="9-4-Demo06Producer"><a href="#9-4-Demo06Producer" class="headerlink" title="9.4 Demo06Producer"></a>9.4 Demo06Producer</h2><p>在 <a href="ttps://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo06Producer.java">Demo06Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，同步发送消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo06Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">syncSend</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo01Message 消息</span></span><br><span class="line">        <span class="type">Demo06Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo06Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 同步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo06Message.TOPIC, message).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.5 Demo01Producer」</a>的同步发送消息的代码是一致的，就是换成了 Demo06Message 。</li>
</ul>
<h2 id="9-5-Demo06Consumer"><a href="#9-5-Demo06Consumer" class="headerlink" title="9.5 Demo06Consumer"></a>9.5 Demo06Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo06Consumer.java">Demo06Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo06Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo06Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo06-consumer-group-&quot; + Demo06Message.TOPIC,</span></span><br><span class="line"><span class="meta">            concurrency = &quot;2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo06Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在 <code>&lt;X&gt;</code> 处，我们在 <code>@KafkaListener</code> 注解上，添加了 <code>concurrency = &quot;2&quot;</code> 属性，创建 2 个线程消费 <code>&quot;DEMO_06&quot;</code> 下的消息。</li>
</ul>
<h2 id="9-6-简单测试"><a href="#9-6-简单测试" class="headerlink" title="9.6 简单测试"></a>9.6 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo06ProducerTest.java">Demo06ProducerTest</a> 测试类，编写一个单元测试方法，发送 10 条消息，观察并发消费情况。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo06ProducerTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo06Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSend</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.syncSend(id);</span><br><span class="line"><span class="comment">//        logger.info(&quot;[testSyncSend][发送编号：[&#123;&#125;] 发送结果：[&#123;&#125;]]&quot;, id, result);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行 <code>#testSyncSend()</code> 单元测试，输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 线程编号为 <span class="number">16</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.365</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"></span><br><span class="line"># 线程编号为 <span class="number">18</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.365</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">16.369</span>  INFO <span class="number">24303</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1575710476</span>&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>我们可以看到，两个线程在消费 <code>&quot;DEMO_06&quot;</code> 下的消息。</li>
<li>😈 为了更好的做对比，胖友可以尝试自行把配置改成 <code>@KafkaListner</code> 的 <code>concurrency=1</code>，就会发现 Demo06Consumer 只会单线程消费了。</li>
</ul>
<p>此时，如果我们使用 <a target="_blank" rel="noopener" href="https://github.com/yahoo/kafka-manager">Kafka Manager</a> 来查看 <code>&quot;DEMO_06&quot;</code> 的消费者列表：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F91abe663c506607c013c55a4222f3442.png" alt=" 的消费者列表"></p>
<h1 id="10-顺序消息"><a href="#10-顺序消息" class="headerlink" title="10. 顺序消息"></a>10. 顺序消息</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-concurrency">lab-03-kafka-demo-concurrency</a> 。</p>
</blockquote>
<p>我们先来一起了解下顺序消息的<strong>顺序消息</strong>的定义：</p>
<ul>
<li>普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。</li>
<li>完全严格顺序 ：在【普通顺序消息】的基础上，Consumer 严格顺序消费。</li>
</ul>
<p>在上述的示例中，我们看到 Spring-Kafka 在 Consumer 消费消息时，<strong>天然</strong>就支持按照 Topic 下的 Partition 下的消息，<strong>顺序消费</strong>。即使在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「9. 并发消费」</a>时，也能保证如此。</p>
<p>那么此时，我们只需要考虑将 Producer 将相关联的消息发送到 Topic 下的相同的 Partition 即可。如果胖友了解 Producer 发送消息的分区策略的话，只要我们发送消息时，指定了消息的 key ，Producer 则会根据 key 的哈希值取模来获取到其在 Topic 下对应的 Partition 。完美~~不了解的 Producer 分区选择策略的胖友，可以看看 <a target="_blank" rel="noopener" href="https://leokongwq.github.io/2017/02/27/mq-kafka-producer-partitioner.html">《Kafka 发送消息分区选择策略详解》</a> 文章。</p>
<p>下面，我们开始本小节的示例。该示例，我们会在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「9. 并发消费」</a>的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-concurrency">lab-03-kafka-demo-concurrency</a> 项目中，继续改造。</p>
<h2 id="10-1-Demo06Producer"><a href="#10-1-Demo06Producer" class="headerlink" title="10.1 Demo06Producer"></a>10.1 Demo06Producer</h2><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo06Producer.java">Demo06Producer</a> 类，增加顺序发送消息方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo06Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">syncSendOrderly</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建 Demo01Message 消息</span></span><br><span class="line">    <span class="type">Demo06Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo06Message</span>();</span><br><span class="line">    message.setId(id);</span><br><span class="line">    <span class="comment">// 同步发送消息</span></span><br><span class="line">    <span class="comment">// 因为我们使用 String 的方式序列化 key ，所以需要将 id 转换成 String</span></span><br><span class="line">    <span class="keyword">return</span> kafkaTemplate.send(Demo06Message.TOPIC, String.valueOf(id), message).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>调用 KafkaTemplate 同步发送消息方法时，我们多传入了 <code>id</code> 作为消息的 key ，从而实现发送到 <code>DEMO_06</code> 这个 Topic 下的相同 Partition 中。</li>
</ul>
<h2 id="10-2-简单测试"><a href="#10-2-简单测试" class="headerlink" title="10.2 简单测试"></a>10.2 简单测试</h2><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-concurrency/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo06ProducerTest.java">Demo06ProducerTest</a> 测试类，新增一个单元测试方法，顺序发送 10 条消息，观察消费情况。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo06ProducerTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSendOrderly</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.syncSendOrderly(id);</span><br><span class="line">        logger.info(<span class="string">&quot;[testSyncSend][发送编号：[&#123;&#125;] 发送队列：[&#123;&#125;]]&quot;</span>, id, result.getRecordMetadata().partition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行 <code>#testSyncSendOrderly()</code> 单元测试，输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Producer 同步发送 <span class="number">10</span> 条顺序消息成功，都发送到了 Topic 为 DEMO_06 ，队列编号为 <span class="number">9</span> 的消息队列上</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.866</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.867</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.869</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.870</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.871</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.872</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.873</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.875</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.876</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.877</span>  INFO <span class="number">31773</span> --- [           main] c.i.s.l.k.producer.Demo06ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送队列：[<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"># Demo06Consumer 在线程编号为 <span class="number">18</span> 中，顺序消费</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.908</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.911</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">45.912</span>  INFO <span class="number">31773</span> --- [ntainer#<span class="number">0</span>-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo06Consumer        : [onMessage][线程编号:<span class="number">18</span> 消息内容：Demo06Message&#123;id=<span class="number">1</span>&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>😈 胖友认真看下艿艿在日志中的注释，理解下整个顺序消息的过程。</li>
</ul>
<h1 id="11-事务消息"><a href="#11-事务消息" class="headerlink" title="11. 事务消息"></a>11. 事务消息</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-transaction">lab-03-kafka-demo-transaction</a> 。</p>
</blockquote>
<p>Kafka 内置提供事务消息的支持。对事务消息的概念不了解的胖友，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/longyb-transaction_mq/?self">《事务消息组件的套路》</a> 文章。</p>
<p>不过 Kafka 提供的并不是<strong>完整的</strong>的事务消息的支持，缺少了<strong>回查机制</strong>。关于这一点，刚推荐的文章也有讲到。目前，常用的分布式消息队列，只有 RocketMQ 提供了完整的事务消息的支持，具体的可以看看<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self">《芋道 Spring Boot 消息队列 RocketMQ 入门》</a> 的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「9. 事务消息」</a>小节，😈 暂时不拓展开来讲。</p>
<p>下面，我们开始本小节的示例。考虑到不污染上述的示例，我们新建一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-transaction">lab-03-kafka-demo-transaction</a> 项目。</p>
<h2 id="11-1-引入依赖"><a href="#11-1-引入依赖" class="headerlink" title="11.1 引入依赖"></a>11.1 引入依赖</h2><p>和 <a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">3.1 引入依赖」</a> 一致，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/pom.xml"><code>pom.xml</code></a> 文件。</p>
<h2 id="11-2-应用配置文件"><a href="#11-2-应用配置文件" class="headerlink" title="11.2 应用配置文件"></a>11.2 应用配置文件</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/main/resources"><code>resources</code></a> 目录下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">    <span class="comment"># Kafka Producer 配置项</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="string">all</span> <span class="comment"># 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span> <span class="comment"># 发送失败时，重试发送的次数</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span> <span class="comment"># 消息的 key 的序列化</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span> <span class="comment"># 消息的 value 的序列化</span></span><br><span class="line">      <span class="attr">transaction-id-prefix:</span> <span class="string">demo.</span> <span class="comment"># 事务编号前缀</span></span><br><span class="line">    <span class="comment"># Kafka Consumer 配置项</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span> <span class="comment"># 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">spring:</span></span><br><span class="line">          <span class="attr">json:</span></span><br><span class="line">            <span class="attr">trusted:</span></span><br><span class="line">              <span class="attr">packages:</span> <span class="string">cn.iocoder.springboot.lab03.kafkademo.message</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">level:</span> <span class="string">read_committed</span> <span class="comment"># 读取已提交的消息</span></span><br><span class="line">    <span class="comment"># Kafka Consumer Listener 监听器配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">missing-topics-fatal:</span> <span class="literal">false</span> <span class="comment"># 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># spring-kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br><span class="line">      <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">kafka:</span> <span class="string">ERROR</span> <span class="comment"># kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>相比</p>
<p>「3.2 应用配置文件」</p>
<p>来说，修改或增加如下三个参数：</p>
<ul>
<li>修改 <code>spring.kafka.producer.acks=all</code> 配置，不然在启动时会报 <code>&quot;Must set acks to all in order to use the idempotent producer. Otherwise we cannot guarantee idempotence.&quot;</code> 错误。因为，Kafka 的事务消息需要基于幂等性来实现，所以必须保证所有节点都写入成功。</li>
<li>增加 <code>transaction-id-prefix=demo.</code> 配置，事务编号的前缀。需要保证相同应用配置相同，不同应用配置不同。具体可以看看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57179169/how-to-choose-kafka-transaction-id-for-several-applications-hosted-in-kubernete">《How to choose Kafka transaction id for several applications》</a>的讨论。</li>
<li>增加 <code>spring.kafka.consumer.properties.isolation.level=read_committed</code> 配置，Consumer <strong>仅</strong>读取已提交的消息。😈 一定要配置！！！被坑惨了，当时以为自己的事务消息怎么就是不生效，原来少加了这个。</li>
</ul>
</li>
</ul>
<h2 id="11-3-Demo07Producer"><a href="#11-3-Demo07Producer" class="headerlink" title="11.3 Demo07Producer"></a>11.3 Demo07Producer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo07Producer.java">Demo07Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，实现发送<strong>事务</strong>消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo07Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">syncSendInTransaction</span><span class="params">(Integer id, Runnable runner)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.executeInTransaction(<span class="keyword">new</span> <span class="title class_">KafkaOperations</span>.OperationsCallback&lt;Object, Object, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">doInOperations</span><span class="params">(KafkaOperations&lt;Object, Object&gt; kafkaOperations)</span> &#123;</span><br><span class="line">                <span class="comment">// 创建 Demo07Message 消息</span></span><br><span class="line">                <span class="type">Demo07Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo07Message</span>();</span><br><span class="line">                message.setId(id);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SendResult&lt;Object, Object&gt; sendResult = kafkaOperations.send(Demo07Message.TOPIC, message).get();</span><br><span class="line">                    logger.info(<span class="string">&quot;[doInOperations][发送编号：[&#123;&#125;] 发送结果：[&#123;&#125;]]&quot;</span>, id, sendResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本地业务逻辑... biubiubiu</span></span><br><span class="line">                runner.run();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>使用 kafkaTemplate 提交的</p>
<p><code>#executeInTransaction(OperationsCallback&lt;K, V, T&gt; callback)</code></p>
<p>模板方法，实现在 Kafka 事务中，执行自定义</p>
<p>KafkaOperations.OperationsCallback</p>
<p>操作。</p>
<ul>
<li>在 <code>#executeInTransaction(...)</code> 方法中，我们可以通过 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/core/KafkaOperations.java">KafkaOperations</a> 来执行发送消息等 Kafka 相关的操作，也可以执行自己的业务逻辑。</li>
<li>在 <code>#executeInTransaction(...)</code> 方法的开始，它会自动动创建 Kafka 的事务；然后执行我们定义的 KafkaOperations 的逻辑；如果成功，则提交 Kafka 事务；如果失败，则回滚 Kafka 事务。</li>
</ul>
</li>
<li><p>另外，我们定义了一个 <code>runner</code> 参数，用于表示本地业务逻辑~</p>
</li>
</ul>
<p><strong>注意</strong>，如果 Kafka Producer 开启了事务的功能，则所有发送的消息，都必须处于 Kafka 事务之中，否则会抛出 <code>&quot; No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation, start a transaction with @Transactional before invoking the template method, run in a transaction started by a listener container when consuming a record&quot;</code> 异常。</p>
<p>所以，如果胖友的业务中，即存在需要事务的情况，也存在不需要事务的情况，需要分别定义两个 KafkaTemplate（Kafka Producer）。</p>
<h2 id="11-4-Demo07Consumer"><a href="#11-4-Demo07Consumer" class="headerlink" title="11.4 Demo07Consumer"></a>11.4 Demo07Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo07Consumer.java">Demo07Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo07Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo07Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo07-consumer-group-&quot; + Demo07Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo07Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.6 Demo1Consumer.java」</a> 一致，差别只在于消费 Topic 为 <code>DEMO_07</code> 的消息。</li>
</ul>
<h2 id="11-5-简单测试"><a href="#11-5-简单测试" class="headerlink" title="11.5 简单测试"></a>11.5 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-transaction/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo07ProducerTest.java">Demo07ProducerTest</a> 测试类，编写单元测试方法，调用 Demo07Producer 发送<strong>事务</strong>消息的方式。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo07ProducerTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo07Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSendInTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        producer.syncSendInTransaction(id, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;[run][我要开始睡觉了]&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;[run][我睡醒了]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>故意创建一个执行逻辑为 sleep 10 秒的 Runnable 对象，来让我们测试验证，事务消息在提交后，才会被 Consumer 消费到。</li>
</ul>
<p>执行 <code>#testSyncSendInTransaction()</code> 单元测试，输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Producer 同步发送消息成功。</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">20.496</span>  INFO <span class="number">37455</span> --- [           main] c.i.s.l.k.producer.Demo07Producer        : [doInOperations][发送编号：[<span class="number">1575724220</span>] 发送结果：[SendResult [producerRecord=ProducerRecord(topic=DEMO_07, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo07Message&#123;id=<span class="number">1575724220</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_07-<span class="number">0</span>@<span class="number">14</span>]]]</span><br><span class="line"></span><br><span class="line"># 故意 sleep <span class="number">10</span> 秒，延迟事务消息的提交</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">20.496</span>  INFO <span class="number">37455</span> --- [           main] c.i.s.l.k.producer.Demo07ProducerTest    : [run][我要开始睡觉了]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">30.500</span>  INFO <span class="number">37455</span> --- [           main] c.i.s.l.k.producer.Demo07ProducerTest    : [run][我睡醒了]</span><br><span class="line"></span><br><span class="line"># 在事务消息提交之后，事务消息才被 Consumer 消费到</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">30.558</span>  INFO <span class="number">37455</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo07Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo07Message&#123;id=<span class="number">1575724220</span>&#125;]</span><br></pre></td></tr></table></figure>



<ul>
<li>成功观察到，发送的事务消息，在提交之后才被 Consumer 消费到。</li>
</ul>
<h2 id="11-6-集成到-Spring-Transaction-体系"><a href="#11-6-集成到-Spring-Transaction-体系" class="headerlink" title="11.6 集成到 Spring Transaction 体系"></a>11.6 集成到 Spring Transaction 体系</h2><p>Spring-Kafka 提供了对 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction">Spring Transaction</a> 的集成，所以在实际开发中，我们只需要配合使用 <code>@Transactional</code> 注解，来声明事务即可，而无需使用 KafkaTemplate 提供的 <code>#executeInTransaction(...)</code> 模板方法。😈 是不是便捷很多呢!</p>
<p>具体的使用示例，艿艿就暂时不提供了，感兴趣的胖友可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59891ede5f90">《使用Kafka 事务的两种方式》</a> 文章。</p>
<h1 id="12-消费进度的提交机制"><a href="#12-消费进度的提交机制" class="headerlink" title="12. 消费进度的提交机制"></a>12. 消费进度的提交机制</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack">lab-03-kafka-demo-ack</a> 。</p>
</blockquote>
<p>原生 Kafka Consumer 消费端，有两种消费进度提交的提交机制：</p>
<ul>
<li>【默认】自动提交，通过配置 <code>enable.auto.commit=true</code> ，每过 <code>auto.commit.interval.ms</code> 时间间隔，都会自动提交消费消费进度。而提交的时机，是在 Consumer 的 <code>#poll(...)</code> 方法的逻辑里完成，在每次从 Kafka Broker 拉取消息时，会检查是否到达自动提交的时间间隔，如果是，那么就会提交上一次轮询拉取的位置。</li>
<li>手动提交，通过配置 <code>enable.auto.commit=false</code> ，后续通过 Consumer 的 <code>#commitSync(...)</code> 或 <code>#commitAsync(...)</code> 方法，同步或异步提交消费进度。</li>
</ul>
<p>Spring-Kafka Consumer 消费端，提供了更丰富的消费者进度的提交机制，更加灵活。当然，也是分成自动提交和手动提交两个大类。在 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/ContainerProperties.java#L44-L93">AckMode</a> 枚举类中，可以看到每一种具体的方式。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContainerProperties#AckMode.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AckMode</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 自动提交 ==========</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit after each record is processed by the listener.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RECORD, <span class="comment">// 每条消息被消费完成后，自动提交</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit whatever has already been processed before the next poll.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BATCH, <span class="comment">// 每一次消息被消费完成后，在下次拉取消息之前，自动提交</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit pending updates after</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ContainerProperties#setAckTime(long) ackTime&#125; has elapsed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TIME, <span class="comment">// 达到一定时间间隔后，自动提交。</span></span><br><span class="line">	      <span class="comment">// 不过要注意，它并不是一到就立马提交，如果此时正在消费某一条消息，需要等这条消息被消费完成，才能提交消费进度。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit pending updates after</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ContainerProperties#setAckCount(int) ackCount&#125; has been</span></span><br><span class="line"><span class="comment">	 * exceeded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	COUNT, <span class="comment">// 消费成功的消息数到达一定数量后，自动提交。</span></span><br><span class="line">	      <span class="comment">// 不过要注意，它并不是一到就立马提交，如果此时正在消费某一条消息，需要等这条消息被消费完成，才能提交消费进度。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit pending updates after</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ContainerProperties#setAckCount(int) ackCount&#125; has been</span></span><br><span class="line"><span class="comment">	 * exceeded or after &#123;<span class="doctag">@link</span> ContainerProperties#setAckTime(long)</span></span><br><span class="line"><span class="comment">	 * ackTime&#125; has elapsed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	COUNT_TIME, <span class="comment">// TIME 和 COUNT 的结合体，满足任一都会自动提交。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 手动提交 ==========</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User takes responsibility for acks using an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AcknowledgingMessageListener&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANUAL, <span class="comment">// 调用时，先标记提交消费进度。等到当前消息被消费完成，然后在提交消费进度。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User takes responsibility for acks using an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AcknowledgingMessageListener&#125;. The consumer</span></span><br><span class="line"><span class="comment">	 * immediately processes the commit.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANUAL_IMMEDIATE, <span class="comment">// 调用时，立即提交消费进度。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>看下每种方式，艿艿都添加了注释哟。</li>
</ul>
<p>那么，既然现在存在原生 Kafka 和 Spring-Kafka 提供的两种消费进度的提交机制，我们应该怎么配置呢？</p>
<ul>
<li>使用原生 Kafka 的方式，通过配置 <code>spring.kafka.consumer.enable-auto-commit=true</code> 。然后，通过 <code>spring.kafka.consumer.auto-commit-interval</code> 设置自动提交的频率。</li>
<li>使用 Spring-Kafka 的方式，通过配置 <code>spring.kafka.consumer.enable-auto-commit=false</code> 。然后通过 <code>spring.kafka.listener.ack-mode</code> 设置具体模式。另外，还有 <code>spring.kafka.listener.ack-time</code> 和 <code>spring.kafka.listener.ack-count</code> 可以设置自动提交的时间间隔和消息条数。</li>
</ul>
<p><strong>默认什么都不配置的情况下，使用 Spring-Kafka 的 BATCH 模式：每一次消息被消费完成后，在下次拉取消息之前，自动提交</strong>。</p>
<p>下面，我们开始本小节的示例，实现一个<strong>手动提交消息进度</strong>的消费者。考虑到不污染上述的示例，我们新建一个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack">lab-03-kafka-demo-ack</a> 项目。</p>
<h2 id="12-1-引入依赖"><a href="#12-1-引入依赖" class="headerlink" title="12.1 引入依赖"></a>12.1 引入依赖</h2><p>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.1 引入依赖」」</a>一致，见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-ack/pom.xml"><code>pom.xml</code></a> 文件</p>
<h2 id="12-2-应用配置文件"><a href="#12-2-应用配置文件" class="headerlink" title="12.2 应用配置文件"></a>12.2 应用配置文件</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/resources"><code>resources</code></a> 目录下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件。配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # Kafka 配置项，对应 KafkaProperties 配置类</span><br><span class="line">  kafka:</span><br><span class="line">    bootstrap-servers: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9092</span> # 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span><br><span class="line">    # Kafka Producer 配置项</span><br><span class="line">    producer:</span><br><span class="line">      acks: <span class="number">1</span> # <span class="number">0</span>-不应答。<span class="number">1</span>-leader 应答。all-所有 leader 和 follower 应答。</span><br><span class="line">      retries: <span class="number">3</span> # 发送失败时，重试发送的次数</span><br><span class="line">      key-serializer: org.apache.kafka.common.serialization.StringSerializer # 消息的 key 的序列化</span><br><span class="line">      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer # 消息的 value 的序列化</span><br><span class="line">    # Kafka Consumer 配置项</span><br><span class="line">    consumer:</span><br><span class="line">      auto-offset-reset: earliest # 设置消费者分组最初的消费进度为 earliest 。可参考博客 https:<span class="comment">//blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span></span><br><span class="line">      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer</span><br><span class="line">      enable-auto-commit: <span class="literal">false</span> # 使用 Spring-Kafka 的消费进度的提交机制</span><br><span class="line">      properties:</span><br><span class="line">        spring:</span><br><span class="line">          json:</span><br><span class="line">            trusted:</span><br><span class="line">              packages: cn.iocoder.springboot.lab03.kafkademo.message</span><br><span class="line">    # Kafka Consumer Listener 监听器配置</span><br><span class="line">    listener:</span><br><span class="line">      missing-topics-fatal: <span class="literal">false</span> # 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 <span class="literal">false</span> ，解决报错</span><br><span class="line">      ack-mode: MANUAL</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org:</span><br><span class="line">      springframework:</span><br><span class="line">        kafka: ERROR # spring-kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span><br><span class="line">      apache:</span><br><span class="line">        kafka: ERROR # kafka INFO 日志太多了，所以我们限制只打印 ERROR 级别</span><br></pre></td></tr></table></figure>



<ul>
<li><p>相比</p>
<p>「3.2 应用配置文件」</p>
<p>来说，增加如下两个参数：</p>
<ul>
<li>添加 <code>spring.kafka.consumer.enable-auto-commit=false</code> 配置，使用 Spring-Kafka 的消费进度的提交机制。😈 设计情况下，不添加该配置项也是可以的，因为 <code>false</code> 是默认值。</li>
<li>添加 <code>spring.kafka.listener.ack-mode=MANUAL</code> 配置，使用 MANUAL 模式：调用时，先标记提交消费进度。等到当前消息被消费完成，然后在提交消费进度。</li>
</ul>
</li>
</ul>
<h2 id="12-3-Demo08Message"><a href="#12-3-Demo08Message" class="headerlink" title="12.3 Demo08Message"></a>12.3 Demo08Message</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message"><code>cn.iocoder.springboot.lab03.kafkademo.message</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/java/cn/iocoder/springboot/lab03/kafkademo/message/Demo08Message.java">Demo08Message</a> 消息类，提供给当前示例使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo04Message.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;DEMO_08&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 set/get/toString 方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>TOPIC</code> 静态属性，我们设置该消息类对应 Topic 为 <code>&quot;DEMO_08&quot;</code> 。</li>
</ul>
<h2 id="12-4-Demo08Producer"><a href="#12-4-Demo08Producer" class="headerlink" title="12.4 Demo08Producer"></a>12.4 Demo08Producer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer"><code>cn.iocoder.springboot.lab03.kafkademo.producer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo08Producer.java">Demo08Producer</a> 类，它会使用 Kafka-Spring 封装提供的 KafkaTemplate ，同步发送消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo08Producer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">syncSend</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 Demo08Message 消息</span></span><br><span class="line">        <span class="type">Demo08Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo08Message</span>();</span><br><span class="line">        message.setId(id);</span><br><span class="line">        <span class="comment">// 同步发送消息</span></span><br><span class="line">        <span class="keyword">return</span> kafkaTemplate.send(Demo08Message.TOPIC, message).get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Boot/Kafka/#">「3.5 Demo01Producer」</a>的同步发送消息的代码是一致的，就是换成了 Demo08Message 。</li>
</ul>
<h2 id="12-5-Demo08Consumer"><a href="#12-5-Demo08Consumer" class="headerlink" title="12.5 Demo08Consumer"></a>12.5 Demo08Consumer</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/"><code>cn.iocoder.springboot.lab03.kafkademo.consumer</code></a> 包下，创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-03-kafka/lab-03-kafka-demo-ack/src/main/java/cn/iocoder/springboot/lab03/kafkademo/consumer/Demo08Consumer.java">Demo08Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo08Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo08Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo08-consumer-group-&quot; + Demo08Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo08Message message, Acknowledgment acknowledgment)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">        <span class="comment">// 提交消费进度</span></span><br><span class="line">        <span class="keyword">if</span> (message.getId() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            acknowledgment.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在消费方法上，我们增加了第二个方法参数，类型为 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/support/Acknowledgment.java">Acknowledgment</a> 类。通过调用其 <code>#acknowledge()</code> 方法，可以提交当前消息的 Topic 的 Partition 的消费进度。</li>
<li>在消费逻辑中，我们故意只提交消费的消息的 <code>Demo08Message.id</code> 为<strong>奇数</strong>的消息。😈 这样，我们只需要发送一条 <code>id=1</code> ，一条 <code>id=2</code> 的消息，如果第二条的消费进度没有被提交，就可以说明手动提交消费进度成功。</li>
</ul>
<h2 id="12-6-简单测试"><a href="#12-6-简单测试" class="headerlink" title="12.6 简单测试"></a>12.6 简单测试</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-03-kafka/lab-03-kafka-demo-ack/src/test/java/cn/iocoder/springboot/lab03/kafkademo/producer/Demo08ProducerTest.java">Demo08ProducerTest</a> 测试类，编写单元测试方法，测试手动提交消费进度。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo08ProducerTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Demo08Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSyncSend</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>; id &lt;= <span class="number">2</span>; id++) &#123;</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.syncSend(id);</span><br><span class="line">            logger.info(<span class="string">&quot;[testSyncSend][发送编号：[&#123;&#125;] 发送结果：[&#123;&#125;]]&quot;</span>, id, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，保证消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行 <code>#testSyncSend()</code> 单元测试，输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer 同步发送 2 条消息成功</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">20.914</span>  INFO <span class="number">43412</span> --- [           main] c.i.s.l.k.producer.Demo08ProducerTest    : [testSyncSend][发送编号：[<span class="number">1</span>] 发送结果：[SendResult [producerRecord=ProducerRecord(topic=DEMO_08, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">56</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo08Message&#123;id=<span class="number">1</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_08-<span class="number">0</span>@<span class="number">0</span>]]]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">20.916</span>  INFO <span class="number">43412</span> --- [           main] c.i.s.l.k.producer.Demo08ProducerTest    : [testSyncSend][发送编号：[<span class="number">2</span>] 发送结果：[SendResult [producerRecord=ProducerRecord(topic=DEMO_08, partition=<span class="literal">null</span>, headers=RecordHeaders(headers = [RecordHeader(key = __TypeId__, value = [<span class="number">99</span>, <span class="number">110</span>, <span class="number">46</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">115</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">48</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">46</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">68</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">48</span>, <span class="number">56</span>, <span class="number">77</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">101</span>])], isReadOnly = <span class="literal">true</span>), key=<span class="literal">null</span>, value=Demo08Message&#123;id=<span class="number">2</span>&#125;, timestamp=<span class="literal">null</span>), recordMetadata=DEMO_08-<span class="number">0</span>@<span class="number">1</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo08Consumer 消费 2 条消息成功</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">21.006</span>  INFO <span class="number">43412</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo08Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo08Message&#123;id=<span class="number">1</span>&#125;]</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">07</span> <span class="number">23</span>:<span class="number">41</span>:<span class="number">21.006</span>  INFO <span class="number">43412</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.consumer.Demo08Consumer        : [onMessage][线程编号:<span class="number">16</span> 消息内容：Demo08Message&#123;id=<span class="number">2</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>此时，如果我们使用 <a target="_blank" rel="noopener" href="https://github.com/yahoo/kafka-manager">Kafka Manager</a> 来查看 <code>&quot;DEMO_08&quot;</code> 的消费者列表：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F837ddfe7871e1cbaa4c1bf1c815e40ca.png" alt=" 的消费者列表"></p>
<ul>
<li>第 2 条消息的消费进度，未被提交，符合预期~</li>
</ul>
<h1 id="——–-4"><a href="#——–-4" class="headerlink" title="——–"></a>——–</h1><h1 id="SpringCloud中的Kafka"><a href="#SpringCloud中的Kafka" class="headerlink" title="SpringCloud中的Kafka"></a>SpringCloud中的Kafka</h1><h1 id="——–-5"><a href="#——–-5" class="headerlink" title="——–"></a>——–</h1><blockquote>
<p>本文在提供完整代码示例，可见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs">https://github.com/YunaiV/SpringBoot-Labs</a> 的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka">labx-11-spring-cloud-stream-kafka</a> 目录。</p>
<p>原创不易，给点个 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/stargazers">Star</a> 嘿，一起冲鸭！</p>
</blockquote>
<h1 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文我们来学习 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka">Spring Cloud Stream Kafka</a> 组件，基于 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream">Spring Cloud Stream</a> 的编程模型，接入 <strong>Kafka</strong> 作为消息中间件，实现消息驱动的微服务。</p>
<blockquote>
<p>FROM <a target="_blank" rel="noopener" href="https://www.oschina.net/p/kafka">《分布式发布订阅消息系统 Kafka》</a></p>
<p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，她有如下特性：</p>
<ul>
<li>通过 O(1) 的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li>
<li>高吞吐量：即使是非常普通的硬件kafka也可以支持每秒数十万的消息。</li>
<li>支持通过 Kafka 服务器和消费机集群来分区消息。</li>
</ul>
</blockquote>
<p>在开始本文之前，胖友需要对 Kafka 进行简单的学习。可以阅读<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/install/?self">《Kafka 极简入门》</a>文章，将第<strong>一二</strong>小节看完，在本机搭建一个 Kafka 服务。</p>
<h1 id="2-Spring-Cloud-Stream-介绍"><a href="#2-Spring-Cloud-Stream-介绍" class="headerlink" title="2. Spring Cloud Stream 介绍"></a>2. Spring Cloud Stream 介绍</h1><p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream">Spring Cloud Stream</a> 是一个用于构建基于<strong>消息</strong>的微服务应用框架，使用 <a target="_blank" rel="noopener" href="https://www.oschina.net/p/spring+integration">Spring Integration</a> 与 Broker 进行连接。</p>
<blockquote>
<p>友情提示：可能有胖友对 Broker 不太了解，我们来简单解释下。</p>
<p>一般来说，消息队列中间件都有一个 <strong>Broker Server</strong>（代理服务器），消息中转角色，负责存储消息、转发消息。</p>
<p>例如说在 RocketMQ 中，Broker 负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。另外，Broker 也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
</blockquote>
<p>Spring Cloud Stream 提供了消息中间件的<strong>统一抽象</strong>，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。</p>
<p>Spring Cloud Stream 内部有两个概念：<strong>Binder</strong> 和 <strong>Binding</strong>。</p>
<p>① **<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binder/Binder.java">Binder</a>**，跟消息中间件集成的组件，用来创建对应的 Binding。各消息中间件都有自己的 Binder 具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Binder</span>&lt;T, </span><br><span class="line">    C <span class="keyword">extends</span> <span class="title class_">ConsumerProperties</span>, <span class="comment">// 消费者配置</span></span><br><span class="line">    P <span class="keyword">extends</span> <span class="title class_">ProducerProperties</span>&gt; &#123; <span class="comment">// 生产者配置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建消费者的 Binding</span></span><br><span class="line">    Binding&lt;T&gt; <span class="title function_">bindConsumer</span><span class="params">(String name, String group, T inboundBindTarget, C consumerProperties)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者的 Binding</span></span><br><span class="line">    Binding&lt;T&gt; <span class="title function_">bindProducer</span><span class="params">(String name, T outboundBindTarget, P producerProperties)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Kafka 实现了 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka/src/main/java/org/springframework/cloud/stream/binder/kafka/KafkaMessageChannelBinder.java">KafkaMessageChannelBinder</a></li>
<li>RabbitMQ 实现了 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit/blob/master/spring-cloud-stream-binder-rabbit/src/main/java/org/springframework/cloud/stream/binder/rabbit/RabbitMessageChannelBinder.java">RabbitMessageChannelBinder</a></li>
<li>RocketMQ 实现了 <a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-stream-binder-rocketmq/src/main/java/com/alibaba/cloud/stream/binder/rocketmq/RocketMQMessageChannelBinder.java">RocketMQMessageChannelBinder</a></li>
</ul>
<p>② **<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binder/Binding.java">Binding</a>**，包括 Input Binding 和 Output Binding。Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。</p>
<p>最终整体交互如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F47e3a32ab66c617b0bb0a831760570c3.png" alt="Spring Cloud Stream Application"></p>
<p>可能看完之后，胖友对 Spring Cloud Stream 还是有点懵逼，并且觉得概念怎么这么多呢？不要慌，我们先来快速入个门，会有更加具象的感受。</p>
<h1 id="3-快速入门-1"><a href="#3-快速入门-1" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a></li>
</ul>
<p>友情提示：这可能是一个信息量有点大的入门内容，请保持耐心~</p>
</blockquote>
<p>本小节，我们一起来快速入门下，会创建 2 个项目，分别作为生产者和消费者。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F7c137d39b5a094ef9e804aa389cf5e1e.png" alt="项目结构"></p>
<h2 id="3-1-搭建生产者"><a href="#3-1-搭建生产者" class="headerlink" title="3.1 搭建生产者"></a>3.1 搭建生产者</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目，作为生产者。</p>
<h3 id="3-1-1-引入依赖"><a href="#3-1-1-引入依赖" class="headerlink" title="3.1.1 引入依赖"></a>3.1.1 引入依赖</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/pom.xml"><code>pom.xml</code></a> 文件中，引入 Spring Cloud Stream Kafka 相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>labx-11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.iocoder.springboot.labs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>labx-11-sc-stream-kafka-producer-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        引入 Spring Boot、Spring Cloud、Spring Cloud Alibaba 三者 BOM 文件，进行依赖版本的管理，防止不兼容。</span></span><br><span class="line"><span class="comment">        在 https://dwz.cn/mcLIfNKt 文章中，Spring Cloud Alibaba 开发团队推荐了三者的依赖关系</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 SpringMVC 相关依赖，并实现对其的自动配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入 Spring Cloud Stream Kafka 相关依赖，将 Kafka 作为消息队列，并实现对其的自动配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>通过引入 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-stream-kafka"><code>spring-cloud-starter-stream-kafka</code></a> 依赖，引入并实现 Stream Kafka 的自动配置。在该依赖中，已经帮我们自动引入 Kafka 的大量依赖，非常方便，如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F9d2db5b41ce3cbc563710dbbfcf3713b.png" alt="img"></p>
<h3 id="3-1-2-配置文件"><a href="#3-1-2-配置文件" class="headerlink" title="3.1.2 配置文件"></a>3.1.2 配置文件</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，添加 Spring Cloud Stream Kafka 相关配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-producer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">        <span class="comment"># Kafka 自定义 Binding 配置项，对应 KafkaBindingProperties Map</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-output:</span></span><br><span class="line">            <span class="comment"># Kafka Producer 配置项，对应 KafkaProducerProperties 类</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">sync:</span> <span class="literal">true</span> <span class="comment"># 是否同步发送消息，默认为 false 异步。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18080</span></span><br></pre></td></tr></table></figure>



<p>① <code>spring.cloud.stream</code> 为 Spring Cloud Stream 配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/config/BindingServiceProperties.java">BindingServiceProperties</a> 类。配置的层级有点深，我们一层一层来看看。</p>
<p>② <code>spring.cloud.stream.bindings</code> 为 Binding 配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/config/BindingProperties.java">BindingProperties</a> Map。其中，<em>key</em> 为 Binding 的名字。要注意，虽然说 Binding 分成 Input 和 Output 两种类型，但是在配置项中并不会体现出来，而是要在稍后搭配 <code>@Input</code> 还是 <code>@Output</code> 注解，才会有具体的区分。</p>
<p>这里，我们配置了一个名字为 <code>demo01-output</code> 的 Binding。从命名上，我们的意图是想作为 Output Binding，用于生产者发送消息。</p>
<ul>
<li><p><code>destination</code>：目的地。在 Kafka 中，使用 Topic 作为目的地。这里我们设置为 <code>DEMO-TOPIC-01</code>。</p>
<blockquote>
<p><strong>Topic（主题）</strong>：每条发布到 Kafka 的消息都有一个类别，这个类别被称为 Topic。</p>
</blockquote>
</li>
<li><p><code>content-type</code>：内容格式。这里使用 JSON 格式，因为稍后我们将发送消息的类型为 POJO，使用 JSON 进行序列化。</p>
</li>
</ul>
<p>③ <code>spring.cloud.stream.kafka</code> 为 Spring Cloud Stream Kafka 配置项。</p>
<p>④ <code>spring.cloud.stream.kafka.binder</code> 为 Kafka Binder 配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka-core/src/main/java/org/springframework/cloud/stream/binder/kafka/properties/KafkaBinderConfigurationProperties.java">KafkaBinderConfigurationProperties</a> 类。</p>
<ul>
<li><p><code>brokers</code>：指定 Kafka Broker 地址，可以设置多个，以逗号分隔。</p>
<blockquote>
<p><strong>Broker</strong>：Kafka 集群中的一台或多台服务器统称为 Broker。</p>
</blockquote>
</li>
</ul>
<p>⑤ <code>spring.cloud.stream.kafka.bindings</code> 为 Kafka <strong>自定义</strong> Binding 配置项，用于对<strong>通用的</strong> <code>spring.cloud.stream.bindings</code> 配置项的增强，实现 Kafka Binding 独特的配置。该配置项对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka-core/src/main/java/org/springframework/cloud/stream/binder/kafka/properties/KafkaBindingProperties.java">KafkaBindingProperties</a> Map，其中 <em>key</em> 为 Binding 的名字，需要对应上噢。</p>
<p>这里，我们对名字为 <code>demo01-output</code> 的 Binding 进行增强，进行 Producer 的配置。其中，<code>producer</code> 为 Kafka Producer 配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka-core/src/main/java/org/springframework/cloud/stream/binder/kafka/properties/KafkaProducerProperties.java">KafkaProducerProperties</a> 类。</p>
<ul>
<li><code>sync</code>：是否同步发送消息，默认为 <code>false</code> 异步。一般业务场景下，使用同步发送消息较多，所以这里我们设置为 <code>true</code> 同步消息。</li>
</ul>
<h3 id="3-1-3-MySource"><a href="#3-1-3-MySource" class="headerlink" title="3.1.3 MySource"></a>3.1.3 MySource</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/message/MySource.java">MySource</a> 接口，声明名字为 Output Binding。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MySource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Output(&quot;demo01-output&quot;)</span></span><br><span class="line">    MessageChannel <span class="title function_">demo01Output</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里，我们通过 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/annotation/Output.java"><code>@Output</code></a> 注解，声明了一个名字为 <code>demo01-output</code> 的 Output Binding。注意，这个名字要和我们配置文件中的 <code>spring.cloud.stream.bindings</code> 配置项对应上。</p>
<p>同时，<code>@Output</code> 注解的方法的返回结果为 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/MessageChannel.java">MessageChannel</a> 类型，可以使用它发送消息。MessageChannel 提供的发送消息的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageChannel</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="variable">INDEFINITE_TIMEOUT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">send</span><span class="params">(Message&lt;?&gt; message)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> send(message, INDEFINITE_TIMEOUT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">send</span><span class="params">(Message&lt;?&gt; message, <span class="type">long</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么，我们是否要实现 MySource 接口呢？答案是<strong>不需要</strong>，全部交给 Spring Cloud Stream 的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binding/BindableProxyFactory.java">BindableProxyFactory</a> 来解决。BindableProxyFactory 会通过动态代理，<strong>自动</strong>实现 MySource 接口。 而 <code>@Output</code> 注解的方法的返回值，BindableProxyFactory 会扫描带有 <code>@Output</code> 注解的方法，<strong>自动</strong>进行创建。</p>
<p>例如说，<code>#demo01Output()</code> 方法被<strong>自动</strong>创建返回结果为 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/messaging/DirectWithAttributesChannel.java">DirectWithAttributesChannel</a>，它是 MessageChannel 的子类。</p>
<blockquote>
<p>友情提示：感兴趣的胖友，可以在 BindableProxyFactory 的 <code>#afterPropertiesSet()</code> 和 <code>#invoke(MethodInvocation invocation)</code> 方法上，都打上一个断点，然后进行愉快的调试。</p>
</blockquote>
<h3 id="3-1-4-Demo01Message"><a href="#3-1-4-Demo01Message" class="headerlink" title="3.1.4 Demo01Message"></a>3.1.4 Demo01Message</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/message/Demo01Message.java">Demo01Message</a> 类，示例 Message 消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 setter/getter/toString 方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-5-Demo01Controller"><a href="#3-1-5-Demo01Controller" class="headerlink" title="3.1.5 Demo01Controller"></a>3.1.5 Demo01Controller</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/controller/Demo01Controller.java">Demo01Controller</a> 类，提供发送消息的 HTTP 接口。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MySource mySource; <span class="comment">// &lt;X&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt; 创建 Message</span></span><br><span class="line">        <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>()</span><br><span class="line">                .setId(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt());</span><br><span class="line">        <span class="comment">// &lt;2&gt; 创建 Spring Message 对象</span></span><br><span class="line">        Message&lt;Demo01Message&gt; springMessage = MessageBuilder.withPayload(message)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// &lt;3&gt; 发送消息</span></span><br><span class="line">        <span class="keyword">return</span> mySource.demo01Output().send(springMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>&lt;X&gt;</code> 处，使用 <code>@Autowired</code> 注解，注入 MySource Bean。</li>
<li><code>&lt;1&gt;</code> 处，创建 Demo01Message 对象。</li>
<li><code>&lt;2&gt;</code> 处，使用 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/support/MessageBuilder.java">MessageBuilder</a> 创建 Spring <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/Message.java">Message</a> 对象，并设置消息内容为 Demo01Message 对象。</li>
<li><code>&lt;3&gt;</code> 处，通过 MySource 获得 MessageChannel 对象，然后发送消息。</li>
</ul>
<h3 id="3-1-6-ProducerApplication"><a href="#3-1-6-ProducerApplication" class="headerlink" title="3.1.6 ProducerApplication"></a>3.1.6 ProducerApplication</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/ProducerApplication.java">ProducerApplication</a> 类，启动应用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBinding(MySource.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/annotation/EnableBinding.java"><code>@EnableBinding</code></a> 注解，声明指定接口开启 Binding 功能，扫描其 <code>@Input</code> 和 <code>@Output</code> 注解。这里，我们设置为 MySource 接口。</p>
<h2 id="3-2-搭建消费者"><a href="#3-2-搭建消费者" class="headerlink" title="3.2 搭建消费者"></a>3.2 搭建消费者</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，作为消费者。</p>
<h3 id="3-2-1-引入依赖"><a href="#3-2-1-引入依赖" class="headerlink" title="3.2.1 引入依赖"></a>3.2.1 引入依赖</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/pom.xml"><code>pom.xml</code></a> 文件中，引入 Spring Cloud Alibaba Kafka 相关依赖。</p>
<blockquote>
<p>友情提示：和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3.1.1 引入依赖」</a>基本一样，点击 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/pom.xml">链接</a> 查看。</p>
</blockquote>
<h3 id="3-2-2-配置文件"><a href="#3-2-2-配置文件" class="headerlink" title="3.2.2 配置文件"></a>3.2.2 配置文件</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，添加 Spring Cloud Stream Kafka 相关配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">demo01-consumer-group</span> <span class="comment"># 消费者分组</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<p>总体来说，和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3.1.2 配置文件」</a>是比较接近的，所以我们只说差异点噢。</p>
<p>① <code>spring.cloud.stream.bindings</code> 为 Binding 配置项。</p>
<p>这里，我们配置了一个名字为 <code>demo01-input</code> 的 Binding。从命名上，我们的意图是想作为 Input Binding，用于消费者消费消息。</p>
<ul>
<li><p><code>group</code>：消费者分组。</p>
<blockquote>
<p><strong>消费者组（Consumer Group）</strong>：同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic。</p>
</blockquote>
</li>
</ul>
<p>对于消费队列的消费者，会有两种消费模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<blockquote>
<ul>
<li><strong>集群消费（Clustering）</strong>：集群消费模式下,相同 Consumer Group 的每个 Consumer 实例平均分摊消息。</li>
<li><strong>广播消费（Broadcasting）</strong>：广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。</li>
</ul>
</blockquote>
<p>Kafka 的消费者<strong>两种模式都支持</strong>。因为这里我们配置了消费者组，所以采用<strong>集群消费</strong>。至于如何使用广播消费，我们稍后举例子。</p>
<p>这里一点要注意！！！艿艿加了三个感叹号，一定要理解集群消费和广播消费的差异。我们来举个例子，以有两个消费者分组 A 和 B 的场景举例子：</p>
<ul>
<li>假设每个消费者分组各启动<strong>一个</strong>实例，此时我们发送一条消息，该消息会被两个消费者分组 <code>&quot;consumer_group_01&quot;</code> 和 <code>&quot;consumer_group_02&quot;</code> 都各自消费一次。</li>
<li>假设每个消费者分组各启动<strong>一个</strong>实例，此时我们发送一条消息，该消息会被分组 A 的<strong>某个</strong>实例消费一次，被分组 B 的<strong>某个</strong>实例也消费一次</li>
</ul>
<p>通过<strong>集群消费</strong>的机制，我们可以实现针对相同 Topic ，不同消费者分组实现各自的业务逻辑。例如说：用户注册成功时，发送一条 Topic 为 <code>&quot;USER_REGISTER&quot;</code> 的消息。然后，不同模块使用不同的消费者分组，订阅该 Topic ，实现各自的拓展逻辑：</p>
<ul>
<li>积分模块：判断如果是手机注册，给用户增加 20 积分。</li>
<li>优惠劵模块：因为是新用户，所以发放新用户专享优惠劵。</li>
<li>站内信模块：因为是新用户，所以发送新用户的欢迎语的站内信。</li>
<li>… 等等</li>
</ul>
<p>这样，我们就可以将注册成功后的业务拓展逻辑，实现业务上的<strong>解耦</strong>，未来也更加容易拓展。同时，也提高了注册接口的性能，避免用户需要等待业务拓展逻辑执行完成后，才响应注册成功。</p>
<p>同时，相同消费者分组的多个实例，可以实现<strong>高可用</strong>，保证在一个实例意外挂掉的情况下，其它实例能够顶上。并且，多个实例都进行消费，能够提升<strong>消费速度</strong>。</p>
<blockquote>
<p>友情提示：如果还不理解的话，没有关系，我们下面会演示下我们上面举的例子。</p>
</blockquote>
<p>② 考虑到稍后我们要测试集群消费，所以我们要给 <code>DEMO-TOPIC-01</code> Topic 创建多个 Partition。在 Kafka 中，Topic 是基于 Partition 分配到相同消费组下的消费者，从而进行消费消息的。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F10942550a4f09160875fadab05545655.png" alt="消费者分区"></p>
<blockquote>
<p><strong>Partition（分区）</strong>：Topic 物理上的分组，一个 Topic 可以分为多个 Partition ，每个 Partition 是一个有序的队列。Partition 中的每条消息都会被分配一个有序的 id（offset）。</p>
</blockquote>
<p>这里，我们给 <code>DEMO-TOPIC-01</code> Topic 创建 Partition 大小为 10。操作命令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 情况一，如果 `DEMO-TOPIC-<span class="number">01</span>` Topic 未创建，则进行创建：</span><br><span class="line">$ bin/kafka-topics.sh --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span> --create --topic my-topic --partitions <span class="number">10</span> --replication-factor <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 情况二，如果 `DEMO-TOPIC-<span class="number">01</span>` Topic 未创建，则进行修改 Partition 大小：</span><br><span class="line">$ bin/kafka-topics.sh --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span> -alter --partitions <span class="number">10</span> --topic DEMO-TOPIC-<span class="number">01</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-3-MySink"><a href="#3-2-3-MySink" class="headerlink" title="3.2.3 MySink"></a>3.2.3 MySink</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/MySink.java">MySink</a> 接口，声明名字为 Input Binding。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MySink</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">DEMO01_INPUT</span> <span class="operator">=</span> <span class="string">&quot;demo01-input&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Input(DEMO01_INPUT)</span></span><br><span class="line">    SubscribableChannel <span class="title function_">demo01Input</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里，我们通过 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/annotation/Input.java"><code>@Input</code></a> 注解，声明了一个名字为 <code>demo01-input</code> 的 Input Binding。注意，这个名字要和我们配置文件中的 <code>spring.cloud.stream.bindings</code> 配置项对应上。</p>
<p>同时，<code>@Input</code> 注解的方法的返回结果为 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/SubscribableChannel.java">SubscribableChannel</a> 类型，可以使用它订阅消息来消费。MessageChannel 提供的订阅消息的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SubscribableChannel</span> <span class="keyword">extends</span> <span class="title class_">MessageChannel</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">subscribe</span><span class="params">(MessageHandler handler)</span>; <span class="comment">// 订阅</span></span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">unsubscribe</span><span class="params">(MessageHandler handler)</span>; <span class="comment">// 取消订阅</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么，我们是否要实现 MySink 接口呢？答案也是<strong>不需要</strong>，还是全部交给 Spring Cloud Stream 的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binding/BindableProxyFactory.java">BindableProxyFactory</a> 大兄弟来解决。BindableProxyFactory 会通过动态代理，<strong>自动</strong>实现 MySink 接口。 而 <code>@Input</code> 注解的方法的返回值，BindableProxyFactory 会扫描带有 <code>@Input</code> 注解的方法，<strong>自动</strong>进行创建。</p>
<p>例如说，<code>#demo01Input()</code> 方法被<strong>自动</strong>创建返回结果为 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/messaging/DirectWithAttributesChannel.java">DirectWithAttributesChannel</a>，它也是 SubscribableChannel 的子类。</p>
<blockquote>
<p>友情提示：感兴趣的胖友，可以在 BindableProxyFactory 的 <code>#afterPropertiesSet()</code> 和 <code>#invoke(MethodInvocation invocation)</code> 方法上，都打上一个断点，然后进行愉快的调试。</p>
</blockquote>
<h3 id="3-2-4-Demo01Message"><a href="#3-2-4-Demo01Message" class="headerlink" title="3.2.4 Demo01Message"></a>3.2.4 Demo01Message</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/message/Demo01Message.java">Demo01Message</a> 类，示例 Message 消息。</p>
<blockquote>
<p>友情提示：和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3.1.4 Demo01Message」</a>基本一样，点击 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/message/Demo01Message.java">链接</a> 查看。</p>
</blockquote>
<h3 id="3-2-5-Demo01Consumer"><a href="#3-2-5-Demo01Consumer" class="headerlink" title="3.2.5 Demo01Consumer"></a>3.2.5 Demo01Consumer</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/Demo01Consumer.java">Demo01Consumer</a> 类，消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(MySink.DEMO01_INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> Demo01Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在方法上，添加 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/annotation/StreamListener.java"><code>@StreamListener</code></a> 注解，声明对应的 <strong>Input</strong> Binding。这里，我们使用 <code>MySink.DEMO01_INPUT</code>。</p>
<p>又因为我们消费的消息是 POJO 类型，所以我们需要添加 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/Payload.java"><code>@Payload</code></a> 注解，声明需要进行反序列化成 POJO 对象。</p>
<h3 id="3-2-6-ConsumerApplication"><a href="#3-2-6-ConsumerApplication" class="headerlink" title="3.2.6 ConsumerApplication"></a>3.2.6 ConsumerApplication</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/ConsumerApplication.java">ConsumerApplication</a> 类，启动应用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBinding(MySink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/annotation/EnableBinding.java"><code>@EnableBinding</code></a> 注解，声明指定接口开启 Binding 功能，扫描其 <code>@Input</code> 和 <code>@Output</code> 注解。这里，我们设置为 MySink 接口。</p>
<h2 id="3-3-测试单集群多实例的场景"><a href="#3-3-测试单集群多实例的场景" class="headerlink" title="3.3 测试单集群多实例的场景"></a>3.3 测试单集群多实例的场景</h2><p>本小节，我们会在<strong>一个</strong>消费者集群启动<strong>两个</strong>实例，测试在集群消费的情况下的表现。</p>
<p>① 执行 <strong>Consumer</strong>Application 两次，启动两个<strong>消费者</strong>的实例，从而实现在消费者分组 <code>demo01-consumer-group</code> 下有两个消费者实例。</p>
<blockquote>
<p>友情提示：因为 IDEA 默认同一个程序只允许启动 1 次，所以我们需要配置 DemoProviderApplication 为 <code>Allow parallel run</code>。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F1f4cf03d2094060a2c939d78883a69aa.png" alt="Allow parallel run"></p>
</blockquote>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口十次，发送十条消息。此时在 IDEA 控制台看到消费者打印日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerApplication 控制台 01</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">50.461</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=<span class="number">1983864145</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">53.081</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">2014337623</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">53.475</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">250644839</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">53.844</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=<span class="number">2143820238</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">54.289</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=<span class="number">1421045645</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConsumerApplication 控制台 02</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">51.009</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">132504622</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">51.416</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">2052532135</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">51.824</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">223534414</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.262</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">1525635094</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.666</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">688399661</span>&#125;]</span><br></pre></td></tr></table></figure>



<p><strong>符合预期</strong>。从日志可以看出，每条消息仅被消费一次。</p>
<h2 id="3-4-测试多集群多实例的场景"><a href="#3-4-测试多集群多实例的场景" class="headerlink" title="3.4 测试多集群多实例的场景"></a>3.4 测试多集群多实例的场景</h2><p>本小节，我们会在<strong>二个</strong>消费者集群<strong>各</strong>启动<strong>两个</strong>实例，测试在集群消费的情况下的表现。</p>
<p>① 执行 <strong>Consumer</strong>Application 两次，启动两个<strong>消费者</strong>的实例，从而实现在消费者分组 <code>demo01-consumer-group</code> 下有两个消费者实例。</p>
<p>② 修改 <code>labx-11-sc-stream-kafka-consumer-demo</code> 项目的配置文件，修改 <code>spring.cloud.stream.bindings.demo01-input.group</code> 配置项，将消费者分组改成 <code>demo02-consumer-group</code>。</p>
<p>然后，执行 <strong>Consumer</strong>Application 两次，再启动两个<strong>消费者</strong>的实例，从而实现在消费者分组 <code>demo02-consumer-group</code> 下有两个消费者实例。</p>
<p>③ 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口十次，发送十条消息。此时在 IDEA 控制台看到消费者打印日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者分组 `demo01-consumer-group` 的 ConsumerApplication 控制台 01</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">34.728</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">1737808914</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">37.728</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">2140451405</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">38.203</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=<span class="number">813702607</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">38.601</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">1028557655</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">39.024</span>  INFO <span class="number">65124</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">399853121</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者分组 `demo01-consumer-group` 的 ConsumerApplication 控制台 02</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">35.196</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1461873560</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">35.717</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1947944757</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">36.176</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">151575160</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">36.789</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">88228856</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">37.272</span>  INFO <span class="number">65177</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">790199000</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者分组 `demo02-consumer-group` 的 ConsumerApplication 控制台 01</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">35.196</span>  INFO <span class="number">65419</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1461873560</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">35.717</span>  INFO <span class="number">65419</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1947944757</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">36.176</span>  INFO <span class="number">65419</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">151575160</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">36.789</span>  INFO <span class="number">65419</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">88228856</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">37.272</span>  INFO <span class="number">65419</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">790199000</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者分组 `demo02-consumer-group` 的 ConsumerApplication 控制台 02</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">34.728</span>  INFO <span class="number">65422</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1737808914</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">37.728</span>  INFO <span class="number">65422</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">2140451405</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">38.204</span>  INFO <span class="number">65422</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">813702607</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">38.601</span>  INFO <span class="number">65422</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1028557655</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">21</span>:<span class="number">07</span>:<span class="number">39.024</span>  INFO <span class="number">65422</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">399853121</span>&#125;]</span><br></pre></td></tr></table></figure>



<p><strong>符合预期</strong>。从日志可以看出，每条消息被<strong>每个</strong>消费者集群都进行了消费，且仅被消费一次。</p>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>至此，我们已经完成了 Stream Kafka 的快速入门，是不是还是蛮简答的噢。现在胖友可以在回过头看看 Binder 和 Binding 的概念，是不是就清晰一些了。</p>
<h1 id="4-定时消息"><a href="#4-定时消息" class="headerlink" title="4. 定时消息"></a>4. 定时消息</h1><p><strong>Kafka 并未提供定时消息的功能，需要我们自行拓展</strong>。</p>
<p>例如说<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/delayed-message-consume-service-use-kafka/?self">《基于 Kafka 的定时消息&#x2F;任务服》</a>文章，提供的方案。</p>
<p>当然，也可以考虑基于 MySQL 存储定时消息，Job 扫描到达时间的定时消息，发送给 Kafka 。</p>
<h1 id="5-消费重试"><a href="#5-消费重试" class="headerlink" title="5. 消费重试"></a>5. 消费重试</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-retry/"><code>labx-11-sc-stream-kafka-consumer-retry</code></a></li>
</ul>
</blockquote>
<p>Spring-Kafka 提供<strong>消费重试</strong>的机制。在消息<strong>消费失败</strong>的时候，Spring-Kafka 会通过<strong>消费重试</strong>机制，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。</p>
<blockquote>
<p>友情提示：Spring Cloud Stream Kafka 是基于 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka">Spring-Kafka</a> 操作 Kafka，它仅仅是上层的封装哟。</p>
</blockquote>
<p>当然，Spring-Kafka 并不会无限重新投递消息给 Consumer 重新消费，而是在默认情况下，达到 N 次重试次数时，Consumer 还是消费失败时，该消息就会进入到<strong>死信队列</strong>。</p>
<blockquote>
<p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，Spring-Kafka 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，Spring-Kafka 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>Spring-Kafka 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。后续，我们可以通过对死信队列中的消息进行重发，来使得消费者实例再次进行消费。</p>
</blockquote>
<ul>
<li>在<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self">《芋道 Spring Boot 消息队列 RocketMQ 入门》</a>的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「6. 消费重试」</a>小节中，我们可以看到，消费重试和死信队列，是 RocketMQ 自带的功能。</li>
<li>而在 Kafka 中，消费重试和死信队列，是由 Spring-Kafka 所封装提供的。</li>
</ul>
<p>每条消息的失败重试，是可以配置一定的<strong>间隔时间</strong>。具体，我们在示例的代码中，来进行具体的解释。</p>
<p>下面，我们来实现一个 Consumer 消费重试的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F8e3c8812b8a1c0abc2aada0b3d195e61.png" alt="项目结构"></p>
<h2 id="5-1-搭建生产者"><a href="#5-1-搭建生产者" class="headerlink" title="5.1 搭建生产者"></a>5.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h2 id="5-2-搭建消费者"><a href="#5-2-搭建消费者" class="headerlink" title="5.2 搭建消费者"></a>5.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-retry/"><code>labx-11-sc-stream-kafka-consumer-retry</code></a> 项目作为消费者。</p>
<h3 id="5-2-1-配置文件"><a href="#5-2-1-配置文件" class="headerlink" title="5.2.1 配置文件"></a>5.2.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-retry/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，增加<strong>消费重试</strong>相关的配置项。最终配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">demo01-consumer-group</span> <span class="comment"># 消费者分组</span></span><br><span class="line">          <span class="comment"># Consumer 配置项，对应 ConsumerProperties 类</span></span><br><span class="line">          <span class="attr">consumer:</span></span><br><span class="line">            <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 重试次数，默认为 3 次。</span></span><br><span class="line">            <span class="attr">back-off-initial-interval:</span> <span class="number">3000</span> <span class="comment"># 重试间隔的初始值，单位毫秒，默认为 1000</span></span><br><span class="line">            <span class="attr">back-off-multiplier:</span> <span class="number">2.0</span> <span class="comment"># 重试间隔的递乘系数，默认为 2.0</span></span><br><span class="line">            <span class="attr">back-off-max-interval:</span> <span class="number">10000</span> <span class="comment"># 重试间隔的最大值，单位毫秒，默认为 10000</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">        <span class="comment"># Kafka Binding 配置项，对应 KafkaBindingProperties 类</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-input:</span></span><br><span class="line">            <span class="comment"># Kafka Consumer 配置项，对应 KafkaConsumerProperties 类</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">enable-dlq:</span> <span class="literal">true</span> <span class="comment"># 是否开启死信队列，默认为 false 关闭</span></span><br><span class="line">              <span class="attr">dlq-name:</span> <span class="comment"># 死信队列名，默认为 `errors.&#123;topicName&#125;.&#123;consumerGroup&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<p>① <code>spring.cloud.stream.bindings.&lt;bindingName&gt;.consumer</code> 为 Spring Cloud Stream Consumer <strong>通用</strong>配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binder/ConsumerProperties.java">ConsumerProperties</a> 类。</p>
<ul>
<li><p><code>max-attempts</code>：最大重试次数，默认为 3 次。如果想要禁用掉重试，可以设置为 1。</p>
<blockquote>
<p><code>max-attempts</code> 配置项要注意，是一条消息一共尝试消费总共 <code>max-attempts</code> 次，包括首次的正常消费。</p>
</blockquote>
</li>
<li><p><code>back-off-initial-interval</code>：重试间隔的初始值，单位毫秒，默认为 1000。</p>
</li>
<li><p><code>back-off-multiplier</code>：重试间隔的递乘系数，默认为 2.0。</p>
</li>
<li><p><code>back-off-max-interval</code>：重试间隔的最大值，单位毫秒，默认为 10000。</p>
</li>
</ul>
<p>将四个参数组合在一起，我们来看一个消费重试的过程：</p>
<ul>
<li>第一次 00:00:00：首次消费，失败。</li>
<li>第二次 00:00:03：3 秒后重试，因为重试间隔的初始值为 <code>back-off-initial-interval</code>，等于 3000 毫秒。</li>
<li>第三次 00:00:09：6 秒后重试，因为有重试间隔的递乘系数 <code>back-off-multiplier</code>，所以是 <code>2.0 * 3000</code> 等于 6000 毫秒。</li>
<li>第四次，没有，因为到达最大重试次数，等于 3。</li>
</ul>
<p>② <code>spring.cloud.stream.kafka.bindings.&lt;bindingName&gt;.consumer</code> 为 Spring Cloud Stream Kafka Consumer <strong>专属</strong>配置项，我们新增了两个配置项：</p>
<ul>
<li><code>enable-dlq</code>：是否开启死信队列，默认为 <code>false</code> 关闭。这里，问问们设置为 <code>true</code> 来进行开启。</li>
<li><code>dlq-name</code>：死信队列名，默认为 <code>errors.&#123;topicName&#125;.&#123;consumerGroup&#125;</code>。这里我们并未设置，直接使用默认，即本小节的示例对应 <code>errors.DEMO-TOPIC-01.demo01-consumer-group</code>。</li>
</ul>
<h3 id="5-2-2-Demo01Consumer"><a href="#5-2-2-Demo01Consumer" class="headerlink" title="5.2.2 Demo01Consumer"></a>5.2.2 Demo01Consumer</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-retry/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/Demo01Consumer.java">Demo01Consumer</a> 类，直接抛出异常，模拟消费失败，从而演示消费重试的功能。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(MySink.DEMO01_INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> Demo01Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">        <span class="comment">// &lt;X&gt; 注意，此处抛出一个 RuntimeException 异常，模拟消费失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我就是故意抛出一个异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3-简单测试-1"><a href="#5-3-简单测试-1" class="headerlink" title="5.3 简单测试"></a>5.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动一个<strong>消费者</strong>的实例。</p>
<p>我们打开 Kafka 运维界面，可以看到多了一个 <code>errors.DEMO-TOPIC-01.demo01-consumer-group</code> Topic，即本小节的死信队列。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F96a5da899c1e3fb6863a5c9f8757edc3.png" alt=" Topic"></p>
<blockquote>
<p>友情提示：Kafka 运维界面，可以看看<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/install/?self">《芋道 Kafka 极简入门》</a>文章的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「4. Kafka Manager」</a>小节。</p>
</blockquote>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口，发送消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次消费</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">22</span>:<span class="number">14</span>:<span class="number">55.465</span>  INFO <span class="number">67252</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">1264911073</span>&#125;]</span><br><span class="line"><span class="comment">// 第二次消费，3 秒后</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">22</span>:<span class="number">14</span>:<span class="number">58.467</span>  INFO <span class="number">67252</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">1264911073</span>&#125;]</span><br><span class="line"><span class="comment">// 第三次消费，6 秒后</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">22</span>:<span class="number">15</span>:<span class="number">04.471</span>  INFO <span class="number">67252</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">1264911073</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置的 LoggingHandler 打印异常日志</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">22</span>:<span class="number">15</span>:<span class="number">04.473</span> ERROR <span class="number">67252</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.s.integration.handler.LoggingHandler   : org.springframework.messaging.MessagingException: Exception thrown <span class="keyword">while</span> invoking Demo01Consumer#onMessage[<span class="number">1</span> args]; nested exception is java.lang.RuntimeException: 我就是故意抛出一个异常 <span class="comment">// ... 省略异常堆栈</span></span><br><span class="line">Caused by: java.lang.RuntimeException: 我就是故意抛出一个异常 <span class="comment">// ... 省略异常堆栈</span></span><br></pre></td></tr></table></figure>



<p>测试 Consumer 消费重试成功~</p>
<p>不过要<strong>注意</strong>，目前我们看到的重试方案，是通过 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-retry/docs/api/current/org/springframework/retry/support/RetryTemplate.html">RetryTemplate</a> 来实现<strong>客户端级别</strong>的消费冲水。而 RetryTemplate 又是通过 <strong>sleep</strong> 来实现消费间隔的时候，这样将影响 Consumer 的整体消费速度，毕竟 sleep 会占用掉线程。</p>
<h1 id="6-消费异常处理机制"><a href="#6-消费异常处理机制" class="headerlink" title="6. 消费异常处理机制"></a>6. 消费异常处理机制</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-error-handler/"><code>labx-11-sc-stream-kafka-consumer-error-handler</code></a></li>
</ul>
</blockquote>
<p>在 Spring Cloud Stream 中，提供了<strong>通用</strong>的消费异常处理机制，可以拦截到消费者消费消息时发生的异常，进行自定义的处理逻辑。</p>
<p>下面，我们来搭建一个 Spring Cloud Stream 消费异常处理机制的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fb7a0fbeef788a195540c64c0a63f187e.png" alt="项目结构"></p>
<h2 id="6-1-搭建生产者"><a href="#6-1-搭建生产者" class="headerlink" title="6.1 搭建生产者"></a>6.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h2 id="6-2-搭建消费者"><a href="#6-2-搭建消费者" class="headerlink" title="6.2 搭建消费者"></a>6.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「5. 消费重试」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-retry/"><code>labx-11-sc-stream-kafka-consumer-retry</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-error-handler/"><code>labx-11-sc-stream-kafka-consumer-error-handler</code></a> 项目作为消费者。</p>
<h3 id="6-2-1-Demo01Consumer"><a href="#6-2-1-Demo01Consumer" class="headerlink" title="6.2.1 Demo01Consumer"></a>6.2.1 Demo01Consumer</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-error-handler/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/Demo01Consumer.java">Demo01Consumer</a> 类，增加消费异常处理方法。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(MySink.DEMO01_INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> Demo01Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">        <span class="comment">// &lt;X&gt; 注意，此处抛出一个 RuntimeException 异常，模拟消费失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我就是故意抛出一个异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;DEMO-TOPIC-01.demo01-consumer-group.errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(ErrorMessage errorMessage)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;[handleError][payload：&#123;&#125;]&quot;</span>, errorMessage.getPayload().getMessage());</span><br><span class="line">        logger.error(<span class="string">&quot;[handleError][originalMessage：&#123;&#125;]&quot;</span>, errorMessage.getOriginalMessage());</span><br><span class="line">        logger.error(<span class="string">&quot;[handleError][headers：&#123;&#125;]&quot;</span>, errorMessage.getHeaders());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME)</span> <span class="comment">// errorChannel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">globalHandleError</span><span class="params">(ErrorMessage errorMessage)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;[globalHandleError][payload：&#123;&#125;]&quot;</span>, errorMessage.getPayload().getMessage());</span><br><span class="line">        logger.error(<span class="string">&quot;[globalHandleError][originalMessage：&#123;&#125;]&quot;</span>, errorMessage.getOriginalMessage());</span><br><span class="line">        logger.error(<span class="string">&quot;[globalHandleError][headers：&#123;&#125;]&quot;</span>, errorMessage.getHeaders());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>① 在 Spring Integration 的设定中，若 <code>#onMessage(@Payload Demo01Message message)</code> 方法消费消息发生异常时，会发送错误消息（<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/support/ErrorMessage.java">ErrorMessage</a>）到对应的**错误 Channel（<code>&lt;destination&gt;.&lt;group&gt;.errors</code>）**中。同时，所有错误 Channel 都桥接到了 Spring Integration 定义的**全局错误 Channel(<code>errorChannel</code>)**。</p>
<blockquote>
<p>友情提示：先暂时记住 Spring Integration 这样的设定，艿艿也没去深究 T T，也是一脸懵逼。</p>
</blockquote>
<p>因此，我们有<strong>两种</strong>方式来实现异常处理：</p>
<ul>
<li><strong>局部</strong>的异常处理：通过订阅指定<strong>错误 Channel</strong></li>
<li><strong>全局</strong>的异常处理：通过订阅<strong>全局错误 Channel</strong></li>
</ul>
<p>② 在 <code>#handleError(ErrorMessage errorMessage)</code> 方法上，我们声明了 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-core/src/main/java/org/springframework/integration/annotation/ServiceActivator.java"><code>@ServiceActivator</code></a> 注解，订阅<strong>指定错误 Channel</strong>的错误消息，实现 <code>#onMessage(@Payload Demo01Message message)</code> 方法的<strong>局部</strong>异常处理。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fb6c58f403ca177f11cc89b8c8d2f3800.png" alt="对应关系"></p>
<p>③ 在 <code>#globalHandleError(ErrorMessage errorMessage)</code> 方法上，我们声明了 <code>@StreamListener</code> 注解，订阅<strong>全局错误 Channel</strong>的错误消息，实现<strong>全局</strong>异常处理。</p>
<p>④ 在<strong>全局</strong>和<strong>局部</strong>异常处理都定义的情况下，错误消息仅会被<strong>符合条件</strong>的<strong>局部</strong>错误异常处理。如果没有符合条件的，错误消息才会被<strong>全局</strong>异常处理。</p>
<h2 id="6-3-简单测试"><a href="#6-3-简单测试" class="headerlink" title="6.3 简单测试"></a>6.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口，发送一条消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onMessage 方法，一共 3 次，包括重试</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">07</span>:<span class="number">38</span>:<span class="number">23.037</span>  INFO <span class="number">68126</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">1512001860</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">07</span>:<span class="number">38</span>:<span class="number">26.045</span>  INFO <span class="number">68126</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">1512001860</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">07</span>:<span class="number">38</span>:<span class="number">32.046</span>  INFO <span class="number">68126</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">1512001860</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleError 方法</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">07</span>:<span class="number">38</span>:<span class="number">32.054</span> ERROR <span class="number">68126</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [handleError][payload：Exception thrown <span class="keyword">while</span> invoking Demo01Consumer#onMessage[<span class="number">1</span> args]; nested exception is java.lang.RuntimeException: 我就是故意抛出一个异常]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">07</span>:<span class="number">38</span>:<span class="number">32.054</span> ERROR <span class="number">68126</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [handleError][originalMessage：GenericMessage [payload=<span class="type">byte</span>[<span class="number">18</span>], headers=&#123;kafka_offset=<span class="number">45</span>, scst_nativeHeadersPresent=<span class="literal">true</span>, kafka_consumer=org.apache.kafka.clients.consumer.KafkaConsumer<span class="meta">@e32f669</span>, deliveryAttempt=<span class="number">3</span>, kafka_timestampType=CREATE_TIME, kafka_receivedMessageKey=<span class="literal">null</span>, kafka_receivedPartitionId=<span class="number">0</span>, contentType=application/json, kafka_receivedTopic=DEMO-TOPIC-<span class="number">01</span>, kafka_receivedTimestamp=<span class="number">1583710702910</span>, kafka_groupId=demo01-consumer-group&#125;]]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">07</span>:<span class="number">38</span>:<span class="number">32.054</span> ERROR <span class="number">68126</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [handleError][headers：&#123;kafka_data=ConsumerRecord(topic = DEMO-TOPIC-<span class="number">01</span>, partition = <span class="number">0</span>, leaderEpoch = <span class="number">0</span>, offset = <span class="number">45</span>, CreateTime = <span class="number">1583710702910</span>, serialized <span class="type">key</span> <span class="variable">size</span> <span class="operator">=</span> -<span class="number">1</span>, serialized <span class="type">value</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">18</span>, headers = RecordHeaders(headers = [RecordHeader(key = contentType, value = [<span class="number">34</span>, <span class="number">97</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">99</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">47</span>, <span class="number">106</span>, <span class="number">115</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">34</span>]), RecordHeader(key = spring_json_header_types, value = [<span class="number">123</span>, <span class="number">34</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">84</span>, <span class="number">121</span>, <span class="number">112</span>, <span class="number">101</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">34</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">34</span>, <span class="number">125</span>])], isReadOnly = <span class="literal">false</span>), key = <span class="literal">null</span>, value = [B@57ae40f0), id=e6852311-62b5-cc85-1f63-cef9a01847a2, sourceData=ConsumerRecord(topic = DEMO-TOPIC-<span class="number">01</span>, partition = <span class="number">0</span>, leaderEpoch = <span class="number">0</span>, offset = <span class="number">45</span>, CreateTime = <span class="number">1583710702910</span>, serialized <span class="type">key</span> <span class="variable">size</span> <span class="operator">=</span> -<span class="number">1</span>, serialized <span class="type">value</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">18</span>, headers = RecordHeaders(headers = [RecordHeader(key = contentType, value = [<span class="number">34</span>, <span class="number">97</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">99</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">47</span>, <span class="number">106</span>, <span class="number">115</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">34</span>]), RecordHeader(key = spring_json_header_types, value = [<span class="number">123</span>, <span class="number">34</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">84</span>, <span class="number">121</span>, <span class="number">112</span>, <span class="number">101</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">34</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">34</span>, <span class="number">125</span>])], isReadOnly = <span class="literal">false</span>), key = <span class="literal">null</span>, value = [B@57ae40f0), timestamp=<span class="number">1583710712046</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>😆 不过要注意，如果异常处理方法成功，没有重新抛出异常，会认定为该消息被<strong>消费成功</strong>，所以就不会发到死信队列了噢。</p>
<h1 id="7-广播消费"><a href="#7-广播消费" class="headerlink" title="7. 广播消费"></a>7. 广播消费</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-broadcasting/"><code>labx-11-sc-stream-kafka-consumer-broadcasting</code></a></li>
</ul>
</blockquote>
<p>在上述的示例中，我们看到的都是使用集群消费。而在一些场景下，我们需要使用<strong>广播消费</strong>。</p>
<blockquote>
<p>广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。</p>
</blockquote>
<p><strong>使用场景？</strong></p>
<p>例如说，在应用中，缓存了数据字典等配置表在内存中，可以通过 Kafka 广播消费，实现每个应用节点都消费消息，刷新本地内存的缓存。</p>
<p>又例如说，我们基于 WebSocket 实现了 IM 聊天，在我们给用户主动发送消息时，因为我们不知道用户连接的是哪个提供 WebSocket 的应用，所以可以通过 Kafka 广播消费，每个应用判断当前用户是否是和自己提供的 WebSocket 服务连接，如果是，则推送消息给用户。</p>
<p><strong>如何实现？</strong></p>
<p>不过 Kafka 并不直接提供<strong>内置的</strong>广播消费的功能！！！此时，我们只能退而求其次，每个 Consumer <strong>独有</strong>一个 Consumer Group ，从而保证都能接收到全量的消息</p>
<p>恰好，Spring Cloud Stream RabbitMQ 在设置 Consumer 的消费者分组为空时，会为该 Consumer 生成一个<strong>独有</strong>的<strong>随机</strong>的消费者分组，从而实现<strong>广播消费</strong>的功能。</p>
<p>下面，我们来实现一个 Consumer 广播消费的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fcd95d1edcda75f7acc74a164c7d0dfc1.png" alt="项目结构"></p>
<h2 id="7-1-搭建生产者"><a href="#7-1-搭建生产者" class="headerlink" title="7.1 搭建生产者"></a>7.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h2 id="7-2-搭建消费者"><a href="#7-2-搭建消费者" class="headerlink" title="7.2 搭建消费者"></a>7.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-broadcasting/"><code>labx-11-sc-stream-kafka-consumer-broadcasting</code></a> 项目作为消费者。</p>
<h3 id="7-2-1-配置文件"><a href="#7-2-1-配置文件" class="headerlink" title="7.2.1 配置文件"></a>7.2.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-error-handler/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，删除 Consumer 的消费者分组配置项 <code>group</code> 即可。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line"><span class="comment">#          group: demo01-consumer-group # 消费者分组</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<h2 id="7-3-简单测试"><a href="#7-3-简单测试" class="headerlink" title="7.3 简单测试"></a>7.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application 两次，启动两个<strong>消费者</strong>的实例。</p>
<p>我们打开 Kafka 运维界面，可以看到 Spring Cloud Stream Kafka 生成的以 <code>anonymous.</code> 开头的消费者分组。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F36633b9dc9558f98d50a2d1bc9c1a285.png" alt="运维界面"></p>
<p>同时我们在 IDEA 控制台的日志中，也可以看 Spring Cloud Stream Kafka 生成的以 <code>anonymous.</code> 开头的消费者分组。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerApplication 控制台 01</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">13</span>:<span class="number">54.091</span>  INFO <span class="number">68839</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">1092051199</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">13</span>:<span class="number">54.422</span>  INFO <span class="number">68839</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">618964293</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">13</span>:<span class="number">54.721</span>  INFO <span class="number">68839</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=<span class="number">94760781</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConsumerApplication 控制台 02</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">13</span>:<span class="number">54.092</span>  INFO <span class="number">68852</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=-<span class="number">1092051199</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">13</span>:<span class="number">54.422</span>  INFO <span class="number">68852</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=-<span class="number">618964293</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">13</span>:<span class="number">54.721</span>  INFO <span class="number">68852</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=<span class="number">94760781</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口三次，发送三条消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerApplication 控制台 01</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">35.883</span>  INFO <span class="number">46486</span> --- [Z-_87KO2Pl-WQ-<span class="number">1</span>] c.i.s.l.r.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=<span class="number">2084635466</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">37.278</span>  INFO <span class="number">46486</span> --- [Z-_87KO2Pl-WQ-<span class="number">1</span>] c.i.s.l.r.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">2118253111</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">37.652</span>  INFO <span class="number">46486</span> --- [Z-_87KO2Pl-WQ-<span class="number">1</span>] c.i.s.l.r.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=<span class="number">1956010289</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConsumerApplication 控制台 02</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">35.884</span>  INFO <span class="number">46527</span> --- [2e8iPDhSVKdcg-<span class="number">1</span>] c.i.s.l.r.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=<span class="number">2084635466</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">37.278</span>  INFO <span class="number">46527</span> --- [2e8iPDhSVKdcg-<span class="number">1</span>] c.i.s.l.r.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">2118253111</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">37.652</span>  INFO <span class="number">46527</span> --- [2e8iPDhSVKdcg-<span class="number">1</span>] c.i.s.l.r.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=<span class="number">1956010289</span>&#125;]</span><br></pre></td></tr></table></figure>



<p><strong>符合预期</strong>。从日志可以看出，每条消息仅被每个消费者消费了一次。</p>
<h1 id="8-并发消费"><a href="#8-并发消费" class="headerlink" title="8. 并发消费"></a>8. 并发消费</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-concurrency/"><code>labx-11-sc-stream-kafka-consumer-concurrency</code></a></li>
</ul>
</blockquote>
<p>在上述的示例中，我们配置的每一个 Binding 的 Consumer，都是<strong>串行</strong>消费的。显然，这在监听的 Topic 每秒消息量比较大的时候，会导致消费不及时，导致消息积压的问题。</p>
<p>虽然说，我们可以通过启动多个 JVM 进程，实现<strong>多进程的并发消费</strong>，从而加速消费的速度。但是问题是，否能够实现<strong>多线程</strong>的并发消费呢？答案是<strong>有</strong>。</p>
<p>通过在配置文件中的 <code>spring.cloud.stream.bindings.&lt;bindingName&gt;.consumer.concurrency</code> 配置项，可以指定该 Binder 并发消费的线程数。例如说，如果设置 <code>concurrency=10</code> 时，Spring Cloud Stream Kafka 就会为<strong>该</strong> Binder 创建 10 个线程，进行并发消费。</p>
<p>考虑到让胖友能够更好的理解 <code>concurrency</code> 属性，我们来简单说说 Spring-Kafka 在这块的实现方式。我们来举个例子：</p>
<ul>
<li>首先，我们来创建一个 Topic 为 <code>&quot;DEMO-TOPIC-01&quot;</code> ，并且设置其 Partition 分区数为 <strong>10</strong> 。</li>
<li>然后，我们创建一个用于 Consumer 的 Binding 配置，并设置 <code>concurrency</code> 配置项为 2。</li>
<li>再然后，我们启动项目。Spring-Kafka 会根据 Binding 的 <code>concurrency</code> 配置项为 2，为该 Binding 创建 <strong>2</strong> 个 Kafka Consumer 。注意噢，是 <strong>2</strong> 个 Kafka Consumer 呢！！！后续，每个 Kafka Consumer 会被<strong>单独</strong>分配到一个线程中，进行拉取消息，消费消息。</li>
<li>之后，Kafka Broker 会将 Topic 为 <code>&quot;DEMO-TOPIC-01&quot;</code> 分配给创建的 <strong>2</strong> 个 Kafka Consumer 各 <strong>5</strong> 个 Partition 。😈 如果不了解 Kafka Broker “分配区分”机制单独胖友，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/How-do-Kafka-consumers-allocate-partitions/?self">《Kafka 消费者如何分配分区》</a> 文章。</li>
<li>这样，因为用于 Consumer 的 Binding 的 <code>concurrency</code> 配置项为 2，创建 <strong>2</strong> 个 Kafka Consumer ，就在<strong>各自的线程中</strong>，拉取各自的 Topic 为 <code>&quot;DEMO-TOPIC-01&quot;</code> 的 Partition 的消息，各自<strong>串行</strong>消费。从而，实现<strong>多线程</strong>的并发消费。</li>
</ul>
<p>酱紫讲解一下，胖友对 Spring-Kafka 实现<strong>多线程</strong>的并发消费的机制，是否理解了。不过有一点要注意，不要配置 <code>concurrency</code> 属性过大，则创建的 Kafka Consumer 分配不到消费 Topic 的 Partition 分区，导致不断的空轮询。</p>
<blockquote>
<p>友情提示：可以选择不看。</p>
<p>在理解 Spring-Kafka 提供的<strong>并发消费</strong>机制，花费了好几个小时，主要陷入到了一个误区。</p>
<p>如果胖友有使用过 RocketMQ 的并发消费，会发现只要创建一个 RocketMQ Consumer 对象，然后 Consumer 拉取完消息之后，丢到 Consumer 的线程池中执行消费，从而实现并发消费。</p>
<p>而在 Spring-Kafka 提供的并发消费，会发现需要创建多个 Kafka Consumer 对象，并且每个 Consumer 都单独分配一个线程，然后 Consumer 拉取完消息之后，在各自的线程中执行消费。</p>
<p>又或者说，Spring-Kafka 提供的并发消费，很像 RocketMQ 的顺序消费。😈 从感受上来说，Spring-Kafka 的并发消费像 BIO ，RocketMQ 的并发消费像 NIO 。</p>
<p>不过，理论来说，在原生的 Kafka 客户端，也是能封装出和 RocketMQ Consumer 一样的并发消费的机制。</p>
<p>也因此，在使用 Kafka 的时候，每个 Topic 的 Partition 在消息量大的时候，要注意设置的相对大一些。</p>
</blockquote>
<p>下面，我们来实现一个 Consumer 并发消费的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F1384b78f74f9165363bf2eb371925dcc.png" alt="项目结构"></p>
<h2 id="8-1-搭建生产者"><a href="#8-1-搭建生产者" class="headerlink" title="8.1 搭建生产者"></a>8.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h2 id="8-2-搭建消费者"><a href="#8-2-搭建消费者" class="headerlink" title="8.2 搭建消费者"></a>8.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-concurrency/"><code>labx-11-sc-stream-kafka-consumer-concurrency</code></a> 项目作为消费者。</p>
<h3 id="8-2-1-配置文件"><a href="#8-2-1-配置文件" class="headerlink" title="8.2.1 配置文件"></a>8.2.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-concurrency/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，增加并发消费的配置项。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">demo01-consumer-group</span> <span class="comment"># 消费者分组</span></span><br><span class="line">          <span class="comment"># Consumer 配置项，对应 ConsumerProperties 类</span></span><br><span class="line">          <span class="attr">consumer:</span></span><br><span class="line">            <span class="attr">concurrency:</span> <span class="number">2</span> <span class="comment"># 每个 Consumer 消费线程数的初始大小，默认为 1</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<p><code>spring.cloud.stream.bindings.&lt;bindingName&gt;.consumer.concurrency</code> 配置项，指定该 Binder 的 Consumer 消费线程数的<strong>初始</strong>大小，默认为 1。</p>
<p>这里我们设置为 2，表示该 Consumer <strong>初始</strong>使用 2 个线程并发消费。</p>
<h2 id="8-3-简单测试"><a href="#8-3-简单测试" class="headerlink" title="8.3 简单测试"></a>8.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>此时我们在 IDEA 控制台的日志中，可以看到创建了两个 Kafka Consumer 和它们所分配到的 Partition，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring-Kafka 打印的日志，两个 Consumer 分别消费的 Partition</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.039</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">2</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">1</span> to the committed offset FetchPosition&#123;offset=<span class="number">7</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.039</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">3</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">9</span> to the committed offset FetchPosition&#123;offset=<span class="number">7</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">3</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">7</span> to the committed offset FetchPosition&#123;offset=<span class="number">6</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">2</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">2</span> to the committed offset FetchPosition&#123;offset=<span class="number">6</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">3</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">8</span> to the committed offset FetchPosition&#123;offset=<span class="number">5</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">2</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">0</span> to the committed offset FetchPosition&#123;offset=<span class="number">47</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">3</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">5</span> to the committed offset FetchPosition&#123;offset=<span class="number">5</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">2</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">3</span> to the committed offset FetchPosition&#123;offset=<span class="number">5</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">3</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">6</span> to the committed offset FetchPosition&#123;offset=<span class="number">5</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.040</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.a.k.c.c.internals.ConsumerCoordinator  : [Consumer clientId=consumer-<span class="number">2</span>, groupId=demo01-consumer-group] Setting offset <span class="keyword">for</span> partition DEMO-TOPIC-<span class="number">01</span>-<span class="number">4</span> to the committed offset FetchPosition&#123;offset=<span class="number">6</span>, offsetEpoch=Optional.empty, currentLeader=LeaderAndEpoch&#123;leader=localhost:<span class="number">9092</span> (id: <span class="number">0</span> rack: <span class="literal">null</span>), epoch=<span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring Cloud Stream Kafka 打印的日志，两个 Consumer 分别消费的 Partition</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.045</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] o.s.c.s.b.k.KafkaMessageChannelBinder$<span class="number">1</span>  : demo01-consumer-group: partitions assigned: [DEMO-TOPIC-<span class="number">01</span>-<span class="number">9</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">7</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">8</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">5</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">6</span>]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">34</span>:<span class="number">42.045</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] o.s.c.s.b.k.KafkaMessageChannelBinder$<span class="number">1</span>  : demo01-consumer-group: partitions assigned: [DEMO-TOPIC-<span class="number">01</span>-<span class="number">3</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">4</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">1</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">2</span>, DEMO-TOPIC-<span class="number">01</span>-<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口四次，发送四条消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程编号为 26</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">43</span>:<span class="number">07.450</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=<span class="number">1381530661</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">43</span>:<span class="number">08.239</span>  INFO <span class="number">69381</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=-<span class="number">1440386434</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程编号为 28</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">43</span>:<span class="number">08.626</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">279884815</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 08:<span class="number">43</span>:<span class="number">08.907</span>  INFO <span class="number">69381</span> --- [container-<span class="number">1</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">28</span> 消息内容：Demo01Message&#123;id=-<span class="number">1848103858</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>我们可以看到，两个线程在消费 <code>DEMO-TOPIC-01</code> Topic 下的消息。</p>
<h1 id="9-顺序消息"><a href="#9-顺序消息" class="headerlink" title="9. 顺序消息"></a>9. 顺序消息</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-partitioning"><code>labx-11-sc-stream-kafka-producer-partitioning</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-concurrency/"><code>labx-11-sc-stream-kafka-consumer-concurrency</code></a></li>
</ul>
</blockquote>
<p>我们先来一起了解下顺序消息的<strong>顺序消息</strong>的定义：</p>
<ul>
<li>普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。</li>
<li>完全严格顺序 ：在【普通顺序消息】的基础上，Consumer 严格顺序消费。</li>
</ul>
<blockquote>
<p>消息有序，指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ 可以严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个 Topic 下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>全局顺序：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
<li>分区顺序：对于指定的一个 Topic，所有消息根据 Sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。适用场景：性能要求高，以 Sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li>
</ul>
</blockquote>
<p>注意，<strong>分区</strong>顺序就是<strong>普通</strong>顺序消息，<strong>全局</strong>顺序就是<strong>完全</strong>严格顺序。</p>
<p><strong>📚 如何实现？ 📚</strong></p>
<p>在上述的示例中，我们看到 Spring-Kafka 在 Consumer 消费消息时，<strong>天然</strong>就支持按照 Topic 下的 Partition 下的消息，<strong>顺序消费</strong>。即使在<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「8. 并发消费」</a>时，也能保证如此。</p>
<p>那么此时，我们只需要考虑将 Producer 将相关联的消息发送到 Topic 下的相同的 Partition 即可。在 Spring Cloud Stream 中，支持从消息中获取 Sharding key，从而发送消息到 Topic 下对应的 Partition 中。</p>
<p>下面，我们来实现一个 Spring Cloud Stream RabbitMQ 下的<strong>顺序消息</strong>的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F3982bd28f85a41a70bde4c96edcad9c3.png" alt="项目结构"></p>
<h2 id="9-1-搭建生产者"><a href="#9-1-搭建生产者" class="headerlink" title="9.1 搭建生产者"></a>9.1 搭建生产者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-partitioning"><code>labx-11-sc-stream-kafka-producer-partitioning</code></a> 项目作为生产者。</p>
<h3 id="9-1-1-配置文件"><a href="#9-1-1-配置文件" class="headerlink" title="9.1.1 配置文件"></a>9.1.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-partitioning/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，添加 <code>partition-key-expression</code> 配置项，设置 Producer 发送顺序消息的 Sharding key。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-producer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="comment"># Producer 配置项，对应 ProducerProperties 类</span></span><br><span class="line">          <span class="attr">producer:</span></span><br><span class="line">            <span class="attr">partition-key-expression:</span> <span class="string">payload[&#x27;id&#x27;]</span> <span class="comment"># 分区 key 表达式。该表达式基于 Spring EL，从消息中获得分区 key。</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">        <span class="comment"># Kafka 自定义 Binding 配置项，对应 KafkaBindingProperties Map</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-output:</span></span><br><span class="line">            <span class="comment"># Kafka Producer 配置项，对应 KafkaProducerProperties 类</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">sync:</span> <span class="literal">true</span> <span class="comment"># 是否同步发送消息，默认为 false 异步。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18080</span></span><br></pre></td></tr></table></figure>



<p>① <code>spring.cloud.stream.bindings.&lt;bindingName&gt;.producer.partition-key-expression</code> 配置项，该表达式基于 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html">Spring EL</a>，从消息中获得 Sharding key。</p>
<blockquote>
<p>友情提示：Sharding Key 和 Partition Key 是等价的，有些文章喜欢叫分片键，有些文章喜欢叫分区键。</p>
<p>艿艿自己的习惯，是叫 Sharding Key，奈何 Spring Cloud Stream 是 Partition Key，所以下文胖友看到两个词存在混用的情况，知道是一个意思哈~</p>
</blockquote>
<p>这里，我们设置该配置项为 <code>payload[&#39;id&#39;]</code>，表示从 Spring <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/Message.java">Message</a> 的 payload 的 <code>id</code>。稍后我们发送的消息的 payload 为 Demo01Message，那么 <code>id</code> 就是 <code>Demo01Message.id</code>。</p>
<p>如果我们想从消息的 headers 中获得 Sharding key，可以设置为 <code>headers[&#39;partitionKey&#39;]</code>。</p>
<p>② Spring Cloud Stream 使用 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binder/PartitionHandler.java">PartitionHandler</a> 进行 Sharding key 的获得与计算，最终 Sharding key 的结果为 <code>key.hashCode() % partitionCount</code>。</p>
<blockquote>
<p>感兴趣的胖友，可以阅读 PartitionHandler 的 <code>#determinePartition(Message&lt;?&gt; message)</code> 方法。</p>
</blockquote>
<p>我们以发送一条 <code>id</code> 为 1 的 Demo01Message 消息为示例，最终会发送到对应 Kafka Topic 的 Partition 为 1。计算过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，PartitionHandler 使用 `partition-key-expression` 表达式，从 Message 中获得 Sharding key</span></span><br><span class="line">key =&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，PartitionHandler 计算最终的 Sharding key</span></span><br><span class="line"><span class="comment">// 这里 Partition 数量为 10 的原因是，在「3. 快速入门」小节，我设置 `DEMO-TOPIC-01` Topic 的 Partition 大小为 10.</span></span><br><span class="line">key =&gt; key.hashCode() % partitionCount = <span class="number">1.</span>hashCode() % <span class="number">10</span> = <span class="number">1</span> % <span class="number">10</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步，Kafka 发送到 `DEMO-TOPIC-01` Topic 的顺序为 key Partition 中</span></span><br><span class="line"><span class="comment">// 这里，因为 key 为 1，所以 Partition 顺序为 1。</span></span><br></pre></td></tr></table></figure>



<p>这样，我们就能保证<strong>相同 Sharding Key</strong> 的消息，发送到<strong>相同的对应 Kafka Topic 的 Partition</strong> 中。当前，前提是该 Topic 的 Partition 总数不能变噢，不然计算的 Sharding Key 会发生变化。</p>
<h3 id="9-1-2-Demo01Controller"><a href="#9-1-2-Demo01Controller" class="headerlink" title="9.1.2 Demo01Controller"></a>9.1.2 Demo01Controller</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-partitioning/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/controller/Demo01Controller.java">Demo01Controller</a> 类，增加发送 3 条<strong>顺序</strong>消息的 HTTP 接口。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/send_orderly&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendOrderly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 发送 3 条相同 id 的消息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建 Message</span></span><br><span class="line">        <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>().setId(id);</span><br><span class="line">        <span class="comment">// 创建 Spring Message 对象</span></span><br><span class="line">        Message&lt;Demo01Message&gt; springMessage = MessageBuilder.withPayload(message)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        mySource.demo01Output().send(springMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每次发送的 3 条消息使用相同的 <code>id</code>，配合上我们使用它作为 Sharding key，就可以发送对应 Topic 的<strong>相同 Partition</strong> 中。</p>
<p>另外，整列发送的虽然是<strong>顺序</strong>消息，但是和发送<strong>普通</strong>消息的代码是<strong>一模一样</strong>的。</p>
<h2 id="9-2-搭建消费者"><a href="#9-2-搭建消费者" class="headerlink" title="9.2 搭建消费者"></a>9.2 搭建消费者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「8. 并发消费」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-concurrency/"><code>labx-11-sc-stream-kafka-consumer-concurrency</code></a> 项目即可。</p>
<h2 id="9-3-简单测试"><a href="#9-3-简单测试" class="headerlink" title="9.3 简单测试"></a>9.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send_orderly">http://127.0.0.1:18080/demo01/send_orderly</a> 接口，发送顺序消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">10</span>:<span class="number">37</span>:<span class="number">05.351</span>  INFO <span class="number">71912</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=<span class="number">1414772641</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">10</span>:<span class="number">37</span>:<span class="number">05.354</span>  INFO <span class="number">71912</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=<span class="number">1414772641</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-08 <span class="number">10</span>:<span class="number">37</span>:<span class="number">05.358</span>  INFO <span class="number">71912</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">26</span> 消息内容：Demo01Message&#123;id=<span class="number">1414772641</span>&#125;]</span><br></pre></td></tr></table></figure>



<p><code>id</code> 为 1414772641 的消息被发送到 Kafka Topic 的 Partition 为 1，并且在线程编号为 26 的线程中消费。😈 胖友可以自己在多调用几次接口，继续尝试。</p>
<h1 id="10-消息过滤"><a href="#10-消息过滤" class="headerlink" title="10. 消息过滤"></a>10. 消息过滤</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-filter"><code>labx-11-sc-stream-kafka-consumer-filter</code></a></li>
</ul>
</blockquote>
<p>Spring Cloud Stream 提供了<strong>通用</strong>的 <strong>Consumer</strong> 级别的效率过滤器机制。我们只需要使用 <code>@StreamListener</code> 注解的 <code>condition</code> 属性，设置消息满足指定 Spring EL 表达式的情况下，才进行消费。</p>
<p>下面，我们来实现一个 Spring Cloud Stream Kafka 下的<strong>消息过滤</strong>的示例。最终项目如下图所示：<a target="_blank" rel="noopener" href="https://static.iocoder.cn/images/Spring-Cloud/2020-11-01/61.png">项目结构</a></p>
<h2 id="10-1-搭建生产者"><a href="#10-1-搭建生产者" class="headerlink" title="10.1 搭建生产者"></a>10.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h3 id="10-1-1-Demo01Controller"><a href="#10-1-1-Demo01Controller" class="headerlink" title="10.1.1 Demo01Controller"></a>10.1.1 Demo01Controller</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/controller/Demo01Controller.java">Demo01Controller</a> 类，增加发送 3 条<strong>带 <code>tag</code> 消息头的</strong>消息的 HTTP 接口。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/send_tag&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendTag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String tag : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;yunai&quot;</span>, <span class="string">&quot;yutou&quot;</span>, <span class="string">&quot;tudou&quot;</span>&#125;) &#123;</span><br><span class="line">        <span class="comment">// 创建 Message</span></span><br><span class="line">        <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>()</span><br><span class="line">                .setId(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt());</span><br><span class="line">        <span class="comment">// 创建 Spring Message 对象</span></span><br><span class="line">        Message&lt;Demo01Message&gt; springMessage = MessageBuilder.withPayload(message)</span><br><span class="line">                .setHeader(<span class="string">&quot;tag&quot;</span>, tag) <span class="comment">// &lt;X&gt; 设置 Tag</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        mySource.demo01Output().send(springMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>&lt;X&gt;</code> 处，设置发送消息的 <code>tag</code> 消息头。</p>
<h2 id="10-2-搭建消费者"><a href="#10-2-搭建消费者" class="headerlink" title="10.2 搭建消费者"></a>10.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-filter"><code>labx-11-sc-stream-kafka-consumer-filter</code></a> 项目作为消费者。</p>
<h3 id="10-2-1-Demo01Consumer"><a href="#10-2-1-Demo01Consumer" class="headerlink" title="10.2.1 Demo01Consumer"></a>10.2.1 Demo01Consumer</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-filter/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/Demo01Consumer.java">Demo01Consumer</a> 类，使用 <code>@StreamListener</code> 注解的 <code>condition</code> 属性来过滤消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(value = MySink.DEMO01_INPUT, condition = &quot;headers[&#x27;tag&#x27;] == &#x27;yunai&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> Demo01Message message)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们设置消息的 Header 带有的 <code>tag</code> 值为 <code>yunai</code> 时，才进行消费。</p>
<h2 id="10-3-简单测试"><a href="#10-3-简单测试" class="headerlink" title="10.3 简单测试"></a>10.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send_tag">http://127.0.0.1:18080/demo01/send_tag</a> 接口，发送带有 Tag 的消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息头 tag 为 `yunai` 的消息被消费</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">19</span>:<span class="number">25</span>:<span class="number">28.495</span>  INFO <span class="number">80717</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">25</span> 消息内容：Demo01Message&#123;id=-<span class="number">8065193</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息头 tag 为 `yutou` 和 `tudou` 的消息被过滤</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">19</span>:<span class="number">25</span>:<span class="number">28.500</span>  WARN <span class="number">80717</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] .DispatchingStreamListenerMessageHandler : Cannot find a <span class="meta">@StreamListener</span> matching <span class="keyword">for</span> message with id: <span class="literal">null</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">19</span>:<span class="number">25</span>:<span class="number">28.502</span>  WARN <span class="number">80717</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] .DispatchingStreamListenerMessageHandler : Cannot find a <span class="meta">@StreamListener</span> matching <span class="keyword">for</span> message with id: <span class="literal">null</span></span><br></pre></td></tr></table></figure>



<p>只消费了一条消息头为 <code>yunai</code> 的消息，而消息头为 <code>yutou</code> 和 <code>tudou</code> 的消息被 Consumer 过滤。要<strong>注意</strong>，被过滤掉的消息，后续是无法被消费掉了，效果和消费成功是一样的。</p>
<h1 id="11-事务消息-1"><a href="#11-事务消息-1" class="headerlink" title="11. 事务消息"></a>11. 事务消息</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-transaction"><code>labx-11-sc-stream-kafka-producer-transaction</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-transaction/"><code>labx-11-sc-stream-kafka-consumer-transaction</code></a></li>
</ul>
</blockquote>
<p>Kafka 内置提供事务消息的支持。对事务消息的概念不了解的胖友，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/longyb-transaction_mq/?self">《事务消息组件的套路》</a> 文章。</p>
<p>不过 Kafka 提供的并不是<strong>完整的</strong>的事务消息的支持，缺少了<strong>回查机制</strong>。关于这一点，刚推荐的文章也有讲到。目前，常用的分布式消息队列，只有 RocketMQ 提供了完整的事务消息的支持，具体的可以看看<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self">《芋道 Spring Boot 消息队列 RocketMQ 入门》</a> 的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「9. 事务消息」</a>小节，😈 暂时不拓展开来讲。</p>
<p>下面，我们来实现一个 Spring Cloud Stream Kafka 下的<strong>事务消息</strong>的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F43ca8d0d650ee5a6618c11c8809614da.png" alt="项目结构"></p>
<h2 id="11-1-搭建生产者"><a href="#11-1-搭建生产者" class="headerlink" title="11.1 搭建生产者"></a>11.1 搭建生产者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-transaction"><code>labx-11-sc-stream-kafka-producer-transaction</code></a> 项目作为生产者。</p>
<h3 id="11-1-1-配置文件"><a href="#11-1-1-配置文件" class="headerlink" title="11.1.1 配置文件"></a>11.1.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-transaction/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，添加事务相关配置项，开启发送事务消息的功能。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-producer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">          <span class="attr">transaction:</span></span><br><span class="line">            <span class="attr">transaction-id-prefix:</span> <span class="string">demo.</span> <span class="comment"># 事务编号前缀</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">configuration:</span></span><br><span class="line">                <span class="attr">retries:</span> <span class="number">1</span> <span class="comment"># 发送失败时，重试发送的次数</span></span><br><span class="line">                <span class="attr">acks:</span> <span class="string">all</span> <span class="comment"># 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span></span><br><span class="line">        <span class="comment"># Kafka 自定义 Binding 配置项，对应 KafkaBindingProperties Map</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-output:</span></span><br><span class="line">            <span class="comment"># Kafka Producer 配置项，对应 KafkaProducerProperties 类</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">sync:</span> <span class="literal">true</span> <span class="comment"># 是否同步发送消息，默认为 false 异步。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18080</span></span><br></pre></td></tr></table></figure>



<p><code>spring.cloud.stream.kafka.binder.transaction</code> 为 Spring Cloud Stream Kafka <strong>事务</strong>配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka-core/src/main/java/org/springframework/cloud/stream/binder/kafka/properties/KafkaBinderConfigurationProperties.java#L366-L387"><code>KafkaBinderConfigurationProperties.Transaction</code></a> 类。</p>
<ul>
<li><p><code>transaction-id-prefix</code> 配置项，事务编号的前缀。需要保证相同应用配置相同，不同应用配置不同。具体可以看看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57179169/how-to-choose-kafka-transaction-id-for-several-applications-hosted-in-kubernete">《How to choose Kafka transaction id for several applications》</a>的讨论。</p>
</li>
<li><pre><code>producer
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  配置项，Producer 在事务中的</span><br><span class="line"></span><br><span class="line">  附加</span><br><span class="line"></span><br><span class="line">  配置项。</span><br><span class="line"></span><br><span class="line">  - `retries` 配置项，发送失败时，重试发送的次数。</span><br><span class="line">  - `acks` 配置项，必须设置为 `all`，不然在启动时会报 `&quot;Must set acks to all in order to use the idempotent producer. Otherwise we cannot guarantee idempotence.&quot;` 错误。因为，Kafka 的事务消息需要基于幂等性来实现，所以必须保证所有节点都写入成功。</span><br><span class="line"></span><br><span class="line">### 11.1.2 TransactionConfig</span><br><span class="line"></span><br><span class="line">创建 [TransactionConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-transaction/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/config/TransactionConfig.java) 类，创建 [KafkaTransactionManager](https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/transaction/KafkaTransactionManager.java) Bean，Kafka 的事务管理器，集成到 Spring 的事务体系中，这样就可以使用 `@Transactional` 声明式事务。代码如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Configuration</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class TransactionConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager transactionManager(BinderFactory binders) &#123;</span><br><span class="line">        // 获得 Kafka ProducerFactory 对象</span><br><span class="line">        ProducerFactory&lt;byte[], byte[]&gt; pf = ((KafkaMessageChannelBinder) binders.getBinder(null,</span><br><span class="line">                MessageChannel.class)).getTransactionalProducerFactory();</span><br><span class="line">        // 创建 KafkaTransactionManager 事务管理器</span><br><span class="line">        assert pf != null;</span><br><span class="line">        return new KafkaTransactionManager&lt;&gt;(pf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="11-1-3-Demo01Controller"><a href="#11-1-3-Demo01Controller" class="headerlink" title="11.1.3 Demo01Controller"></a>11.1.3 Demo01Controller</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-transaction/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/controller/Demo01Controller.java">Demo01Controller</a> 类，增加发送<strong>事务</strong>消息的 HTTP 接口。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Controller .java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/send_transaction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTransaction</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建 Message</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>()</span><br><span class="line">            .setId(id);</span><br><span class="line">    <span class="comment">// 创建 Spring Message 对象</span></span><br><span class="line">    Message&lt;Demo01Message&gt; springMessage = MessageBuilder.withPayload(message)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    mySource.demo01Output().send(springMessage);</span><br><span class="line">    logger.info(<span class="string">&quot;[sendTransaction][发送编号：[&#123;&#125;] 发送成功]&quot;</span>, id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &lt;X&gt; 等待</span></span><br><span class="line">    Thread.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在发送消息方法上，我们添加了 <code>@Transactional</code> 注解，声明事务。因为我们创建了 KafkaTransactionManager 事务管理器，所以这里会创建 Kafka 事务。</p>
<p>在 <code>&lt;X&gt;</code> 处，我们故意等待 <code>Thread#sleep(long millis)</code> 10 秒，判断 Kafka 事务是否生效。</p>
<ul>
<li>如果同步发送消息成功后，Consumer 立即消费到该消息，说明未生效。</li>
<li>如果 Consumer 是 10 秒之后，才消费到该消息，说明已生效。</li>
</ul>
<h2 id="11-2-搭建消费者"><a href="#11-2-搭建消费者" class="headerlink" title="11.2 搭建消费者"></a>11.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-transaction/"><code>labx-11-sc-stream-kafka-consumer-transaction</code></a> 项目作为消费者。</p>
<h3 id="11-2-1-配置文件"><a href="#11-2-1-配置文件" class="headerlink" title="11.2.1 配置文件"></a>11.2.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-transaction/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，添加事务相关配置项，仅消费<strong>已提交</strong>的消息。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">demo01-consumer-group</span> <span class="comment"># 消费者分组</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">        <span class="comment"># Kafka Binding 配置项，对应 KafkaBindingProperties 类</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-input:</span></span><br><span class="line">            <span class="comment"># Kafka Consumer 配置项，对应 KafkaConsumerProperties 类</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">configuration:</span></span><br><span class="line">                <span class="attr">isolation:</span></span><br><span class="line">                  <span class="attr">level:</span> <span class="string">read_committed</span> <span class="comment"># 读取已提交的消息</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<p>添加 <code>spring.cloud.stream.kafka.bindings.&lt;bindingName&gt;.consumer.configuration.isolation.level</code> 为 <code>read_committed</code>，设置 Consumer <strong>仅</strong>读取已提交的消息。😈 一定要配置！！！被坑惨了，当时以为自己的事务消息怎么就是不生效，原来少加了这个。</p>
<h2 id="11-3-简单测试"><a href="#11-3-简单测试" class="headerlink" title="11.3 简单测试"></a>11.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send_transaction">http://127.0.0.1:18080/demo01/send_transaction</a> 接口，发送事务消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer 成功同步发送了 1 条消息。此时，事务并未提交</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">22</span>:<span class="number">31</span>:<span class="number">34.863</span>  INFO <span class="number">84414</span> --- [io-<span class="number">18080</span>-exec-<span class="number">1</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send_transaction][发送编号：[<span class="number">629326486</span>] 发送成功]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 秒后，Producer 提交事务。</span></span><br><span class="line"><span class="comment">// 此时，Consumer 消费到该消息。</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">22</span>:<span class="number">31</span>:<span class="number">44.952</span>  INFO <span class="number">84408</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=<span class="number">629326486</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>Consumer 在事务消息提交后，消费到该消息。符合预期~</p>
<h1 id="12-消费进度的提交机制-1"><a href="#12-消费进度的提交机制-1" class="headerlink" title="12. 消费进度的提交机制"></a>12. 消费进度的提交机制</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-ack/"><code>labx-11-sc-stream-kafka-consumer-ack</code></a></li>
</ul>
</blockquote>
<p><strong>📚 原生 Kafka 的提交机制</strong></p>
<p>原生 Kafka Consumer 消费端，有两种消费进度提交的提交机制：</p>
<ul>
<li>【默认】自动提交，通过配置 <code>enable.auto.commit=true</code> ，每过 <code>auto.commit.interval.ms</code> 时间间隔，都会自动提交消费消费进度。而提交的时机，是在 Consumer 的 <code>#poll(...)</code> 方法的逻辑里完成，在每次从 Kafka Broker 拉取消息时，会检查是否到达自动提交的时间间隔，如果是，那么就会提交上一次轮询拉取的位置。</li>
<li>手动提交，通过配置 <code>enable.auto.commit=false</code> ，后续通过 Consumer 的 <code>#commitSync(...)</code> 或 <code>#commitAsync(...)</code> 方法，同步或异步提交消费进度。</li>
</ul>
<p><strong>📚 Spring-Kafka 的提交机制</strong></p>
<p>Spring-Kafka Consumer 消费端，提供了更丰富的消费者进度的提交机制，更加灵活。当然，也是分成自动提交和手动提交两个大类。在 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/listener/ContainerProperties.java#L44-L93">AckMode</a> 枚举类中，可以看到每一种具体的方式。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContainerProperties#AckMode.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AckMode</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 自动提交 ==========</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit after each record is processed by the listener.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	RECORD, <span class="comment">// 每条消息被消费完成后，自动提交</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit whatever has already been processed before the next poll.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BATCH, <span class="comment">// 每一次消息被消费完成后，在下次拉取消息之前，自动提交</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit pending updates after</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ContainerProperties#setAckTime(long) ackTime&#125; has elapsed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TIME, <span class="comment">// 达到一定时间间隔后，自动提交。</span></span><br><span class="line">	      <span class="comment">// 不过要注意，它并不是一到就立马提交，如果此时正在消费某一条消息，需要等这条消息被消费完成，才能提交消费进度。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit pending updates after</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ContainerProperties#setAckCount(int) ackCount&#125; has been</span></span><br><span class="line"><span class="comment">	 * exceeded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	COUNT, <span class="comment">// 消费成功的消息数到达一定数量后，自动提交。</span></span><br><span class="line">	      <span class="comment">// 不过要注意，它并不是一到就立马提交，如果此时正在消费某一条消息，需要等这条消息被消费完成，才能提交消费进度。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Commit pending updates after</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ContainerProperties#setAckCount(int) ackCount&#125; has been</span></span><br><span class="line"><span class="comment">	 * exceeded or after &#123;<span class="doctag">@link</span> ContainerProperties#setAckTime(long)</span></span><br><span class="line"><span class="comment">	 * ackTime&#125; has elapsed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	COUNT_TIME, <span class="comment">// TIME 和 COUNT 的结合体，满足任一都会自动提交。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 手动提交 ==========</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User takes responsibility for acks using an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AcknowledgingMessageListener&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANUAL, <span class="comment">// 调用时，先标记提交消费进度。等到当前消息被消费完成，然后在提交消费进度。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * User takes responsibility for acks using an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AcknowledgingMessageListener&#125;. The consumer</span></span><br><span class="line"><span class="comment">	 * immediately processes the commit.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANUAL_IMMEDIATE, <span class="comment">// 调用时，立即提交消费进度。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>看下每种方式，艿艿都添加了注释哟。</li>
</ul>
<p>那么，既然现在存在原生 Kafka 和 Spring-Kafka 提供的两种消费进度的提交机制，我们应该怎么配置呢？</p>
<ul>
<li>使用原生 Kafka 的方式，通过配置 <code>spring.kafka.consumer.enable-auto-commit=true</code> 。然后，通过 <code>spring.kafka.consumer.auto-commit-interval</code> 设置自动提交的频率。</li>
<li>使用 Spring-Kafka 的方式，通过配置 <code>spring.kafka.consumer.enable-auto-commit=false</code> 。然后通过 <code>spring.kafka.listener.ack-mode</code> 设置具体模式。另外，还有 <code>spring.kafka.listener.ack-time</code> 和 <code>spring.kafka.listener.ack-count</code> 可以设置自动提交的时间间隔和消息条数。</li>
</ul>
<p><strong>默认什么都不配置的情况下，使用 Spring-Kafka 的 BATCH 模式：每一次消息被消费完成后，在下次拉取消息之前，自动提交</strong>。</p>
<p><strong>📚 Spring Cloud Stream Kafka 的提交机制</strong></p>
<p>Spring Cloud Stream Kafka 在 Spring-Kafka 上进一步封装，在 <code>spring.cloud.stream.kafka.bindings.&lt;bindingName&gt;.consumer</code> 下提供了两个配置项：</p>
<ul>
<li><code>auto-commit-offset</code> 配置项，是否自动提交消费进度，默认为 <code>true</code> 自动提交。</li>
<li><code>ack-each-record</code> 配置项，是否每一条消息都进行提交消费进度，默认为 <code>false</code> 在每一批消费完成后一起提交。</li>
</ul>
<p>我们进行下整理，将 Spring Cloud Stream Kafka 这两个配置项，和 Spring-Kafka 的 AckMode 对应上，如下表格：</p>
<table>
<thead>
<tr>
<th align="left">AckMode</th>
<th align="left"><code>auto-commit-offset</code></th>
<th align="left"><code>ack-each-record</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">自动 <code>RECORD</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr>
<td align="left">自动 <code>BATCH</code></td>
<td align="left"><code>true</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">手动 <code>MANUAL</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr>
<td align="left">手动 <code>MANUAL_IMMEDIATE</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<p>因此，<strong>默认什么都不配置的情况下，也使用 Spring-Kafka 的 BATCH 模式：每一次消息被消费完成后，在下次拉取消息之前，自动提交</strong>。</p>
<p>下面，我们来实现一个 Spring Cloud Stream Kafka 下的<strong>手动提交消费进度</strong>的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F8f6ea4bf1de1625c00f3e487182eab5c.png" alt="项目结构"></p>
<h2 id="12-1-搭建生产者"><a href="#12-1-搭建生产者" class="headerlink" title="12.1 搭建生产者"></a>12.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h2 id="12-2-搭建消费者"><a href="#12-2-搭建消费者" class="headerlink" title="12.2 搭建消费者"></a>12.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-ack/"><code>labx-11-sc-stream-kafka-consumer-ack</code></a> 项目作为消费者。</p>
<h3 id="12-2-1-配置文件"><a href="#12-2-1-配置文件" class="headerlink" title="12.2.1 配置文件"></a>12.2.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-ack/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，设置 <code>auto-commit-offset</code> 配置项为 <code>false</code>，<code>ack-each-record</code> 配置项为 <code>true</code>，即使用 Spring-Kafka 的 <code>MANUAL</code> 模式，手动提交消费进度。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">demo01-consumer-group</span> <span class="comment"># 消费者分组</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">        <span class="comment"># Kafka Binding 配置项，对应 KafkaBindingProperties 类</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-input:</span></span><br><span class="line">            <span class="comment"># Kafka Consumer 配置项，对应 KafkaConsumerProperties 类</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">auto-commit-offset:</span> <span class="literal">false</span> <span class="comment"># 是否自动提交消费进度，默认为 true 自动提交。</span></span><br><span class="line">              <span class="attr">ack-each-record:</span> <span class="literal">true</span> <span class="comment"># 是否每一条消息都进行提交消费进度，默认为 false 在每一批消费完成后一起提交。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<h3 id="12-2-2-Demo01Consumer"><a href="#12-2-2-Demo01Consumer" class="headerlink" title="12.2.2 Demo01Consumer"></a>12.2.2 Demo01Consumer</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-ack/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/Demo01Consumer.java">Demo01Consumer</a> 类，增加手动提交消费进度的代码。代码如下：代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo08Consumer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = Demo08Message.TOPIC,</span></span><br><span class="line"><span class="meta">            groupId = &quot;demo08-consumer-group-&quot; + Demo08Message.TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Demo08Message message, Acknowledgment acknowledgment)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), message);</span><br><span class="line">        <span class="comment">// 提交消费进度</span></span><br><span class="line">        <span class="keyword">if</span> (message.getId() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            acknowledgment.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>① 在消费方法上，我们增加了第二个方法参数，类型为 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/support/Acknowledgment.java">Acknowledgment</a> 类。通过调用其 <code>#acknowledge()</code> 方法，可以提交当前消息的 Topic 的 Partition 的消费进度。</p>
<p>② 在消费逻辑中，我们故意只提交消费的第一条消息。😈 这样，我们只需要发送两条消息，如果第二条的消费进度没有被提交，就可以说明手动提交消费进度成功。</p>
<h2 id="12-3-简单测试"><a href="#12-3-简单测试" class="headerlink" title="12.3 简单测试"></a>12.3 简单测试</h2><blockquote>
<p>友情提示：这里为了测试方便，避免其它示例污染，因此艿艿先直接删除了 <code>DEMO-TOPIC-01</code> Topic，然后重新创建。</p>
</blockquote>
<p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口，发送两条消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Consumer 消费 2 条消息成功</span><br><span class="line">2020-03-10 08:28:52.274  INFO 86430 --- [container-0-C-1] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:27 消息内容：Demo01Message&#123;id=-1390450417&#125;]</span><br><span class="line">2020-03-10 08:28:53.101  INFO 86430 --- [container-0-C-1] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:27 消息内容：Demo01Message&#123;id=34018866&#125;]</span><br></pre></td></tr></table></figure>



<p>我们打开 Kafka 运维界面，查看下 <code>DEMO-TOPIC-01</code> Topic 的消息进度情况，会看到<strong>一条消息的消费进度未被提交</strong>，符合预期。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F635404bf56e9e987ca6be51686ee2c5d.png" alt=" Topic"></p>
<h1 id="13-批量发送消息"><a href="#13-批量发送消息" class="headerlink" title="13. 批量发送消息"></a>13. 批量发送消息</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-batch"><code>labx-11-sc-stream-kafka-producer-batch</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a></li>
</ul>
</blockquote>
<p>在一些业务场景下，我们希望使用 Producer 批量发送消息，提高发送性能。不同于我们在<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self">《芋道 Spring Boot 消息队列 RocketMQ 入门》</a> 的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「4. 批量发送消息」</a> 功能，RocketMQ 是提供了一个可以批量发送多条消息的 API 。</p>
<p>而 Kafka 提供的批量发送消息，它提供了一个 <a target="_blank" rel="noopener" href="http://people.apache.org/~nehanarkhede/kafka-0.9-producer-javadoc/doc/org/apache/kafka/clients/producer/internals/RecordAccumulator.html">RecordAccumulator</a> 消息收集器，将发送给相同 Topic 的相同 Partition 分区的消息们，“<strong>偷偷</strong>”收集在一起，当满足条件时候，一次性批量发送提交给 Kafka Broker 。通过在 <code>spring.cloud.stream.kafka.bindings.&lt;bindingName&gt;.producer</code> 下提供了两个配置项，满足<strong>任一</strong>即会批量发送：</p>
<ul>
<li>【时间】<code>batch-timeout</code> ：超过收集的时间的最大等待时长，单位：毫秒。</li>
<li>【空间】<code>buffer-memory</code> ：超过收集的消息占用的最大内存。</li>
</ul>
<p>下面，我们来实现一个 Spring Cloud Stream Kafka 下的<strong>批量发送消息</strong>的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F51338ce21d434fa7142aca9f7fed538f.png" alt="项目结构"></p>
<h2 id="13-1-搭建生产者"><a href="#13-1-搭建生产者" class="headerlink" title="13.1 搭建生产者"></a>13.1 搭建生产者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-batch"><code>labx-11-sc-stream-kafka-producer-batch</code></a> 项目作为生产者。</p>
<h3 id="13-1-1-配置文件"><a href="#13-1-1-配置文件" class="headerlink" title="13.1.1 配置文件"></a>13.1.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-batch/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，增加批量<strong>发送</strong>消息相关的配置项。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-producer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">        <span class="comment"># Kafka 自定义 Binding 配置项，对应 KafkaBindingProperties Map</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo01-output:</span></span><br><span class="line">            <span class="comment"># Kafka Producer 配置项，对应 KafkaProducerProperties 类</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">batch-timeout:</span> <span class="number">30000</span> <span class="comment"># 批处理延迟时间上限。这里配置为 30 * 1000 ms 过后，不管是否消息数量是否到达 batch-size 或者消息大小到达 buffer-memory 后，都直接发送一次请求</span></span><br><span class="line">              <span class="attr">buffer-size:</span> <span class="number">33554432</span> <span class="comment"># 每次批量发送消息的最大内存</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18080</span></span><br></pre></td></tr></table></figure>



<p>具体 <code>batch-timeout</code> 和 <code>buffer-size</code> 配置项的数值配置多少，根据自己的应用来。这里，我们故意将 <code>batch-timeout</code> 配置成了 30 秒，主要为了演示之用。</p>
<h3 id="13-1-2-Demo01Controller"><a href="#13-1-2-Demo01Controller" class="headerlink" title="13.1.2 Demo01Controller"></a>13.1.2 Demo01Controller</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-batch/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/kafkademo/controller/Demo01Controller.java">Demo01Controller</a> 类，增加发送三条消息的 HTTP 接口，方便测试。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Controller.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/send_batch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建 Message</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">        <span class="type">Demo01Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo01Message</span>()</span><br><span class="line">                .setId(id);</span><br><span class="line">        <span class="comment">// 创建 Spring Message 对象</span></span><br><span class="line">        Message&lt;Demo01Message&gt; springMessage = MessageBuilder.withPayload(message)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        mySource.demo01Output().send(springMessage);</span><br><span class="line">        logger.info(<span class="string">&quot;[send_transaction][发送编号：[&#123;&#125;] 发送成功]&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就是普通的发送消息的代码，多套了一层循环~</p>
<h2 id="13-2-搭建消费者"><a href="#13-2-搭建消费者" class="headerlink" title="13.2 搭建消费者"></a>13.2 搭建消费者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目即可。</p>
<h2 id="13-3-简单测试"><a href="#13-3-简单测试" class="headerlink" title="13.3 简单测试"></a>13.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send_batch">http://127.0.0.1:18080/demo01/send_batch</a> 接口，发送三条消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer 发送了 3 条消息，被 RecordAccumulator 收集</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">58</span>:<span class="number">52.736</span>  INFO <span class="number">87258</span> --- [io-<span class="number">18080</span>-exec-<span class="number">1</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send_batch][发送编号：[-<span class="number">936892120</span>] 发送成功]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">58</span>:<span class="number">52.736</span>  INFO <span class="number">87258</span> --- [io-<span class="number">18080</span>-exec-<span class="number">1</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send_batch][发送编号：[<span class="number">128684651</span>] 发送成功]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">58</span>:<span class="number">52.737</span>  INFO <span class="number">87258</span> --- [io-<span class="number">18080</span>-exec-<span class="number">1</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send_batch][发送编号：[-<span class="number">1940691507</span>] 发送成功]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 30 秒后，Producer 批量发送消息。</span></span><br><span class="line"><span class="comment">// 此时，Consumer 消费到该消息。</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">59</span>:<span class="number">22.753</span>  INFO <span class="number">87236</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">936892120</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">59</span>:<span class="number">22.753</span>  INFO <span class="number">87236</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=<span class="number">128684651</span>&#125;]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">59</span>:<span class="number">22.753</span>  INFO <span class="number">87236</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">27</span> 消息内容：Demo01Message&#123;id=-<span class="number">1940691507</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>Consumer 在消息批量发送后，才消费到该消息。符合预期~</p>
<h1 id="14-批量消费消息"><a href="#14-批量消费消息" class="headerlink" title="14. 批量消费消息"></a>14. 批量消费消息</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-producer-demo</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-batch/"><code>labx-11-sc-stream-kafka-consumer-batch</code></a></li>
</ul>
</blockquote>
<p>在一些业务场景下，我们希望使用 Consumer 批量消费消息，提高消费速度。要注意，Consumer 的批量消费消息，和 Producer 的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「13. 批量发送消息」</a> 没有直接关联哈。</p>
<p>其实现方式是，Consumer 阻塞等待最多 <code>fetch.max.wait.ms</code> 毫秒，至少拉取 <code>fetch.min.bytes</code> 数据量的消息，至多拉取 <code>max.poll.records</code> 数量的消息，进行批量消费。</p>
<ul>
<li>如果在 <code>fetch.max.wait.ms</code> 秒内已经成功拉取到 <code>max.poll.records</code> 条消息，则直接进行批量消费消息。</li>
<li>如果在 <code>fetch.max.wait.ms</code> 秒还没拉取到 <code>max.poll.records</code> 条消息，不再等待，而是进行批量消费消息。</li>
</ul>
<p>下面，我们来实现一个 Spring Cloud Stream Kafka 下的 <strong>Consumer 的批量消费消息</strong>的示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F5223da4354c67361041c1fe6b33d6b35.png" alt="项目结构"></p>
<h2 id="14-1-搭建生产者"><a href="#14-1-搭建生产者" class="headerlink" title="14.1 搭建生产者"></a>14.1 搭建生产者</h2><p>直接使用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo/"><code>labx-11-sc-stream-kafka-producer-demo</code></a> 项目即可。</p>
<h2 id="14-2-搭建消费者"><a href="#14-2-搭建消费者" class="headerlink" title="14.2 搭建消费者"></a>14.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo/"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-batch/"><code>labx-11-sc-stream-kafka-consumer-batch</code></a> 项目作为消费者。</p>
<h3 id="14-2-1-配置文件"><a href="#14-2-1-配置文件" class="headerlink" title="14.2.1 配置文件"></a>14.2.1 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-batch/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，增加批量<strong>消费</strong>消息相关的配置项。完整配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-consumer-application</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># Spring Cloud Stream 配置项，对应 BindingServiceProperties 类</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment"># Binder 配置项，对应 BinderProperties Map</span></span><br><span class="line"><span class="comment">#      binders:</span></span><br><span class="line">      <span class="comment"># Binding 配置项，对应 BindingProperties Map</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo01-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">DEMO-TOPIC-01</span> <span class="comment"># 目的地。这里使用 Kafka Topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 内容格式。这里使用 JSON</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">demo01-consumer-group</span> <span class="comment"># 消费者分组</span></span><br><span class="line">          <span class="comment"># Consumer 配置项，对应 ConsumerProperties 类</span></span><br><span class="line">          <span class="attr">consumer:</span></span><br><span class="line">            <span class="attr">batch-mode:</span> <span class="literal">true</span> <span class="comment"># 是否批量消费默认，默认为 false</span></span><br><span class="line">      <span class="comment"># Spring Cloud Stream Kafka 配置项</span></span><br><span class="line">      <span class="attr">kafka:</span></span><br><span class="line">        <span class="comment"># Kafka Binder 配置项，对应 KafkaBinderConfigurationProperties 类</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">brokers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">          <span class="attr">configuration:</span></span><br><span class="line">            <span class="attr">fetch.max.wait.ms:</span> <span class="number">10000</span> <span class="comment"># poll 一次拉取的阻塞的最大时长，单位：毫秒。这里指的是阻塞拉取需要满足至少 fetch-min-size 大小的消息</span></span><br><span class="line">            <span class="attr">fetch.min.bytes:</span> <span class="number">1024</span> <span class="comment"># poll 一次消息拉取的最小数据量，单位：字节</span></span><br><span class="line">            <span class="attr">max.poll.records:</span> <span class="number">100</span> <span class="comment"># poll 一次消息拉取的最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int[10000,19999]&#125;</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br></pre></td></tr></table></figure>



<p>① 具体 <code>fetch.max.wait.ms</code>、<code>fetch.min.bytes</code>、<code>max.poll.records</code> 配置项的数值配置多少，根据自己的应用来。这里，我们故意将 <code>fetch.max.wait.ms</code> 配置成了 10 秒，主要为了演示之用。</p>
<p>② 设置 <code>spring.cloud.stream.bindings.&lt;bindingName&gt;.consumer.batch-mode</code> 配置项为 <code>true</code>，开启 Consumer 批量消费模式。</p>
<h3 id="14-2-2-Demo01Consumer"><a href="#14-2-2-Demo01Consumer" class="headerlink" title="14.2.2 Demo01Consumer"></a>14.2.2 Demo01Consumer</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-batch/src/main/java/cn/iocoder/springcloud/labx11/kafkademo/consumerdemo/listener/Demo01Consumer.java">Demo01Consumer</a> 类，将消费消息的方法的参数改为 **<code>List&lt;?&gt;</code>**，从而批量消费消息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(MySink.DEMO01_INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> List&lt;Demo01Message&gt; messages)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onMessage][线程编号:&#123;&#125; 消息内容：&#123;&#125;]&quot;</span>, Thread.currentThread().getId(), messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-3-简单测试"><a href="#14-3-简单测试" class="headerlink" title="14.3 简单测试"></a>14.3 简单测试</h2><p>① 执行 <strong>Consumer</strong>Application，启动<strong>消费者</strong>的实例。</p>
<p>② 执行 <strong>Producer</strong>Application，启动<strong>生产者</strong>的实例。</p>
<p>之后，请求 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/demo01/send">http://127.0.0.1:18080/demo01/send</a> 接口三次，发送三条消息。IDEA 控制台输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer 成功同步发送了 3 条消息</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">42.630</span>  INFO <span class="number">92203</span> --- [io-<span class="number">18080</span>-exec-<span class="number">6</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send][发送编号：[-<span class="number">536147214</span>] 发送成功]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">42.877</span>  INFO <span class="number">92203</span> --- [io-<span class="number">18080</span>-exec-<span class="number">7</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send][发送编号：[<span class="number">651899347</span>] 发送成功]</span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">43.071</span>  INFO <span class="number">92203</span> --- [io-<span class="number">18080</span>-exec-<span class="number">8</span>] c.i.s.l.k.k.controller.Demo01Controller  : [send][发送编号：[-<span class="number">1217020146</span>] 发送成功]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 拉取 30 秒超时后，获取到发送的 3 条消息，并批量消费了 3 条消息</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">48.881</span>  INFO <span class="number">92667</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.k.c.listener.Demo01Consumer      : [onMessage][线程编号:<span class="number">30</span> 消息内容：[[B@5cb66abe, [B@66be19cc, [B@63f992da]]</span><br></pre></td></tr></table></figure>



<p>从日志中，我们可以看出，发送的 3 条消息被 Demo01Consumer 批量消费了。</p>
<h1 id="15-监控端点"><a href="#15-监控端点" class="headerlink" title="15. 监控端点"></a>15. 监控端点</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>生产者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-actuator"><code>labx-11-sc-stream-kafka-producer-actuator</code></a></li>
<li>消费者：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-actuator"><code>labx-11-sc-stream-kafka-consumer-actuator</code></a></li>
</ul>
</blockquote>
<p>Spring Cloud Stream 的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/endpoint/BindingsEndpoint.java"><code>endpoint</code></a> 模块，基于 Spring Boot Actuator，提供了自定义监控端点 <a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-sentinel/src/main/java/com/alibaba/cloud/sentinel/endpoint/SentinelEndpoint.java"><code>bindings</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/endpoint/ChannelsEndpoint.java"><code>channels</code></a>，用于获取 Spring Cloud Stream 的 Binding 和 Channel 信息。</p>
<p>同时，Spring Cloud Stream Kafka 拓展了 Spring Boot Actuator 内置的 <code>health</code> 端点，通过自定义的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka/src/main/java/org/springframework/cloud/stream/binder/kafka/KafkaBinderHealthIndicator.java">KafkaBinderHealthIndicator</a>，获取 Kafka 客户端的健康状态。</p>
<blockquote>
<p>友情提示：对 Spring Boot Actuator 不了解的胖友，可以后续阅读<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Actuator/?self">《芋道 Spring Boot 监控端点 Actuator 入门》</a>文章。</p>
</blockquote>
<p>我们来搭建一个 Spring Cloud Stream RocketMQ <strong>监控端点</strong>的使用示例。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F62e4adeb6f3baa2b67d74dc651fb23c2.png" alt="项目结构"></p>
<h2 id="15-1-搭建生产者"><a href="#15-1-搭建生产者" class="headerlink" title="15.1 搭建生产者"></a>15.1 搭建生产者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-demo"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-actuator"><code>labx-11-sc-stream-kafka-producer-actuator</code></a> 项目作为生产者。</p>
<h3 id="15-1-1-引入依赖"><a href="#15-1-1-引入依赖" class="headerlink" title="15.1.1 引入依赖"></a>15.1.1 引入依赖</h3><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-actuator/pom.xml"><code>pom.xml</code></a> 文件中，额外引入 Spring Boot Actuator 相关依赖。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现对 Actuator 的自动化配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="15-1-2-配置文件"><a href="#15-1-2-配置文件" class="headerlink" title="15.1.2 配置文件"></a>15.1.2 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-producer-actuator/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，<strong>额外</strong>增加 Spring Boot Actuator 配置项。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span> <span class="comment"># 需要开放的端点。默认值只打开 health 和 info 两个端点。通过设置 * ，可以开放所有端点。</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="comment"># Health 端点配置项，对应 HealthProperties 配置类</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 是否开启。默认为 true 开启。</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span> <span class="comment"># 何时显示完整的健康信息。默认为 NEVER 都不展示。可选 WHEN_AUTHORIZED 当经过授权的用户；可选 ALWAYS 总是展示。</span></span><br></pre></td></tr></table></figure>



<p>每个配置项的作用，胖友看下艿艿添加的注释。如果还不理解的话，后续看下<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Actuator/?self">《芋道 Spring Boot 监控端点 Actuator 入门》</a>文章。</p>
<h3 id="15-1-3-简单测试"><a href="#15-1-3-简单测试" class="headerlink" title="15.1.3 简单测试"></a>15.1.3 简单测试</h3><p>① 使用 ProducerApplication 启动生产者。</p>
<p>② 访问应用的 <code>bindings</code> 监控端点 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/actuator/bindings%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A![">http://127.0.0.1:18080/actuator/bindings，返回结果如下图：![</a> 监控端点](<a target="_blank" rel="noopener" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0195e4f7088284d84213949c24cd2e7e.png">https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0195e4f7088284d84213949c24cd2e7e.png</a>)</p>
<p>③ 访问应用的 <code>channels</code> 监控端点 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/actuator/channels%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A![">http://127.0.0.1:18080/actuator/channels，返回结果如下图：![</a> 监控端点](<a target="_blank" rel="noopener" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F1ddd85ff936b8971d4429648dc10af6c.png">https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F1ddd85ff936b8971d4429648dc10af6c.png</a>)</p>
<p>④ 访问应用的 <code>health</code> 监控端点 <a target="_blank" rel="noopener" href="http://127.0.0.1:18080/actuator/health%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A![">http://127.0.0.1:18080/actuator/health，返回结果如下图：![</a> 监控端点](<a target="_blank" rel="noopener" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0cc98de40045e3715475c92abda4e202.png">https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0cc98de40045e3715475c92abda4e202.png</a>)</p>
<h2 id="15-2-搭建消费者"><a href="#15-2-搭建消费者" class="headerlink" title="15.2 搭建消费者"></a>15.2 搭建消费者</h2><p>从<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Kafka/#">「3. 快速入门」</a>小节的 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-demo"><code>labx-11-sc-stream-kafka-consumer-demo</code></a> 项目，复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-actuator"><code>labx-11-sc-stream-kafka-consumer-actuator</code></a> 项目作为消费者。</p>
<h3 id="15-2-1-引入依赖"><a href="#15-2-1-引入依赖" class="headerlink" title="15.2.1 引入依赖"></a>15.2.1 引入依赖</h3><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-actuator/pom.xml"><code>pom.xml</code></a> 文件中，额外引入 Spring Boot Actuator 相关依赖。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现对 Actuator 的自动化配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="15-2-2-配置文件"><a href="#15-2-2-配置文件" class="headerlink" title="15.2.2 配置文件"></a>15.2.2 配置文件</h3><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-11-spring-cloud-stream-kafka/labx-11-sc-stream-kafka-consumer-actuator/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，<strong>额外</strong>增加 Spring Boot Actuator 配置项。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span> <span class="comment"># 需要开放的端点。默认值只打开 health 和 info 两个端点。通过设置 * ，可以开放所有端点。</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="comment"># Health 端点配置项，对应 HealthProperties 配置类</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 是否开启。默认为 true 开启。</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">ALWAYS</span> <span class="comment"># 何时显示完整的健康信息。默认为 NEVER 都不展示。可选 WHEN_AUTHORIZED 当经过授权的用户；可选 ALWAYS 总是展示。</span></span><br></pre></td></tr></table></figure>



<p>每个配置项的作用，胖友看下艿艿添加的注释。如果还不理解的话，后续看下<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Actuator/?self">《芋道 Spring Boot 监控端点 Actuator 入门》</a>文章。</p>
<h3 id="15-2-3-简单测试"><a href="#15-2-3-简单测试" class="headerlink" title="15.2.3 简单测试"></a>15.2.3 简单测试</h3><p>① 使用 ConsumerApplication 启动消费者，随机端口为 15748。</p>
<p>② 访问应用的 <code>bindings</code> 监控端点 <a target="_blank" rel="noopener" href="http://127.0.0.1:15748/actuator/bindings%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A![">http://127.0.0.1:15748/actuator/bindings，返回结果如下图：![</a> 监控端点](<a target="_blank" rel="noopener" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F8cbe61dd176634cb9f2450bfa9f8bd4f.png">https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F8cbe61dd176634cb9f2450bfa9f8bd4f.png</a>)</p>
<p>③ 访问应用的 <code>channels</code> 监控端点 <a target="_blank" rel="noopener" href="http://127.0.0.1:15748/actuator/channels%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A![">http://127.0.0.1:15748/actuator/channels，返回结果如下图：![</a> 监控端点](<a target="_blank" rel="noopener" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F291400348a33ad5bf618c7a3fe6e55ee.png">https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F291400348a33ad5bf618c7a3fe6e55ee.png</a>)</p>
<p>④ 访问应用的 <code>health</code> 监控端点 <a target="_blank" rel="noopener" href="http://127.0.0.1:15748/actuator/health%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A![">http://127.0.0.1:15748/actuator/health，返回结果如下图：![</a> 监控端点](<a target="_blank" rel="noopener" href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F291400348a33ad5bf618c7a3fe6e55ee.png">https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F291400348a33ad5bf618c7a3fe6e55ee.png</a>)</p>
<h1 id="——–-6"><a href="#——–-6" class="headerlink" title="——–"></a>——–</h1><h1 id="SpringCloud事件总线中的Kafka"><a href="#SpringCloud事件总线中的Kafka" class="headerlink" title="SpringCloud事件总线中的Kafka"></a>SpringCloud事件总线中的Kafka</h1><h1 id="——–-7"><a href="#——–-7" class="headerlink" title="——–"></a>——–</h1><h1 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote>
<p>友情提示：在开始本文之前，胖友需要对 Kafka 进行简单的学习。可以阅读<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Kafka/install/?self">《Kafka 极简入门》</a>文章，将第<strong>一二</strong>小节看完，在本机搭建一个 Kafka 服务。</p>
<p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，她有如下特性：</p>
<ul>
<li>通过 O(1) 的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li>
<li>高吞吐量：即使是非常普通的硬件kafka也可以支持每秒数十万的消息。</li>
<li>支持通过 Kafka 服务器和消费机集群来分区消息。</li>
</ul>
</blockquote>
<p>本文我们来学习 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-starter-bus-kafka">Spring Cloud Bus Kafka</a> 组件，基于 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus">Spring Cloud Bus</a> 的编程模型，接入 Kafka 消息队列，实现<strong>事件总线</strong>的功能。</p>
<blockquote>
<p>Spring Cloud Bus 是<strong>事件、消息总线</strong>，用于在集群（例如，配置变化事件）中传播状态变化，可与 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Cloud/Spring-Cloud-Config/?self">Spring Cloud Config</a> 联合实现热部署。</p>
</blockquote>
<p>在<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Event/?self">《芋道 Spring Boot 事件机制 Event 入门》</a>文章，我们已经了解到，Spring 内置了事件机制，可以实现 <strong>JVM 进程内</strong>的事件发布与监听。但是如果想要<strong>跨 JVM 进程</strong>的事件发布与监听，此时它就无法满足我们的诉求了。</p>
<p>因此，Spring Cloud Bus 在 Spring 事件机制的基础之上进行<strong>拓展</strong>，结合 RabbitMQ、Kafka、RocketMQ 等等消息队列作为事件的<strong>“传输器”</strong>，通过发送事件（消息）到消息队列上，从而广播到订阅该事件（消息）的所有节点上。最终如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Ffa1a17b3cea554f6ce9859209569ca48.png" alt="整体模型"></p>
<p>Spring Cloud Bus 定义了 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/RemoteApplicationEvent.java">RemoteApplicationEvent</a> 类，远程的 ApplicationEvent 的<strong>抽象基类</strong>。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = &quot;type&quot;)</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&quot;source&quot;)</span> <span class="comment">// &lt;2&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RemoteApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123; <span class="comment">// &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String originService;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String destinationService;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ... 省略一大撮代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>显然，我们使用 Spring Cloud Bus 发送的自定义事件，必须要<strong>继承</strong> RemoteApplicationEvent 类。</p>
</li>
<li><p><code>&lt;1&gt;</code> 处，继承 Spring 事件机制定义的 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationEvent.java">ApplicationEvent</a> 抽象基类。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，通过 Jackson 的 <code>@JsonIgnoreProperties</code> 注解，设置忽略继承自 ApplicationEvent 的 <code>source</code> 属性，避免序列化问题。</p>
</li>
<li><p><code>id</code> 属性，事件编号。一般情况下，RemoteApplicationEvent 会使用 <code>UUID.randomUUID().toString()</code> 代码，自动生成 UUID 即可。</p>
</li>
<li><p><code>originService</code> 属性，来源服务。Spring Cloud Bus 提供好了 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/ServiceMatcher.java"><code>ServiceMatcher#getServiceId()</code></a> 方法，获取服务编号作为 <code>originService</code> 属性的值。</p>
<blockquote>
<p>友情提示：这个属性非常关键，艿艿稍后会详细讲一下，都是眼泪啊！！！</p>
</blockquote>
</li>
<li><p><code>destinationService</code> 属性，目标服务。该属性的格式是 <code>&#123;服务名&#125;:&#123;服务实例编号&#125;</code>。</p>
<blockquote>
<p>举个板栗：</p>
<ul>
<li>如果想要广播给所有服务的所有实例，则设置为 <code>**:**</code>。</li>
<li>如果想要广播给 <code>users</code> 服务的所有实例，则设置为 <code>users:**</code>。</li>
<li>如如果想要广播给 <code>users</code> 服务的指定实例，则设置为 <code>users:bc6d27d7-dc0f-4386-81fc-0b3363263a15</code>。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h1><blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>事件发布器：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/"><code>labx-19-sc-bus-kafka-demo-publisher</code></a></li>
<li>事件监听器：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/"><code>labx-19-sc-bus-kafka-demo-listener</code></a></li>
</ul>
</blockquote>
<p>哔哔再多，不如撸个 Spring Cloud Bus 快速入门的示例。我们会新建两个项目：</p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F9c9b833d56140c3e724260c381e7abe6.png" alt="项目结构"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/"><code>labx-19-sc-bus-kafka-demo-publisher</code></a>：扮演事件<strong>发布器</strong>的角色，使用 Spring Cloud Bus 发送事件。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/"><code>labx-19-sc-bus-kafka-demo-listener</code></a>：扮演事件<strong>监听器</strong>的角色，使用 Spring Cloud Bus 监听事件。</li>
</ul>
<h2 id="2-1-事件发布器项目"><a href="#2-1-事件发布器项目" class="headerlink" title="2.1 事件发布器项目"></a>2.1 事件发布器项目</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/"><code>labx-19-sc-bus-kafka-demo-publisher</code></a> 项目，扮演事件<strong>发布器</strong>的角色，使用 Spring Cloud Bus 发送事件。</p>
<h3 id="2-1-1-引入依赖"><a href="#2-1-1-引入依赖" class="headerlink" title="2.1.1 引入依赖"></a>2.1.1 引入依赖</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/pom.xml"><code>pom.xml</code></a> 文件，引入 Spring Cloud Bus 相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>labx-19<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.iocoder.springboot.labs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>labx-19-sc-bus-kafka-demo-publisher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        引入 Spring Boot、Spring Cloud、Spring Cloud Alibaba 三者 BOM 文件，进行依赖版本的管理，防止不兼容。</span></span><br><span class="line"><span class="comment">        在 https://dwz.cn/mcLIfNKt 文章中，Spring Cloud Alibaba 开发团队推荐了三者的依赖关系</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 SpringMVC 相关依赖，并实现对其的自动配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入基于 Kafka 的 Spring Cloud Bus 的实现的依赖，并实现对其的自动配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-1-2-配置文件"><a href="#2-1-2-配置文件" class="headerlink" title="2.1.2 配置文件"></a>2.1.2 配置文件</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/src/main/resources/application.yml"><code>application.yml</code></a> 配置文件，添加 Spring Cloud Bus 相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">publisher-demo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Bus 相关配置项，对应 BusProperties</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 是否开启，默认为 true</span></span><br><span class="line">      <span class="attr">destination:</span> <span class="string">springCloudBus</span> <span class="comment"># 目标消息队列，默认为 springCloudBus</span></span><br></pre></td></tr></table></figure>



<p>① <code>spring.kafka</code> 配置项，为 Kafka 相关配置项。</p>
<blockquote>
<p>友情提示：感兴趣的胖友，可以阅读<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Kafka/?self">《芋道 Spring Boot 消息队列 Kafka 入门》</a>文章。</p>
</blockquote>
<p>② <code>spring.cloud.bus</code> 配置项，为 Spring Cloud Bus 配置项，对应 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/BusProperties.java">BusProperties</a> 类。一般情况下，使用默认值即可。</p>
<h3 id="2-1-3-UserRegisterEvent"><a href="#2-1-3-UserRegisterEvent" class="headerlink" title="2.1.3 UserRegisterEvent"></a>2.1.3 UserRegisterEvent</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/src/main/java/cn/iocoder/springcloud/labx19/publisherdemo/event/UserRegisterEvent.java">UserRegisterEvent</a> 类，用户注册事件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title class_">RemoteApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisterEvent</span><span class="params">()</span> &#123; <span class="comment">// 序列化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisterEvent</span><span class="params">(Object source, String originService, String destinationService, String username)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source, originService);</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>① 继承 RemoteApplicationEvent 抽象基类。</p>
<p>② 创建一个空的构造方法，毕竟要序列化。</p>
<h3 id="2-1-4-DemoController"><a href="#2-1-4-DemoController" class="headerlink" title="2.1.4 DemoController"></a>2.1.4 DemoController</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/src/main/java/cn/iocoder/springcloud/labx19/publisherdemo/controller/DemoController.java">DemoController</a> 类，提供 <code>/demo/register</code> 注册接口，发送 UserRegisterEvent 事件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceMatcher busServiceMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 执行注册逻辑</span></span><br><span class="line">        logger.info(<span class="string">&quot;[register][执行用户(&#123;&#125;) 的注册逻辑]&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... &lt;2&gt; 发布</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisterEvent</span>(<span class="built_in">this</span>, busServiceMatcher.getServiceId(),</span><br><span class="line">                <span class="literal">null</span>, username)); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>&lt;1&gt;</code> 处，创建 UserRegisterEvent 对象。</p>
<ul>
<li><code>originService</code> 属性，通过 <code>ServiceMatcher#getServiceId()</code> 方法，获得服务编号。</li>
<li><code>destinationService</code> 属性，我们传入 <code>null</code> 值。RemoteApplicationEvent 会自动转换成 <code>**</code>，表示广播给所有监听该消息的实例。</li>
</ul>
<p><code>&lt;2&gt;</code> 处，和 Spring 事件机制<strong>一样</strong>，通过 ApplicationEventPublisher 的 <code>#publishEvent(event)</code> 方法，直接发送事件到 Spring Cloud Bus 消息总线。好奇的胖友，可以打开 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/BusAutoConfiguration.java#L142-L151">BusAutoConfiguration</a> 的代码，如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fae7294563e20ddf90e079320077fc56c.png" alt="BusAutoConfiguration 源码"></p>
<blockquote>
<p>友情提示：如果胖友仔细看的话，还可以发现 Spring Cloud Bus 是使用 Spring Cloud Stream 进行消息的收发的。</p>
</blockquote>
<h3 id="2-1-5-PublisherDemoApplication"><a href="#2-1-5-PublisherDemoApplication" class="headerlink" title="2.1.5 PublisherDemoApplication"></a>2.1.5 PublisherDemoApplication</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/src/main/java/cn/iocoder/springcloud/labx19/publisherdemo/PublisherDemoApplication.java">PublisherDemoApplication</a> 类，作为启动类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PublisherDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-事件监听器项目"><a href="#2-2-事件监听器项目" class="headerlink" title="2.2 事件监听器项目"></a>2.2 事件监听器项目</h2><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/"><code>labx-19-sc-bus-kafka-demo-listener</code></a> 项目，扮演事件<strong>监听器</strong>的角色，使用 Spring Cloud Bus 监听事件。</p>
<h3 id="2-2-1-引入依赖"><a href="#2-2-1-引入依赖" class="headerlink" title="2.2.1 引入依赖"></a>2.2.1 引入依赖</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/pom.xml"><code>pom.xml</code></a> 文件，引入相关的依赖。和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Bus-Kafka/?self#">「2.1.1 引入依赖」</a>是一致的，就不重复“贴”出来了，胖友点击 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/pom.xml"><code>pom.xml</code></a> 文件查看。</p>
<h3 id="2-2-2-配置文件"><a href="#2-2-2-配置文件" class="headerlink" title="2.2.2 配置文件"></a>2.2.2 配置文件</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，添加相关的配置项。和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Bus-Kafka/?self#">「2.1.2 配置文件」</a>是一致的，就不重复“贴”出来了，胖友点击 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/src/main/resources/application.yml"><code>application.yaml</code></a> 文件查看。</p>
<h3 id="2-2-3-UserRegisterEvent"><a href="#2-2-3-UserRegisterEvent" class="headerlink" title="2.2.3 UserRegisterEvent"></a>2.2.3 UserRegisterEvent</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/src/main/java/cn/iocoder/springcloud/labx19/listenerdemo/event/UserRegisterEvent.java">UserRegisterEvent</a> 类，用户注册事件。和<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Bus-Kafka/?self#">「2.1.3 UserRegisterEvent」</a>是一致的，就不重复“贴”出来了，胖友点击 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/src/main/java/cn/iocoder/springcloud/labx19/listenerdemo/event/UserRegisterEvent.java">UserRegisterEvent</a> 文件查看。</p>
<h3 id="2-2-4-UserRegisterListener"><a href="#2-2-4-UserRegisterListener" class="headerlink" title="2.2.4 UserRegisterListener"></a>2.2.4 UserRegisterListener</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/src/main/java/cn/iocoder/springcloud/labx19/listenerdemo/listener/UserRegisterListener.java">UserRegisterListener</a> 类，监听 UserRegisterEvent 事件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户注册事件的监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;UserRegisterEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;[onApplicationEvent][监听到用户(&#123;&#125;) 注册]&quot;</span>, event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>和 Spring 事件机制<strong>一样</strong>，只需要监听指定事件即可。好奇的胖友，可以打开 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/BusAutoConfiguration.java#L153-L190">BusAutoConfiguration</a> 的代码，如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F3a9a4ba52f1c979013a62cf834abd21a.png" alt="BusAutoConfiguration 源码"></p>
<h3 id="2-2-5-ListenerDemoApplication"><a href="#2-2-5-ListenerDemoApplication" class="headerlink" title="2.2.5 ListenerDemoApplication"></a>2.2.5 ListenerDemoApplication</h3><p>创建 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/src/main/java/cn/iocoder/springcloud/labx19/listenerdemo/ListenerDemoApplication.java">ListenerDemoApplication</a> 类，作为启动类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RemoteApplicationEventScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ListenerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在类上，添加 Spring Cloud Bus 定义的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/jackson/RemoteApplicationEventScan.java"><code>@RemoteApplicationEventScan</code></a> 注解，声明要从 Spring Cloud Bus 监听 RemoteApplicationEvent 事件。</p>
<h2 id="2-3-简单测试"><a href="#2-3-简单测试" class="headerlink" title="2.3 简单测试"></a>2.3 简单测试</h2><p>① 执行 PublisherDemoApplication 一次，启动一个事件<strong>发布器</strong>。</p>
<p>② 执行 ListenerDemoApplication <strong>两次</strong>，启动两个事件<strong>监听器</strong>。需要将「Allow parallel run」进行勾选，如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F8b66269c67c425a3f0e8c12750e69853.png" alt="IDEA"></p>
<p>此时，我们可以在 Kafka 运维界面看到 <strong>springCloudBus</strong> 这个 Topic，如下图所示：</p>
<ul>
<li><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Faae41ac63dbcf5fa4c92b6e351076779.png" alt="Kafka 运维界面 - Topic"></li>
<li><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Ffd3fab2a275759cbc29586ac2893f581.png" alt="Kafka 运维界面 - Consumer"></li>
</ul>
<p>③ 调用 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/demo/register?username=yudaoyuanma">http://127.0.0.1:8080/demo/register?username=yudaoyuanma</a> 接口，进行注册。IDEA 控制台打印日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># PublisherDemoApplication 控制台</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-09 <span class="number">07</span>:<span class="number">42</span>:<span class="number">03.417</span>  INFO <span class="number">31050</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] c.i.s.l.p.controller.DemoController      : [register][执行用户(haha) 的注册逻辑]</span><br><span class="line"></span><br><span class="line"># ListenerDemoApplication 控制台 <span class="number">01</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-09 <span class="number">07</span>:<span class="number">42</span>:<span class="number">03.603</span>  INFO <span class="number">31027</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.l.listener.UserRegisterListener  : [onApplicationEvent][监听到用户(haha) 注册]</span><br><span class="line"></span><br><span class="line"># ListenerDemoApplication 控制台 <span class="number">02</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-09 <span class="number">07</span>:<span class="number">42</span>:<span class="number">03.603</span>  INFO <span class="number">31040</span> --- [container-<span class="number">0</span>-C-<span class="number">1</span>] c.i.s.l.l.listener.UserRegisterListener  : [onApplicationEvent][监听到用户(haha) 注册]</span><br></pre></td></tr></table></figure>



<p>发布的 UserRegisterEvent 事件，被两个事件监听器的进程都监听成功。</p>
<h1 id="3-监控端点"><a href="#3-监控端点" class="headerlink" title="3. 监控端点"></a>3. 监控端点</h1><blockquote>
<p>示例代码对应仓库：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener-actuator/"><code>labx-19-sc-bus-kafka-demo-listener-actuator</code></a></p>
</blockquote>
<p>Spring Cloud Bus 的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/endpoint/a"><code>endpoint</code></a> 模块，基于 Spring Boot Actuator，提供了两个自定义监控端点：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/endpoint/EnvironmentBusEndpoint.java"><code>bus-env</code></a> 端点：发布 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/EnvironmentChangeRemoteApplicationEvent.java">EnvironmentChangeRemoteApplicationEvent</a> 事件，配合 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/EnvironmentChangeListener.java">EnvironmentChangeListener</a> 监听器，实现通知并修改远程服务的本地<strong>配置项</strong>。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F02862a15c00a54ee56b917fd4f466c3c.png" alt="EnvironmentChangeRemoteApplicationEvent 发布与监听"></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/endpoint/RefreshBusEndpoint.java"><code>bus-refresh</code></a> 端点：发布 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/endpoint/RefreshBusEndpoint.java">RefreshRemoteApplicationEvent</a> 事件，配合 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/RefreshListener.java">RefreshListener</a> 监听器，实现通知并刷新远程服务的 <strong>Spring Context</strong>。如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fc121a694f2f63f6f786fd8d397b2c81d.png" alt="RefreshRemoteApplicationEvent 发布与监听"></li>
</ul>
<p>同时，Spring Cloud Bus 拓展了 Spring Boot Actuator 内置的 <code>httptrace</code> 端点，会监听 Spring Cloud Bus <strong>发送</strong>消息时产生的 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/SentApplicationEvent.java">SentApplicationEvent</a> 事件和<strong>确认</strong>消息的产生 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/AckRemoteApplicationEvent.java">AckRemoteApplicationEvent</a> 事件，配合 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/TraceListener.java">TraceListener</a> 监听器，记录相应的跟踪信息。不过因为 <code>httptrace</code> 端点改版了，所以目前该功能已经失效，而且<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-bus/commit/10c08c7a8450d84823a8cd82bc9b6e3f9d51be95">失效了 2 年多了</a>，具体代码如下：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F71b962c174412c4d8026c92f1b04ea66.png" alt="TraceListener 源码"></p>
<blockquote>
<p>友情提示：对 Spring Boot Actuator 不了解的胖友，可以后续阅读<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Actuator/?self">《芋道 Spring Boot 监控端点 Actuator 入门》</a>文章。</p>
</blockquote>
<p>我们来搭建一个 Spring Cloud Bus 监控端点的使用示例。考虑方便，我们直接复用<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Bus-Kafka/?self#">「2. 快速入门」</a>小节的项目，从 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener/"><code>labx-19-sc-bus-kafka-demo-listener</code></a> 复制出 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener-actuator/"><code>labx-19-sc-bus-kafka-demo-listener-actuator</code></a>，测试 Spring Cloud Bus 的监控端点结果。最终项目如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F1dce407b9d45f94a75649a4fe5938de6.png" alt="项目结构"></p>
<blockquote>
<p>友情提示：不使用 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-publisher/"><code>labx-19-sc-bus-kafka-demo-publisher</code></a> 的原因是，未添加 <code>@RemoteApplicationEventScan</code> 注解，不会从 Spring Cloud Bus <strong>中</strong>监听 RemoteApplicationEvent 事件。</p>
</blockquote>
<h2 id="3-1-引入依赖-1"><a href="#3-1-引入依赖-1" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h2><p>在 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener-actuator/pom.xml"><code>pom.xml</code></a> 文件中，额外引入 Spring Boot Actuator 相关依赖。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现对 Actuator 的自动化配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2 配置文件"></a>3.2 配置文件</h2><p>修改 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-bus-kafka-demo-listener-actuator/src/main/resources/application.yml"><code>application.yaml</code></a> 配置文件，<strong>额外</strong>增加 Spring Boot Actuator 配置项。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">listener-demo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18080</span> <span class="comment"># 随机端口，方便启动多个消费者</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="comment"># Actuator HTTP 配置项，对应 WebEndpointProperties 配置类</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span> <span class="comment"># 需要开放的端点。默认值只打开 health 和 info 两个端点。通过设置 * ，可以开放所有端点。</span></span><br></pre></td></tr></table></figure>



<p>新增 <code>management</code> 配置项，设置 Spring Boot Actuator 配置项。这里先不详细解析，后续看下<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/Actuator/?self">《芋道 Spring Boot 监控端点 Actuator 入门》</a>文章。</p>
<h2 id="3-3-简单测试"><a href="#3-3-简单测试" class="headerlink" title="3.3 简单测试"></a>3.3 简单测试</h2><p>执行 ListenerDemoApplication 启动项目。</p>
<p>① 使用 Postman 模拟请求 <code>bus-env</code> 端点，如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F96438153bf4dbbf46b8a643b77aea86b.png" alt="Postman  端口"></p>
<p>此时，我们在控制台可以看到 EnvironmentChangeListener 打印日志如下，说明成功接收到 EnvironmentChangeRemoteApplicationEvent 事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-09 <span class="number">07</span>:<span class="number">53</span>:<span class="number">33.737</span>  INFO <span class="number">31712</span> --- [io-<span class="number">18080</span>-exec-<span class="number">1</span>] o.s.c.b.event.EnvironmentChangeListener  : Received remote environment change request. Keys/values to update &#123;test-property=test-value&#125;</span><br></pre></td></tr></table></figure>



<p>② 使用 Postman 模拟请求 <code>bus-refresh</code> 端点，如下图所示：<img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fb335201622ffba02385d5b22e04e10e3.png" alt="Postman  端口"></p>
<p>此时，我们在控制台可以看到 RefreshListener 打印日志如下，说明成功接收到 RefreshRemoteApplicationEvent 事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-09 <span class="number">07</span>:<span class="number">53</span>:<span class="number">46.409</span>  INFO <span class="number">31712</span> --- [io-<span class="number">18080</span>-exec-<span class="number">2</span>] o.s.cloud.bus.event.RefreshListener      : Received remote refresh request. Keys refreshed []</span><br></pre></td></tr></table></figure>



<h1 id="4-集成到-Spring-Cloud-Config"><a href="#4-集成到-Spring-Cloud-Config" class="headerlink" title="4. 集成到 Spring Cloud Config"></a>4. 集成到 Spring Cloud Config</h1><p>实际上，Spring Cloud Bus 在日常开发中，<strong>基本不会使用到</strong>。绝大多数情况下，我们通过使用 Spring Cloud Stream 即可实现它所有的功能，并且更加强大和灵活。同时，艿艿也找了一些在使用 Spring Cloud 作为微服务解决方案的胖友，确实一个都没有在使用 Spring Cloud Bus 的 &#x3D; &#x3D;。</p>
<p>倔强的艿艿又翻阅了网上的相关资料，绝大多数都是提到通过 Spring Cloud Bus，实现 Spring Cloud Config 配置中心的<strong>自动配置刷新</strong>的功能。因此，可能我们不是很必要去学习它，哈哈哈。</p>
<p>不过良心的艿艿，还是在<a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Cloud/Spring-Cloud-Config/?self">《芋道 Spring Cloud 配置中心 Spring Cloud Config 入门》</a>文章的<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Spring-Cloud/Bus-Kafka/?self#">「5. 自动配置刷新（第二弹）」</a>小节中，将 Spring Cloud Bus 集成到 Spring Cloud Config 中，实现配置中心的<strong>自动配置刷新</strong>的功能。</p>
<p><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F25df2f8b1478ac242b7c7fa298a0cf0a.png" alt="Spring Cloud Config + Spring Cloud Bus"></p>
<blockquote>
<p>示例代码对应仓库：</p>
<ul>
<li>配置中心：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-config-server-git-auto-refresh-by-bus/"><code>labx-19-sc-config-server-git-auto-refresh-by-bus</code></a></li>
<li>用户服务：<a target="_blank" rel="noopener" href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/labx-19/labx-19-sc-config-user-application-auto-refresh-by-bus/pom.xml"><code>labx-19-sc-config-user-application-auto-refresh-by-bus</code></a></li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.chenjiabin.xyz">Chen Jiabin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.chenjiabin.xyz/posts/14310/">https://blog.chenjiabin.xyz/posts/14310/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.chenjiabin.xyz" target="_blank">青墨染烟雨</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">入门到精通</a></div><div class="post-share"><div class="social-share" data-image="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0325c825fa31fa6f45916f706a22cca4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020504.jpg" target="_blank"><img class="post-qr-code-img" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020504.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020503.png" target="_blank"><img class="post-qr-code-img" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202502282020503.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/10048/" title="Docker学习笔记"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Faa90ae7420321f0930ea6719b29c828d.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker学习笔记</div></div><div class="info-2"><div class="info-item-1">Docker的安装和扫盲，以及学习网站</div></div></div></a><a class="pagination-related" href="/posts/52481/" title="ElasticSearch入门到精通"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fe69b8f01e7d0f2581a3d4bfe20e93a23.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ElasticSearch入门到精通</div></div><div class="info-2"><div class="info-item-1">ElasticSearch入门到精通</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/52481/" title="ElasticSearch入门到精通"><img class="cover" src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fe69b8f01e7d0f2581a3d4bfe20e93a23.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="info-item-2">ElasticSearch入门到精通</div></div><div class="info-2"><div class="info-item-1">ElasticSearch入门到精通</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/202503011603481.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Chen Jiabin</div><div class="author-info-description">回首向来萧瑟处,归去,也无风雨也无晴</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qinmoranyanyu"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.cnblogs.com/chenjiabin" target="_blank" title="博客园"><i class="fa-solid fa-blog" style="color: #000000;"></i></a><a class="social-icon" href="https://gitee.com/forever-or-moment" target="_blank" title="gitee"><i class="fa-solid fa-rss" style="color: #000000;"></i></a><a class="social-icon" href="mailto:2948429338@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">基于hexo的博客网站,终于搭好了!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93"><span class="toc-number">1.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-1"><span class="toc-number">3.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2"><span class="toc-number">5.</span> <span class="toc-text">2. 单机部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">5.1.</span> <span class="toc-text">2.1 下载软件包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">2.2 配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%90%AF%E5%8A%A8-Kafka"><span class="toc-number">5.3.</span> <span class="toc-text">2.3 启动 Kafka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%88%9B%E5%BB%BA-Topic"><span class="toc-number">5.4.</span> <span class="toc-text">2.4 创建 Topic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%B5%8B%E8%AF%95%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">5.5.</span> <span class="toc-text">2.5 测试发送消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%B5%8B%E8%AF%95%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">5.6.</span> <span class="toc-text">2.6 测试消费消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">6.</span> <span class="toc-text">3. 集群部署</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Kafka-Manager"><span class="toc-number">7.</span> <span class="toc-text">4. Kafka Manager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">7.1.</span> <span class="toc-text">4.1 下载软件包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.2.</span> <span class="toc-text">4.2 配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%90%AF%E5%8A%A8-Kafka-Manager"><span class="toc-number">7.3.</span> <span class="toc-text">4.3 启动 Kafka Manager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B7%BB%E5%8A%A0-Kafka-%E9%9B%86%E7%BE%A4"><span class="toc-number">7.4.</span> <span class="toc-text">4.4 添加 Kafka 集群</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">5. 简单示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">8.1.</span> <span class="toc-text">5.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-ProducerMain"><span class="toc-number">8.2.</span> <span class="toc-text">5.2 ProducerMain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-ConsumerMain"><span class="toc-number">8.3.</span> <span class="toc-text">5.3 ConsumerMain</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-2"><span class="toc-number">9.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E4%B8%AD%E7%9A%84Kafka"><span class="toc-number">10.</span> <span class="toc-text">SpringBoot中的Kafka</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-3"><span class="toc-number">11.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-number">12.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Spring-Kafka"><span class="toc-number">13.</span> <span class="toc-text">2. Spring-Kafka</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">14.</span> <span class="toc-text">3. 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">14.1.</span> <span class="toc-text">3.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">14.2.</span> <span class="toc-text">3.2 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Application"><span class="toc-number">14.3.</span> <span class="toc-text">3.3 Application</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Demo01Message"><span class="toc-number">14.4.</span> <span class="toc-text">3.4 Demo01Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Demo01Producer"><span class="toc-number">14.5.</span> <span class="toc-text">3.5 Demo01Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Demo01Consumer"><span class="toc-number">14.6.</span> <span class="toc-text">3.6 Demo01Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Demo01AConsumer"><span class="toc-number">14.7.</span> <span class="toc-text">3.7 Demo01AConsumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">14.8.</span> <span class="toc-text">3.8 简单测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-KafkaListener"><span class="toc-number">14.9.</span> <span class="toc-text">3.9 @KafkaListener</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">15.</span> <span class="toc-text">4. 批量发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">15.1.</span> <span class="toc-text">4.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">15.2.</span> <span class="toc-text">4.2 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Demo02Message"><span class="toc-number">15.3.</span> <span class="toc-text">4.3 Demo02Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Demo02Producer"><span class="toc-number">15.4.</span> <span class="toc-text">4.4 Demo02Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Demo02Consumer"><span class="toc-number">15.5.</span> <span class="toc-text">4.5 Demo02Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">15.6.</span> <span class="toc-text">4.6 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">16.</span> <span class="toc-text">5. 批量消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">16.1.</span> <span class="toc-text">5.1 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Demo02Consumer"><span class="toc-number">16.2.</span> <span class="toc-text">5.2 Demo02Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">16.3.</span> <span class="toc-text">5.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">17.</span> <span class="toc-text">6. 定时消息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">18.</span> <span class="toc-text">7. 消费重试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-KafkaConfiguration"><span class="toc-number">18.1.</span> <span class="toc-text">7.1 KafkaConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Demo04Message"><span class="toc-number">18.2.</span> <span class="toc-text">7.2 Demo04Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Demo04Producer"><span class="toc-number">18.3.</span> <span class="toc-text">7.3 Demo04Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Demo04Consumer"><span class="toc-number">18.4.</span> <span class="toc-text">7.4 Demo04Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">18.5.</span> <span class="toc-text">7.5 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9"><span class="toc-number">19.</span> <span class="toc-text">8. 广播消费</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">19.1.</span> <span class="toc-text">8.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">19.2.</span> <span class="toc-text">8.2 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-Demo05Message"><span class="toc-number">19.3.</span> <span class="toc-text">8.3 Demo05Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Demo05Producer"><span class="toc-number">19.4.</span> <span class="toc-text">8.4 Demo05Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-Demo05Consumer"><span class="toc-number">19.5.</span> <span class="toc-text">8.5 Demo05Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">19.6.</span> <span class="toc-text">8.6 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%B9%B6%E5%8F%91%E6%B6%88%E8%B4%B9"><span class="toc-number">20.</span> <span class="toc-text">9. 并发消费</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">20.1.</span> <span class="toc-text">9.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">20.2.</span> <span class="toc-text">9.2 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Demo06Message"><span class="toc-number">20.3.</span> <span class="toc-text">9.3 Demo06Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-Demo06Producer"><span class="toc-number">20.4.</span> <span class="toc-text">9.4 Demo06Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-Demo06Consumer"><span class="toc-number">20.5.</span> <span class="toc-text">9.5 Demo06Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">20.6.</span> <span class="toc-text">9.6 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">21.</span> <span class="toc-text">10. 顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-Demo06Producer"><span class="toc-number">21.1.</span> <span class="toc-text">10.1 Demo06Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">21.2.</span> <span class="toc-text">10.2 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">22.</span> <span class="toc-text">11. 事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">22.1.</span> <span class="toc-text">11.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">22.2.</span> <span class="toc-text">11.2 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-Demo07Producer"><span class="toc-number">22.3.</span> <span class="toc-text">11.3 Demo07Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-Demo07Consumer"><span class="toc-number">22.4.</span> <span class="toc-text">11.4 Demo07Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">22.5.</span> <span class="toc-text">11.5 简单测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-%E9%9B%86%E6%88%90%E5%88%B0-Spring-Transaction-%E4%BD%93%E7%B3%BB"><span class="toc-number">22.6.</span> <span class="toc-text">11.6 集成到 Spring Transaction 体系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%9A%84%E6%8F%90%E4%BA%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">23.</span> <span class="toc-text">12. 消费进度的提交机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">23.1.</span> <span class="toc-text">12.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">23.2.</span> <span class="toc-text">12.2 应用配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Demo08Message"><span class="toc-number">23.3.</span> <span class="toc-text">12.3 Demo08Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-Demo08Producer"><span class="toc-number">23.4.</span> <span class="toc-text">12.4 Demo08Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-Demo08Consumer"><span class="toc-number">23.5.</span> <span class="toc-text">12.5 Demo08Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-6-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">23.6.</span> <span class="toc-text">12.6 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-4"><span class="toc-number">24.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud%E4%B8%AD%E7%9A%84Kafka"><span class="toc-number">25.</span> <span class="toc-text">SpringCloud中的Kafka</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-5"><span class="toc-number">26.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="toc-number">27.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Spring-Cloud-Stream-%E4%BB%8B%E7%BB%8D"><span class="toc-number">28.</span> <span class="toc-text">2. Spring Cloud Stream 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">29.</span> <span class="toc-text">3. 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">29.1.</span> <span class="toc-text">3.1 搭建生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">29.1.1.</span> <span class="toc-text">3.1.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">29.1.2.</span> <span class="toc-text">3.1.2 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-MySource"><span class="toc-number">29.1.3.</span> <span class="toc-text">3.1.3 MySource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-Demo01Message"><span class="toc-number">29.1.4.</span> <span class="toc-text">3.1.4 Demo01Message</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-Demo01Controller"><span class="toc-number">29.1.5.</span> <span class="toc-text">3.1.5 Demo01Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-ProducerApplication"><span class="toc-number">29.1.6.</span> <span class="toc-text">3.1.6 ProducerApplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">29.2.</span> <span class="toc-text">3.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">29.2.1.</span> <span class="toc-text">3.2.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">29.2.2.</span> <span class="toc-text">3.2.2 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-MySink"><span class="toc-number">29.2.3.</span> <span class="toc-text">3.2.3 MySink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-Demo01Message"><span class="toc-number">29.2.4.</span> <span class="toc-text">3.2.4 Demo01Message</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-Demo01Consumer"><span class="toc-number">29.2.5.</span> <span class="toc-text">3.2.5 Demo01Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-ConsumerApplication"><span class="toc-number">29.2.6.</span> <span class="toc-text">3.2.6 ConsumerApplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B5%8B%E8%AF%95%E5%8D%95%E9%9B%86%E7%BE%A4%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">29.3.</span> <span class="toc-text">3.3 测试单集群多实例的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%B5%8B%E8%AF%95%E5%A4%9A%E9%9B%86%E7%BE%A4%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">29.4.</span> <span class="toc-text">3.4 测试多集群多实例的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">29.5.</span> <span class="toc-text">3.5 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">30.</span> <span class="toc-text">4. 定时消息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">31.</span> <span class="toc-text">5. 消费重试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">31.1.</span> <span class="toc-text">5.1 搭建生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">31.2.</span> <span class="toc-text">5.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">31.2.1.</span> <span class="toc-text">5.2.1 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-Demo01Consumer"><span class="toc-number">31.2.2.</span> <span class="toc-text">5.2.2 Demo01Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95-1"><span class="toc-number">31.3.</span> <span class="toc-text">5.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%B6%88%E8%B4%B9%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">32.</span> <span class="toc-text">6. 消费异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">32.1.</span> <span class="toc-text">6.1 搭建生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">32.2.</span> <span class="toc-text">6.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-Demo01Consumer"><span class="toc-number">32.2.1.</span> <span class="toc-text">6.2.1 Demo01Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">32.3.</span> <span class="toc-text">6.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9"><span class="toc-number">33.</span> <span class="toc-text">7. 广播消费</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">33.1.</span> <span class="toc-text">7.1 搭建生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">33.2.</span> <span class="toc-text">7.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">33.2.1.</span> <span class="toc-text">7.2.1 配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">33.3.</span> <span class="toc-text">7.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%B9%B6%E5%8F%91%E6%B6%88%E8%B4%B9"><span class="toc-number">34.</span> <span class="toc-text">8. 并发消费</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">34.1.</span> <span class="toc-text">8.1 搭建生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">34.2.</span> <span class="toc-text">8.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">34.2.1.</span> <span class="toc-text">8.2.1 配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">34.3.</span> <span class="toc-text">8.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">35.</span> <span class="toc-text">9. 顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">35.1.</span> <span class="toc-text">9.1 搭建生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">35.1.1.</span> <span class="toc-text">9.1.1 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-Demo01Controller"><span class="toc-number">35.1.2.</span> <span class="toc-text">9.1.2 Demo01Controller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">35.2.</span> <span class="toc-text">9.2 搭建消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">35.3.</span> <span class="toc-text">9.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">36.</span> <span class="toc-text">10. 消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">36.1.</span> <span class="toc-text">10.1 搭建生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-Demo01Controller"><span class="toc-number">36.1.1.</span> <span class="toc-text">10.1.1 Demo01Controller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">36.2.</span> <span class="toc-text">10.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-Demo01Consumer"><span class="toc-number">36.2.1.</span> <span class="toc-text">10.2.1 Demo01Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">36.3.</span> <span class="toc-text">10.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF-1"><span class="toc-number">37.</span> <span class="toc-text">11. 事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">37.1.</span> <span class="toc-text">11.1 搭建生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">37.1.1.</span> <span class="toc-text">11.1.1 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-3-Demo01Controller"><span class="toc-number">37.1.2.</span> <span class="toc-text">11.1.3 Demo01Controller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">37.2.</span> <span class="toc-text">11.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">37.2.1.</span> <span class="toc-text">11.2.1 配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">37.3.</span> <span class="toc-text">11.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%9A%84%E6%8F%90%E4%BA%A4%E6%9C%BA%E5%88%B6-1"><span class="toc-number">38.</span> <span class="toc-text">12. 消费进度的提交机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">38.1.</span> <span class="toc-text">12.1 搭建生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">38.2.</span> <span class="toc-text">12.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">38.2.1.</span> <span class="toc-text">12.2.1 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2-Demo01Consumer"><span class="toc-number">38.2.2.</span> <span class="toc-text">12.2.2 Demo01Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">38.3.</span> <span class="toc-text">12.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">39.</span> <span class="toc-text">13. 批量发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">39.1.</span> <span class="toc-text">13.1 搭建生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">39.1.1.</span> <span class="toc-text">13.1.1 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-Demo01Controller"><span class="toc-number">39.1.2.</span> <span class="toc-text">13.1.2 Demo01Controller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">39.2.</span> <span class="toc-text">13.2 搭建消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">39.3.</span> <span class="toc-text">13.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">40.</span> <span class="toc-text">14. 批量消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">40.1.</span> <span class="toc-text">14.1 搭建生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">40.2.</span> <span class="toc-text">14.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">40.2.1.</span> <span class="toc-text">14.2.1 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-Demo01Consumer"><span class="toc-number">40.2.2.</span> <span class="toc-text">14.2.2 Demo01Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">40.3.</span> <span class="toc-text">14.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9"><span class="toc-number">41.</span> <span class="toc-text">15. 监控端点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">41.1.</span> <span class="toc-text">15.1 搭建生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">41.1.1.</span> <span class="toc-text">15.1.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">41.1.2.</span> <span class="toc-text">15.1.2 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">41.1.3.</span> <span class="toc-text">15.1.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E6%90%AD%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">41.2.</span> <span class="toc-text">15.2 搭建消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">41.2.1.</span> <span class="toc-text">15.2.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">41.2.2.</span> <span class="toc-text">15.2.2 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">41.2.3.</span> <span class="toc-text">15.2.3 简单测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-6"><span class="toc-number">42.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E4%B8%AD%E7%9A%84Kafka"><span class="toc-number">43.</span> <span class="toc-text">SpringCloud事件总线中的Kafka</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%93-7"><span class="toc-number">44.</span> <span class="toc-text">——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-3"><span class="toc-number">45.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">46.</span> <span class="toc-text">2. 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%99%A8%E9%A1%B9%E7%9B%AE"><span class="toc-number">46.1.</span> <span class="toc-text">2.1 事件发布器项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">46.1.1.</span> <span class="toc-text">2.1.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">46.1.2.</span> <span class="toc-text">2.1.2 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-UserRegisterEvent"><span class="toc-number">46.1.3.</span> <span class="toc-text">2.1.3 UserRegisterEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-DemoController"><span class="toc-number">46.1.4.</span> <span class="toc-text">2.1.4 DemoController</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-PublisherDemoApplication"><span class="toc-number">46.1.5.</span> <span class="toc-text">2.1.5 PublisherDemoApplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E9%A1%B9%E7%9B%AE"><span class="toc-number">46.2.</span> <span class="toc-text">2.2 事件监听器项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">46.2.1.</span> <span class="toc-text">2.2.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">46.2.2.</span> <span class="toc-text">2.2.2 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-UserRegisterEvent"><span class="toc-number">46.2.3.</span> <span class="toc-text">2.2.3 UserRegisterEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-UserRegisterListener"><span class="toc-number">46.2.4.</span> <span class="toc-text">2.2.4 UserRegisterListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-ListenerDemoApplication"><span class="toc-number">46.2.5.</span> <span class="toc-text">2.2.5 ListenerDemoApplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">46.3.</span> <span class="toc-text">2.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9"><span class="toc-number">47.</span> <span class="toc-text">3. 监控端点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-1"><span class="toc-number">47.1.</span> <span class="toc-text">3.1 引入依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">47.2.</span> <span class="toc-text">3.2 配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">47.3.</span> <span class="toc-text">3.3 简单测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%9B%86%E6%88%90%E5%88%B0-Spring-Cloud-Config"><span class="toc-number">48.</span> <span class="toc-text">4. 集成到 Spring Cloud Config</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3969/" title="Markdown语法学习"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F11cda97e6af907b5b2158e1dd78bdd6a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown语法学习"/></a><div class="content"><a class="title" href="/posts/3969/" title="Markdown语法学习">Markdown语法学习</a><time datetime="2025-03-06T15:42:14.000Z" title="发表于 2025-03-06 23:42:14">2025-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/47929/" title="typora图床搭建+完美解决PicGo图片上传重命名问题"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Ffb9b51a1bdaac4d95266344a1421aedf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typora图床搭建+完美解决PicGo图片上传重命名问题"/></a><div class="content"><a class="title" href="/posts/47929/" title="typora图床搭建+完美解决PicGo图片上传重命名问题">typora图床搭建+完美解决PicGo图片上传重命名问题</a><time datetime="2025-03-05T16:58:31.000Z" title="发表于 2025-03-06 00:58:31">2025-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/60895/" title="测试文件2"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F546d1ae418f905dccc0f7b3674a0f6e0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试文件2"/></a><div class="content"><a class="title" href="/posts/60895/" title="测试文件2">测试文件2</a><time datetime="2025-03-05T16:00:00.000Z" title="发表于 2025-03-06 00:00:00">2025-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/13423/" title="离散数学学习笔记"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F013f3144c6fd4dabceb0ff25ba9a35a4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散数学学习笔记"/></a><div class="content"><a class="title" href="/posts/13423/" title="离散数学学习笔记">离散数学学习笔记</a><time datetime="2025-03-04T16:00:47.000Z" title="发表于 2025-03-05 00:00:47">2025-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/52481/" title="ElasticSearch入门到精通"><img src="https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2Fe69b8f01e7d0f2581a3d4bfe20e93a23.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch入门到精通"/></a><div class="content"><a class="title" href="/posts/52481/" title="ElasticSearch入门到精通">ElasticSearch入门到精通</a><time datetime="2025-03-04T15:34:24.000Z" title="发表于 2025-03-04 23:34:24">2025-03-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://typora-1329750222.cos.ap-chengdu.myqcloud.com/img/2025%2F03%2F0325c825fa31fa6f45916f706a22cca4.png);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Chen Jiabin</div><div class="footer_custom_text">我的心是簇拥烈日的花,在你的眼里找到了家</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.1/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://blog.meng-project.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://unpkg.com/@waline/client@v3/dist/waline.css')
        .then(() => import('https://unpkg.com/@waline/client@v3/dist/waline.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://lustrous-frangollo-1c41d7.netlify.app/.netlify/functions/twikoo',
      region: 'ap-chengdu',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://lustrous-frangollo-1c41d7.netlify.app/.netlify/functions/twikoo',
      region: 'ap-chengdu',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.41/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Waline' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Waline' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="3136952023" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-fluttering-ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="开始搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>